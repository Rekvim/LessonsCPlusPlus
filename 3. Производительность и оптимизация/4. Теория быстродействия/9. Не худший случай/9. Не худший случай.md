## Не худший случай

Чтобы оценить, сколько примерно времени будет работать ваш алгоритм, ориентируйтесь на правило: ядро процессора выполняет около миллиарда действий в секунду. Оценка грубая, но в некоторых случаях она полезна. Количество действий можно посчитать теоретически. Разберёмся, всегда ли теория верна.

В начале темы мы рассмотрели функцию, которая определяет, одинаковые ли элементы в двух векторах. Вспомним код:
```cpp
// O(n²)
bool TestPermut(const vector<int>& v1, const vector<int>& v2) {
    // если они разной длины, элементы заведомо разные
    if (v1.size() != v2.size()) {
        return false;
    }

    for (int i : v1) {
        // проверяем, что каждый элемент первого вектора
        // содержится одинаковое количество раз в обоих векторах
        if (count(v1.begin(), v1.end(), i) != count(v2.begin(), v2.end(), i)) {
            return false;
        }
    }

    return true;
}

// O(n log n)
bool TestPermut2(const vector<int>& v1, const vector<int>& v2) {
    auto v1_copy = v1;
    auto v2_copy = v2;

    std::sort(v1_copy.begin(), v1_copy.end());
    std::sort(v2_copy.begin(), v2_copy.end());

    return v1_copy == v2_copy;
} 
```

Возможно, вы обратили внимание на странный момент: наивный квадратичный алгоритм из условия быстро завершался при первом запуске, но для ответа `true` ему нужно было много времени. А второй алгоритм всегда работает примерно одинаково быстро. Сравним алгоритмы на сильно различающихся векторах из 500 000 элементов:
```
O(n²): 2 ms
O(n log n): 181 ms 
```
Может показаться, что теория обманывает. Сделаем векторы похожими:
```cpp
int main() {
    std::mt19937 g;

    // ...

    v2 = v1;
    shuffle(v2.begin(), v2.end(), g);
    v2[rand() % v2.size()]++;

    // ...
} 
```
Различие только в одном элементе со случайным индексом. Результаты работы:
```
O(n²): 2286 ms
O(n log n): 178 ms 
```
На этот раз всё как и должно быть.

Если векторы существенно отличаются, первый алгоритм быстро найдёт элемент, который есть в первом векторе, но отсутствует во втором. После этого алгоритм сразу завершится. Но для ответа `true` ему понадобится много времени. А второй, быстрый алгоритм будет в любом случае выполнять две сортировки — в этом смысле он более стабильный.

Подобный эффект можно наблюдать и с `upper_bound`. В уроке о логарифме вы увидели, что этот алгоритм сильно выигрывает у `find_if`. Посмотрим, всегда ли. Вернёмся к тому примеру, но теперь вместо 500 000 000 будем искать число, превышающее 100:
```cpp
...
int result_number;
{
    LOG_DURATION("std::upper_bound"s);
    for (int i = 0; i < SEARCHES; ++i) {
        auto iter = upper_bound(nums.begin(), nums.end(), 100);
        result_number = *iter;
    }
}
cout << result_number << endl;

{
    LOG_DURATION("std::find_if"s);
    for (int i = 0; i < SEARCHES; ++i) {
        auto iter = find_if(nums.begin(), nums.end(), [](int x) {
            return x > 100;
        });
        result_number = *iter;
    }
}
cout << result_number << endl;
... 
```
Результат может быть таким:
```
std::upper_bound: 58 ms
352
std::find_if: 0 ms
352 
```
Оба алгоритма выдали одинаковый результат, но find_if сделал это гораздо быстрее вопреки теории.

Проходя вектор, `find_if` быстро находит нужное число, в то время как `upper_bound` в любом случае будет сходиться к нему бинарным поиском. Однако это не значит, что нужно всегда использовать `find_if` — в среднем `upper_bound` гораздо быстрее.

Из этих примеров можно сделать важный вывод: теоретическая оценка даёт верхнюю границу сложности, но иногда она слишком груба. Надо принимать во внимание специфику задачи.