## Улучшаем сложность

В предыдущих уроках было много слов, но мало дела. Исправим это скорее. Начнём с примера. В конце урока вы ускорите его в десятки раз.

Даны два вектора чисел. Нужно определить, содержат ли они в точности одинаковые элементы. Элементы в векторах могут быть в разном порядке.

Решение:

```cpp
#include <algorithm>
#include <vector>

using namespace std;

// функция возвращает true, если векторы из одинаковых элементов
bool TestPermut(const vector<int>& v1, const vector<int>& v2) {
    // если они разной длины, элементы заведомо разные
    if (v1.size() != v2.size()) {
        return false;
    }

    for (int i : v1) {
        // проверяем, что каждый элемент первого вектора
        // содержится одинаковое количество раз в обоих векторах
        if (count(v1.begin(), v1.end(), i) != count(v2.begin(), v2.end(), i)) {
            return false;
        }
    }

    return true;
} 
```

Измерим время работы цикла. Он совершает $N$ итераций. Каждая итерация два раза вызывает алгоритм `count`. В документации сказано, что его сложность в худшем случае — это линейное количество константных сравнений относительно расстояния между итераторами, то есть $O(N)$. Сделать $N$ раз $O(N)$ — это $O(N^2)$.

Такие сложности есть у массы методов и алгоритмов в стандартной библиотеке. Вы можете самостоятельно убедиться в этом, изучая их страницы на cppreference.com.

Часто сложность можно определить интуитивно, представив, как именно работает функция. Приведём несколько примеров. Постарайтесь в каждом из них понять, почему сложность именно такая.

В частности, $O(1)$ — это сложность:
- получения или изменения элемента `vector`, `deque`, `string`, `list` по итератору;

- получения или изменения элемента `vector` и `string` по индексу;
  
- перемещения итератора `vector` или `deque` на произвольное число в любую сторону;
  
- перемещение итератора map или `set` на один элемент;
  
- вставки в `stack`, в конец `vector`, в начало или конец `deque`, в любое место `list` по итератору. Для вектора эта сложность амортизированная. Что это значит, вы узнаете в одном из следующих уроков;

- удаления в аналогичных случаях.
  
В одной из прошлых тем вы реализовали стек, который выдаёт наименьший элемент. Сложность получения элемента из такого стека константная — $O(1)$.

$O(N)$ — это сложность:
- любых алгоритмов, которые один раз проходят от одного итератора до другого: find, find_if, iota, count, count_if, transform;
- копирования любого контейнера или строки: vector, set, map, deque, stack;
  
- деструктора любого контейнера;

- сравнения контейнеров, строк;
- вставки в начало или середину vector, середину deque;
- удаления в аналогичных случаях.

Для методов контейнера параметр $N$ — это количество элементов контейнера, для алгоритмов — расстояние между итераторами.

Все указанные сложности верны, если такие операции с элементами контейнера как удаление, копирование и сравнение константны, то есть имеют сложность $O(1)$. Иначе нужна другая оценка. Например, если есть вектор строк длины не более $L$, сравнение таких строк требует в худшем случае $O(L)$ операций. Сравнение векторов размера $N$ из таких строк будет иметь сложность $O(NL)$.