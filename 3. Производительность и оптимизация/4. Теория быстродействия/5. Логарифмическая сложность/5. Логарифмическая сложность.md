## Логарифмическая сложность

Рассмотрим такую задачу. В восьмиэтажном доме поселилась невезучая обезьяна, которая очень любит орехи. Орехи она находит неподалёку. Только вот беда — ей совершенно нечем их колоть. Обезьяна хоть и невезучая, но хитрая. Она решила сбрасывать орехи из окна и таким образом разбивать их. Обезьяна успешно расколола орех, кинув его с верхнего, восьмого этажа. Чтобы не подниматься каждый раз так высоко, обезьяна хочет найти самый низкий этаж, при броске с которого орехи разбиваются. Все орехи одинаковые и все броски одинаковые, так что любые два броска с одного этажа будут иметь одинаковый результат.

Когда обезьяна совершает бросок, например, с пятого этажа, она делит этажи на две части. Если бросок успешный, нужный этаж — пятый или ниже. Если неуспешный, нужный этаж выше — шестой, седьмой или восьмой. Поскольку обезьяна невезучая, скорее всего, каждый раз будет выпадать большая часть: в этом конкретном примере — с первого по пятый. Лучший способ — делать части равными, бросая со среднего этажа. Тогда количество вариантов будет каждый раз сокращаться вдвое: после первого броска обезьяна будет рассматривать четыре этажа, после второго — два, после третьего найдёт нужный.

![alt text](image.png)

Число восемь выбрано для условия задачи отнюдь не случайно: чтобы обезьяна могла постоянно делить на два. Также подойдёт любая степень двойки: 2, 4, 8, 16, 32.

Если удвоить количество этажей, обезьяне понадобится всего на один бросок больше. Предложенное решение — пример так называемого логарифмического алгоритма, то есть алгоритма сложности $O(logN)$. Для $N$-этажного здания количество бросков, которое нужно совершить обезьяне, — это двоичный логарифм числа $N$.

У логарифмической зависимости есть особенность: если увеличить аргумент $N$ в несколько раз, количество действий увеличится на несколько штук. Например, увеличили количество этажей в два раза, а количество необходимых бросков возросло на один. Или увеличили число в десять раз, а количество цифр увеличилось на одну. Можно повторить операцию увеличения числа в десять раз шестикратно, и число возрастёт в миллион раз, а количество цифр всего лишь шесть раз увеличится на единицу. Это очень маленький рост.

Важный пример логарифмического алгоритма — бинарный поиск, который использовала хитрая обезьяна. Он реализован в уже известных вам алгоритмах `binary_search`, `lower_bound` и `upper_bound`.

Вы применяете похожий алгоритм, когда ищете слово в словаре. Вряд ли вы просматриваете каждую страницу, начиная с первой, — поиск был бы слишком долгим. Скорее всего, вы открываете словарь в случайном месте и проверяете, раньше или позже находится ваше слово, постепенно сужая круг поиска. Бинарный поиск в контейнере можно применять только если элементы уже упорядочены, как слова в словаре.

Поиграйте с кем-нибудь из близких в игру: попросите загадать число от одного до восьми и написать его на бумажке. Затем задавайте об этом числе вопросы, подразумевающие ответы «да» или «нет». Например: «У тебя число от одного до четырёх?». Угадайте число за три вопроса. Увеличьте диапазон до 1...16 и количество вопросов до четырёх. Затем до 1...32 и пяти вопросов.

Всего одним вопросом вы можете удвоить количество вариантов. Так и работает бинарный поиск.

Проверим, действительно ли `upper_bound` так эффективен, как подсказывает теория. Создадим отсортированный вектор из миллиона случайных чисел от 0 до 1 000 000 000 и тысячу раз поищем первое число, превышающее 500 000 000:

```cpp
int main() {
    static const int NUMBERS = 1'000'000;
    static const int SEARCHES = 1'000;
 
    mt19937 generator;
    uniform_int_distribution<int> uniform_dist(0, 1'000'000'000);

    vector<int> nums;
    for (int i = 0; i < NUMBERS; ++i) {
        int random_number = uniform_dist(generator);
        nums.push_back(random_number);
    }
    sort(nums.begin(), nums.end());

    ...
} 
```

В первом случае применим для поиска алгоритм `upper_bound`, а во втором — `find_if`. Алгоритм `find_if` просматривает контейнер, пока не найдёт нужное значение, его сложность $O(N)$:

```cpp
    ...
    
    int result_number;
    {
        LOG_DURATION("std::upper_bound"s);
        for (int i = 0; i < SEARCHES; ++i) {
            auto iter = upper_bound(nums.begin(), nums.end(), 500'000'000);
            result_number = *iter;
        }
    }
    cout << result_number << endl;

    {
        LOG_DURATION("std::find_if"s);
        for (int i = 0; i < SEARCHES; ++i) {
            auto iter = find_if(nums.begin(), nums.end(), [](int x) {
                return x > 500'000'000;
            });
            result_number = *iter;
        }
    }
    cout << result_number << endl; 
```

Посмотрим на результат:

```
std::upper_bound: 0 ms
500000367
std::find_if: 623 ms
500000367 
```

Результат получился одинаковый, но `upper_bound` выдала его в сотни раз быстрее. Вот она, сила логарифма!

В стандартной библиотеке логарифмическая сложность встречается часто. Её имеют следующие методы и алгоритмы:

- вставка одного элемента в `set` и `map` и удаление из них;
- поиск элемента в `set` и `map`;
- методы `lower_bound`, `upper_bound` для `set` и `map`;

- бинарный поиск по отсортированному `s` или `deque`: `binary_search`, `lower_bound`, `upper_bound`.

Для методов контейнера параметр $N$ — это количество элементов контейнера, а для алгоритмов — расстояние между итераторами.

Логарифмическая сложность так часто встречается в методах `set` и `map`, потому что в них использованы деревья поиска, имеющие логарифмическую глубину.

