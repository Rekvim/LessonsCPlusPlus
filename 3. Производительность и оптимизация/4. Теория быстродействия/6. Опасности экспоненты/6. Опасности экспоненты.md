## Опасности экспоненты

Логарифм — отличная вещь. Число может быть большим, например сто миллионов, а цифр в нём будет всего девять. Девять операций лучше, чем сто миллионов. Но бывает логарифм «наоборот». Он  называется экспонента.

Вспомните задачу о числах Фибоначчи. Эти числа $F_n$ задаются так: $F_0 = 0$, $F_1 = 1$, а остальные получаются по формуле $Fn=F_{n−1} + F_{n−2}$.

Ваше решение могло выглядеть так:

```cpp
#include <cstdint>
#include <iostream>
#include <string>

using namespace std;

// числа Фибоначчи довольно быстро растут, используем int64_t
int64_t F(int i) {
    // тут обработаем i == 0 и i == 1
    if (i <= 0) {
        return 0;
    }

    if (i == 1) {
        return 1;
    }

    // рекурсивно вызовем саму функцию F
    return F(i - 1) + F(i - 2);
}

int main() {
    int i;

    while (true) {
        cout << "Введите индекс: "s;
        if (!(cin >> i)) {
            break;
        }

        cout << "Fi = "s << F(i) << endl;
    }
} 
```
Сомнения может вызвать рекурсия. Функция `F` вызывается многократно. Но глубина рекурсии не превышает `i`. В наших примерах `i` будет в пределах 100, что вполне допустимо. 

Попробуем запустить программу на нескольких примерах. На первый взгляд программа работает неплохо:

```
Введите индекс: 0
Fi = 0
Введите индекс: 1
Fi = 1
Введите индекс: 2
Fi = 1
Введите индекс: 3
Fi = 2
Введите индекс: 4
Fi = 3
Введите индекс: 5
Fi = 5
Введите индекс: 6
Fi = 8
Введите индекс: 10
Fi = 55
Введите индекс: 20
Fi = 6765
Введите индекс: 30
Fi = 832040
Введите индекс: 40
Fi = 102334155 
```

Но перед вычислением 40-го числа возникла подозрительная пауза. Попробуйте запустить программу с индексом 45. Поначалу может показаться, что программа зависла. Но в конце концов она выдаст результат:
```
Введите индекс: 45
Fi = 1134903170 
```
У программы такой простой код, но уже явные проблемы с производительностью! Чтобы оценить их, измерим время, внеся изменения в `main`:
```cpp
...

int main() {
    for (int i = 0; i < 100; ++i) {
        int64_t fi;
        {
            LOG_DURATION("Number "s + std::to_string(i));
            fi = F(i);
        }
        cout << fi << endl;
    }
} 
```
Посмотрим, что выдаст программа:
```
Number 0: 0 ms
0
Number 1: 0 ms
1
Number 2: 0 ms
1
...
Number 27: 3 ms
196418
Number 28: 3 ms
317811
Number 29: 7 ms
514229
Number 30: 12 ms
832040
Number 31: 15 ms
1346269
Number 32: 36 ms
2178309
Number 33: 96 ms
3524578
...
Number 43: 4004 ms
433494437
Number 44: 6674 ms
701408733
Number 45: 10793 ms
1134903170
Number 46: 17412 ms
1836311903 
```

Проблемы начались примерно с 27-го числа и начали увеличиваться лавинообразно, когда количество миллисекунд само стало напоминать числа Фибоначчи. Если подумать, сколько операций совершит вызов `F`, можно понять: это вовсе не случайность. `F` вызывает две такие же функции и будет работать примерно столько, сколько обе они вместе взятые — точь-в-точь как в формуле самих чисел. Если так пойдёт и дальше, для вычисления 80-го числа понадобится примерно восемь лет.

Количество операций возрастает минимум в два раза каждые два числа. Такая сложность называется экспоненциальной и обозначается $O(a^N)$. Как правило, программы, имеющие такую сложность, непригодны для использования, потому что требуют колоссального времени даже при маленьких входных данных.

С экспоненциальной сложностью связана одна из самых знаменитых проблем информатики — проблема классов P и NP. Она заключается в поиске более быстрого, чем экспоненциальный, алгоритма для ряда задач, либо доказательства, что такого алгоритма не существует. В случае положительного решения проблемы, P и NP банковские и криптографические системы окажутся в опасности. Многие алгоритмы шифрования основаны на предположении, что такого алгоритма для NP-задач не существует.