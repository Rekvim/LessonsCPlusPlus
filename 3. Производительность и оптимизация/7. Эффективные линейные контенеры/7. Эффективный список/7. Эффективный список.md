## Эффективный список
В предыдущем спринте вы написали свой односвязный список. В стандартной библиотеке есть похожий контейнер, но двусвязный. Разница лишь в том, что перемещаться по нему можно не только вперёд, но и назад. 

В векторе все элементы расположены последовательно в одном участке памяти. В деке элементы находятся в памяти в небольших чанках. Продолжая идею уменьшения количества последовательно расположенных элементов, приходим к выделению отдельного участка памяти для каждого элемента. При этом каждый элемент будет знать, где лежит предыдущий и следующий.

Рассмотрим удаление элемента из списка:
```cpp
list<int> numbers = {1, 2, 3, 4};
auto it = find(numbers.begin(), numbers.end(), 3);
numbers.erase(it); 
```

Чтобы найти элемент в списке, используем функцию `find`. Как и у других линейных контейнеров, собственного метода `find` у списка нет. Это значит, что поиск будет осуществляться за линейное время и потребует прохода по всем элементам один за другим.

Найдя тройку, вызываем метод `erase`, который правильно перенаправляет указатели предыдущего и следующего элемента. Время удаления константное.
Вспомните, какова сложность удаления элемента из вектора и дека.

Со вставкой элемента то же самое. Выделяется память под элемент, верно расставляются связи. Таким образом, и вставка, и удаление из середины работают для списка быстрее, чем для вектора и дека.

Функциональность списков ограничена, в том числе потому, что быстро получить доступ к элементу по его индексу невозможно. У списка двунаправленный итератор, а не итератор произвольного доступа. Это усложняет — а иногда делает невозможным — работу некоторых алгоритмов. Например, функцию бинарного поиска для списка использовать нельзя, так как эта функция требует итераторы произвольного доступа.

С другой стороны, алгоритм `reverse` существует в виде метода списка, и в реализации этого метода нет переставления элементов местами, что может быть достаточно затратно. Метод `reverse` просто переставляет указатели на соседние элементы. 

Преимущество списка в том, что его устройство позволяет оставлять итераторы рабочими. Ни один из других изученных контейнеров такой возможности не предоставлял. Ни вставка, ни удаление, ни какое-либо другое изменение не инвалидируют итераторы списка — если, конечно, вы не удалили тот элемент, на который итератор указывал. В этом случае чуда не произойдёт, и итератор будет инвалидирован.

Ещё менее популярный контейнер, основанный на том же принципе, — `forward_list`, однонаправленный список. Он может подойти, если нужно итерировать по элементам только в одну сторону, так как в этом случае экономится память. Каждый элемент помнит указатель только на следующий элемент, но не на предыдущий.

Перед тем как приступить к заданию, изучите документацию по следующим методам:
- insert
- assign
- erase
- unique
- remove
- sort