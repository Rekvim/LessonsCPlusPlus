## Инвалидация итераторов

Вспомните, что происходит с указателями при операциях вставки/удаления в дек и вектор.


Для какого контейнера верно каждое утверждение:
Указатели инвалидируются всегда - Вектор
Ссылки инвалидируются всегда - Вектор
При вставке/удалении в начало или в конец указатели и ссылки сохраняются - Дек
При вставке/удалении в середину указатели и ссылки сохраняются - Ни то, ни другое
При вставке/удалении в середину указатели и ссылки инвалидируются - И то, и другое

Ссылки не инвалидируются никогда - Ни то, ни другое

Указатели не инвалидируются никогда - Ни то, ни другое

Указатели и ссылки ведут себя одинаково. У вектора они инвалидируются всегда. У дека они сохраняются при вставке в начало или в конец, но инвалидируются при вставке в середину. Утверждение «При вставке/удалении в середину указатели и ссылки инвалидируются» подходит для обоих контейнеров.

Разберёмся, что происходит с итераторами. В целом они умнее обычных ссылок и указателей, поэтому у них есть шансы спастись после изменения контейнера. Поэкспериментируем:
```cpp
int main() {
    // создадим вектор с одним элементом
    vector<int> numbers = {1};
    // найдём итератор на начало
    auto it = numbers.begin();
    cout << *it << endl;
    // вставим достаточно много элементов,
    // чтобы точно вызвать перевыделение памяти
    for (int i = 0; i < 1000; ++i) {
        numbers.push_back(i);
    }
    cout << *it << endl;
} 
```
После работы программы увидим на экране:
```
1
8264304 
```
Второе число может быть другим, это просто мусор. Выходит, итератор вектора инвалидировался. В целом ожидаемо, так как внутри итератора находится указатель, который, как вы уже знаете, точно инвалидируется.

Проведём аналогичный эксперимент с деком. В том же примере заменим контейнер:

```cpp
int main() {
    // заменим контейнер
    deque<int> numbers = {1};
    ...
} 
```

Результат на экране:
```
1
1 
```
Значение элемента не изменилось. Выглядит многообещающе, но итераторы нужны, чтобы итерировать. Проверим, способен ли ещё на это наш итератор:
```cpp
int main() {
    deque<int> numbers = {1};
    auto it = numbers.begin();
    cout << *it << endl;

    for (int i = 0; i < 1024; ++i) {
        numbers.push_back(i);
    }
    // попытаемся вывести последний элемент из дека
    cout << *it << " " << *(it + numbers.size() - 1) << endl;
} 
```
Запустите программу выше в своей IDE и отметьте, что получилось:

Правильный ответ:
Всё сломалось!

Итератор очень старался, но не смог. И всё сломалось. Значит, итераторы инвалидировались несмотря на все старания.

Резюме: операции с изменением числа элементов инвалидируют итераторы и у вектора, и у дека.