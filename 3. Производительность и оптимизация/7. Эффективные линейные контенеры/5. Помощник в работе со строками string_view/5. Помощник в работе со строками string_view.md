## Помощник в работе со строками: std::string_view

Строки похожи на вектор. Их элементы расположены последовательно в памяти. Они поддерживают доступ к элементам по номеру позиции. Разница в том, что строки содержат элементы только символьного типа. Но иногда мы ждем от строк большего, чем от вектора. Обычно строки содержат слова, и будет удобно уметь работать со словами, не создавая из строки новые строки, как мы делали это раньше.

#### Ускоряем разделение строки на слова

Вспомним пример из поискового сервера:
```cpp
vector<string> SplitIntoWords(const string& text) {
    vector<string> words;
    string word;
    for (const char c : text) {
        if (c == ' ') {
            if (!word.empty()) {
                // обратите внимание на это место в коде
                // здесь мы каждый раз копируем найденное слово
                // в новый элемент в векторе
                words.push_back(word);
                word.clear();
            }
        } else {
            word += c;
        }
    }
    if (!word.empty()) {
        words.push_back(word);
    }
    return words;
}
```
Этот код можно переписать, используя итераторы и алгоритм `find`. Но если посмотреть внимательно, код замедляется не из-за того, как именно мы итерируемся по строке. Каждый раз при добавлении элемента в вектор `words` создаётся новая строка — копия слова из `text`. Это не самый быстрый метод, тем более мы просто хотим знать, где у слов начало и конец. Нам нужны не новые строки, а только позиции в уже имеющейся строке. Для подобных задач и создан `std::string_view`. Разберёмся с нашей функцией:

```cpp
#include <string_view> // Для использования string_view

// изменим название функции
// предыдущая её версия нам ещё пригодится

// пусть теперь наша функция возвращает вектор элементов string_view
vector<string_view> SplitIntoWordsView(const string& str) {
    vector<string_view> result;
    // 1
    auto pos = str.find_first_not_of(" ");
    // 2
    const auto pos_end = str.npos;
    // 3
    while (pos != pos_end) {
        // 4
        auto space = str.find(' ', pos);
        // 5
        result.push_back(space == pos_end ? str.substr(pos) : str.substr(pos, space - pos));
        // 6
        pos = str.find_first_not_of(" ", space);
    }

    return result;
} 
```
По сути, `string_view` — указатель на начало некой строки и её длина. Это не контейнер в прямом смысле: он не содержит элементы, а просто указывает на некую последовательность символов в памяти.

Новая функция вернёт вектор из `string_view`, то есть вектор указателей, на начало слов и их дли́ны. Как раз то, что нам и было надо — избежим копирования слов в вектор.

Рассмотрим реализацию по пунктам. Следите по комментариям к функции:
1. Создаём переменную, где будем сохранять начальную позицию для поиска следующего пробела. Иначе говоря, начало слова. Устанавливаем её на позицию первого непробельного символа.

2. Чтобы остановить поиск, нужен аналог итератора на конец. У `string` и `string_view` такую роль выполняет `npos` — специальная константа класса. Внутри это просто большое число, которое вряд ли когда-нибудь сможет оказаться реальной позицией в строке.
   
3. Используем цикл. Выходим из него, если не удалось найти непробельный символ.
   
4. В цикле ищем следующий пробел, вызывая метод `find`, который вернёт позицию ближайшего пробела, или `npos`, если пробел не найден.
   
5. Если пробел не найден, добавляем в вектор всё, начиная с `pos`. Если найден, выделяем слово от `pos` длиной `space - pos`.
   
6. Достигнув конца строки, выходим из цикла. Иначе, пропускаем одну позицию — пробел — и начинаем следующую итерацию цикла.

Запустим бенчмарк, где вызовем старую и новую функцию для большой строки:

```cpp
// создадим очень длинную строку,
// состоящую из слов из ста 'a'
string GenerateText() {
    const int SIZE = 10000000;
    string text(SIZE, 'a');
    for (int i = 100; i < SIZE; i += 100) {
        text[i] = ' ';
    }
    return text;
}

int main() {
    const string text = GenerateText();
    {
        LOG_DURATION("string");
        const auto words = SplitIntoWords(text);
        // выведем первое слово
        cout << words[0] << "\n";
    }
    {
        LOG_DURATION("string_view");
        const auto words = SplitIntoWordsView(text);
        // выведем первое слово
        cout << words[0] << "\n";
    }

    return 0;
} 
```
Результат работы (с максимальной оптимизацией):

```
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
string: 34 ms
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
string_view: 13 ms 
```
Неплохо.

#### Но есть подвох
Поправим так, чтобы строка, которую нужно обработать, стала короткой:

```cpp
int main() {
    const string text = "a b";
    {
        LOG_DURATION("string");
        const auto words = SplitIntoWords(text);
        cout << words[0] << "\n";
    }
    {
        LOG_DURATION("string_view");
        const auto words = SplitIntoWordsView(text);
        cout << words[0] << "\n";
    }

    return 0;
} 
```

Запустим и удивимся:

```
a
string: 0 ms
⍰
string_view: 0 ms 
```

Там, где мы ожидали увидеть `a`, внезапно вывелся неизвестный символ.

Вы близко подошли к пониманию, что такое временные объекты. В данном случае имеем дело именно с ними. `substr` конструирует собственную строку. Она потом превращается в элемент типа `string_view`, чтобы быть записанной в вектор. Подробнее временные объекты разберём в следующей теме.

`string_view` — это указатель на строчку, которую мы никуда не сохранили. Она появилась и исчезла, а мы положили в вектор указатель на что-то переставшее существовать.

Обращение к несуществующему объекту — пример неопределённого поведения. Поведение программы при этом может быть любым. Даже соответствующим нашему представлению о правильной работе. Так получилось в предыдущем примере — мы увидели то слово, которое ожидали. В этом и состоит опасность неопределённого поведения — время от времени может возникать результат который выглядит правильным и кажется, что всё хорошо.

Чтобы исправить ситуацию, заменим тип аргумента. Пусть пользователь передаёт  `string_view` и сам заботится о том, чтобы строка не оказалась временной. Декларируя таким образом тип аргумента, говорим пользователю, что мы не в ответе за объект самой строки. Если строка исчезнет, все результаты работы функции будут инвалидированы:
```cpp
vector<string_view> SplitIntoWordsView(string_view str) {
    ...
    result.push_back(space == pos_end ? str.substr(pos) : str.substr(pos, space - pos));
    ...
} 
```
Теперь метод `substr` работает не со строкой, а с указателем на строку. Никаких временных строк не создаётся.

В отличие от `string`, объекты `string_view` легковесные, поэтому их передают в функцию по значению, а не по константной ссылке.

Есть ещё один неочевидный бонус в использовании такой сигнатуры. Компилятор умеет превращать строки в объекты типа `string_view` . Это значит, что в функцию, ожидающую `string_view`, можно передать и строку. Все преобразования будут выполнены автоматически. Но если функция ожидает аргумент-строку, передать туда `string_view` уже не удастся — обратное преобразование из `string_view` в `string` возможно только как явное:
```cpp
void DoSomething(const string& str) { ... }

int main() {
    string_view s = "Hello"sv;
    // Явно преобразуем string_view в string
    DoSomething(string{s});
} 
```
Такая асимметрия в преобразовании между `string` и `string_view` происходит из-за того, что `string` преобразуется в `string_view` без накладных расходов. Чтобы преобразовать `string_view` в `string`, строка выделяет память и копирует в неё всё содержимое `string_view`. Такая потенциально дорогая операция требует явного преобразования.