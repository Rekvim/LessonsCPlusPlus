## Эффективный дек
Вы уже много знаете о векторе, но ещё не изучали, как работает дек, в чём его сила и слабость. С деком — двунаправленной очередью — вы познакомились в четвёртом спринте. В этом уроке рассмотрим его реализацию и выясним, в каких случаях стоит выбрать вектор, а в каких — дек.

Принципиальная разница дека и вектора: дек не обещает хранить элементы в памяти подряд. Сразу, не думая и не вникая в реализацию, можно сказать, что итерироваться по вектору должно быть проще, чем по деку. Проверим интуицию — разберёмся, как организована итерация по деку. Создадим дек, добавим в него три элемента при инициализации, потом ещё один в конец и один в начало:
```cpp
deque<int> d = {1, 2, 3};
d.push_back(4);
d.push_front(0); 
```
Будь это вектор, перевыделение памяти и копирование элементов произошли бы уже дважды — при добавлении каждого из новых элементов. Но дек работает иначе:

1. В стеке будет создан объект `d`, где сохранится количество элементов, расположенных в памяти. Кроме этого, внутри дека есть вектор, хранящий указатели на участки памяти, где находятся элементы. Иначе эти участки называются чанками. Изначально у дека будет один чанк размера три, где будут лежать элементы 1, 2 и 3.

![alt text](image.png)

2. Теперь вызовем `push_back`. Места в памяти для нового элемента нет. Дек выделит новый чанк — например, тоже размера три. Положим туда новый элемент на первое место. Не забудем добавить в вектор чанков новый указатель.

![alt text](image-1.png)

3. Пока всё идет неплохо. Вызываем `push_front`, и начинается самое интересное. Положить элемент нужно так, чтобы потом найти его по порядковому номеру. Мы же хотим удобный доступ к элементам. Секрет в том, что дек в очередной раз выделит новый чанк и положит туда 0, но не в начало, а в конец. Первые два элемента этого чанка пока останутся пустыми. Точнее там будет лежать некий мусор. Но внутри своей структуры дек держит специальный параметр "shift". Этот параметр говорит, насколько первый элемент дека сдвинут от начала чанка. В нашем случае `shift = 2`.

Подберите подходящие формулы для поиска элемента по его номеру в деке, если:

`n` — номер искомого элемента в деке,
`chunk_size` — размер чанка,
`shift` — сдвиг первого элемента относительно начала первого чанка,
`found_chunk` — номер чанка, в котором находится искомый элемент,
`found_position` — номер позиции искомого элемента внутри чанка.

Очевидно, дек легко найдёт элемент по номеру его позиции. А значит, этот контейнер отлично поддерживает итераторы произвольного доступа.

Как дек устроен изнутри, стало ясно. Теперь разберёмся, что эффективнее — дек или вектор.

Используйте свои знания о внутреннем устройстве вектора и дека и разделите утверждения в соответствии с тем, к какому контейнеру они относятся.

Дек - Эффективен в случае частых вставок в начало

Вектор - Указатели инвалидируются после вставки или удаления объектов

Дек - Указатели остаются рабочими после вставки или удаления объектов

Вектор - Вставка в начало вызывает копирование всех элементов, которые до этого были в контейнере

Вектор - Чтобы найти объект по его индексу, достаточно прибавить индекс к указателю на начало элементов

Дек -Поиск объекта по индексу требует вычислений с использованием операций деления и взятия остатка от деления

Вектор -Все элементы находятся в памяти последовательно, поэтому итерация не составляет труда

Дек -Итерация через элементы затруднена тем, что элементы могут находиться в разных частях памяти

