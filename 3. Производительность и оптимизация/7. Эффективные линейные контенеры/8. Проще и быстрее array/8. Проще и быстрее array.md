## Проще и быстрее: std::array
Подумайте, в каких случаях использовать динамическую память для хранения элементов контейнера действительно нужно. Данные в куче сохраняются даже после окончания работы функции, где была выделена память. Это полезно не всегда — до сих пор мы создавали контейнер в функции, и после её работы этот контейнер был нам больше не нужен. Динамическое выделение памяти удобно, когда не знаем, сколько точно будет элементов в контейнере. Потенциально их может оказаться как очень много, так и очень мало. Поэтому желательно выделять память «по запросу», а не резервировать лишнюю.

Но иногда мы заранее знаем, что элементов будет определённое небольшое количество. Тогда накладные расходы, связанные с выделением памяти в куче, нам не нужны — это достаточно ресурсозатратная операция. На такие случаи есть контейнер `std::array` — массив, который вообще не выделяет память в куче, а хранит всё на стеке функции.

Сначала проверим, что элементы массива действительно лежат на стеке функции. Используем простой приём:

```cpp
#include <array>
#include <iostream>

using namespace std;

int main() {
    // создадим на стеке переменные x и y,
    // положим между ними массив, заполненный восьмёрками
    int x = 111111;
    array<int, 10> numbers;
    numbers.fill(8);
    int y = 222222;
    // пройдёмся по адресам между y и x
    // и выведем то, что лежит в памяти
    for (int* p = &y; p <= &x; ++p) {
        cout << *p << " "s;
    }
    cout << endl;

    return 0;
} 
```
Результат работы программы:
```
222222 8 8 8 8 8 8 8 8 8 8 6 0 111111 
```
Вывод на экран в вашей IDE может немного отличаться, но это не меняет результата — все десять восьмёрок хранятся последовательно в стеке.

Массивы в языке С устроены так же, но всё-таки `std::array` удобнее. У него есть методы, итераторы, и его можно, например, скопировать:

```cpp
#include <array>
#include <iostream>

using namespace std;

int main() {
    array<int, 10> numbers;
    numbers.fill(8);
    // копируем массив
    const auto numbers_copy = numbers;
    // итерируем по массиву
    for (int x : numbers_copy) {
        cout << x << " ";
    }
    cout << endl;

    return 0;
} 
```
Результат работы:
```
8 8 8 8 8 8 8 8 8 8
```
Разберёмся, в каких ситуациях массив эффективнее. Представим, что у нас есть функция, которая всегда возвращает пять разных элементов. Напишем два варианта этой функции — один вариант с вектором, другой с массивом:

```cpp
#include "profile.h"

#include <array>
#include <vector>

using namespace std;

vector<int> BuildVector(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

array<int, 5> BuildArray(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

const int COUNT = 1000000;

int main() {
    {
        LOG_DURATION("vector");
        for (int i = 0; i < COUNT; ++i) {
            auto numbers = BuildVector(i);
        }
    }
    {
        LOG_DURATION("array");
        for (int i = 0; i < COUNT; ++i) {
            auto numbers = BuildArray(i);
        }
    }

    return 0;
} 
```

В `array<int, 5>` число пять означает максимальное количество элементов, которое может быть сохранено в объекте такого типа. Элементов всегда будет пять, не больше и не меньше. При этом типы `array<int, 5> `и `array<int, 4>` не будут совместимы друг с другом — они абсолютно разные. Запустим программу без оптимизации. Получим:

```
vector: 147 ms
array: 4 ms 
```
А с оптимизацией результат ещё интереснее:
```
vector: 55 ms
array: 0 ms 
```
Несмотря на то, что алгоритмическая сложность у этих двух функций одна и та же, массив работает в разы быстрее вектора.

Какая алгоритмическая сложность у измеряемых макросом `LOG_DURATION` секций?

Правильный ответ
$C⋅N$, где $C$ — количество вызовов функции, а $N$ — количество элементов в контейнере.

Неправильный ответ
$N$, где $N$ — количество элементов в контейнере.

Неправильный ответ:
$C⋅N⋅K$, где $C$ — количество вызовов функции, $N$ — количество элементов в контейнере, $K$ — некая переменная константа.


Проведём ещё один эксперимент. Добавим сортировку для массива, но не будем трогать функцию с вектором. Это увеличит алгоритмическую сложность, и она станет равна $C⋅N⋅logN$:

```cpp
#include "profile.h"

#include <algorithm>
#include <array>
#include <vector>

using namespace std;

vector<int> BuildVector(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

array<int, 5> BuildArray(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

const int COUNT = 1000000;

int main() {
    {
        LOG_DURATION("vector");
        for (int i = 0; i < COUNT; ++i) {  // C * N
            auto numbers = BuildVector(i);
        }
    }
    {
        LOG_DURATION("array");
        for (int i = 0; i < COUNT; ++i) {  // C * N * logN
            auto numbers = BuildArray(i);
            sort(begin(numbers), end(numbers));
        }
    }

    return 0;
} 
```

Посмотрим на результаты:
```
vector: 55 ms
array: 6 ms 
```
Важное наблюдение: функция с массивом всё ещё работает быстрее, хотя её алгоритмическая сложность больше. В данном случае расходы на выделение памяти для вектора оказались выше, чем добавление сортировки для массива.