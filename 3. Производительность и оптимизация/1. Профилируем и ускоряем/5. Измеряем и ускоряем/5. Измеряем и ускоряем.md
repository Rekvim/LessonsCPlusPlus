## Измеряем и ускоряем
Вы потратили много усилий на макросы и теперь ваш профилировщик готов. Посмотрим, на что он способен.

Возможно, вы догадались, почему в примере из прошлого урока так много времени занимает реверсирование вектора. А если не догадались — нестрашно, сейчас разберёмся. 

Дело в том, что когда вектор достаточно велик, вставка элементов в начало и середину — долгая операция: нужно подвинуть много элементов вправо, чтобы освободить ячейку. А мы делаем эту операцию много раз. Куда быстрее вставлять в конец — вспомните пример с чемоданом из начала курса:

Возьмём код из предыдущего урока. Изменим программу так, чтобы вставка производилась в конец. Раньше мы читали с начала и вставляли в начало. А теперь будем читать с конца и вставлять в конец. Вроде бы ничего не изменилось, но теория подсказывает, что вставка в конец эффективнее.

Чтобы изменить направление прохода по вектору, используем обратные итераторы `rbegin` и `rend`. Они работают так же, как `begin` и `end`, но проходят контейнер в обратном направлении:

```cpp
vector<int> ReverseVector2(const vector<int>& source_vector) {
    vector<int> res;

    // будем проходить source_vector задом наперёд
    // с помощью обратного итератора
    for (auto iterator = source_vector.rbegin(); iterator != source_vector.rend(); ++iterator) {
        res.push_back(*iterator);
    }

    return res;
} 
```
Не забываем в `main` поменять `ReverseVector` на `ReverseVector2` и измеряем время.
Было|Стало
|:-:|:-:|
Append random: 3 ms|	Append random: 6 ms
Reverse: 2402 ms	|Reverse: 1 ms
Counting: 38 ms	|Counting: 37 ms
Total: 2446 ms	|Total: 46 ms

Круто, производительность всей программы возросла более чем в 50 раз! Попробуем ускорить ещё. Но чтобы разница была заметной, увеличим размер вектора в 256 раз: с 2^17 до 2^25 или 33 554 432:
```cpp
static const int N = 1 << 25; 
```
Теперь измерения выглядят так:

|Стало|
|:-:|
|Append random: 1366 ms|
|Reverse: 549 ms|
|Counting: 80 ms|
|Total: 2019 ms|

Начинаем ускорять с “Append random” — самой медленной части, потому что она вносит основной вклад в скорость программы. Ведь даже если мы очень постараемся и ускорим Counting в 100 раз, производительность всей программы улучшится только на 4%, а если в 100 раз ускорить Append random, то на 67%. Разница очевидна.

При случайном заполнении вектора требуется только один бит информации, а `rand()` выдаёт как минимум 15 случайных бит. Сколько точно — зависит от операционной системы и компилятора. Используем все 15, которые нам гарантированы:
```cpp
// <algorithm> нужен для функции min
#include <algorithm>
... 
void AppendRandom2(vector<int>& v, int n) {
    for (int i = 0; i < n; i += 15) {
        int number = rand();

        // мы можем заполнить 15 элементов вектора,
        // но не более, чем нам осталось до конца:
        int count = min(15, n - i);

        for (int j = 0; j < count; ++j)
            // таким образом, получим j-й бит числа.
            // операцию побитового сдвига вы уже видели в этой программе
            // на этот раз двигаем вправо, чтобы нужный бит оказался самым последним
            v.push_back((number >> j) % 2);
    }
}
... 
```
Было|Стало
|:-:|:-:|
Append random: 1366 ms|	Append random: 620 ms
Reverse: 549 ms	|Reverse: 579 ms
Counting: 80 ms	|Counting: 81 ms
Total: 2019 ms	|Total: 1312 ms

Ускорение уже скромнее. Однако это лучше, чем ничего. Мы договорились ускорять самую медленную часть программы, но идей, как оптимизировать “Append random” пока нет. Поэтому улучшим функцию `Reverse`, вторую по скорости. Вставлять элемент в конец вектора эффективнее, чем в начало, но можно ещё ускорить процесс. Для этого зарезервируем место — применим метод `reserve`, указав количество элементов, которые будут в векторе в итоге:
```cpp
vector<int> ReverseVector3(const vector<int>& source_vector) {
    vector<int> res;
    res.reserve(source_vector.size());

    // будем проходить sourceVector задом наперёд
    // с помощью обратного итератора
    for (auto iterator = source_vector.rbegin(); iterator != source_vector.rend(); ++iterator) {
        res.push_back(*iterator);
    }

    return res;
} 
```
Было|	Стало
|:-:|:-:|
Append random: 620 ms|	Append random: 624 ms
Reverse: 579 ms	|Reverse: 194 ms
Counting: 81 ms	|Counting: 80 ms
Total: 1312 ms	|Total: 926 ms

Отлично! Не так хорошо, как при первой оптимизации, но всё-таки ускорение почти в три раза — это очень неплохо.