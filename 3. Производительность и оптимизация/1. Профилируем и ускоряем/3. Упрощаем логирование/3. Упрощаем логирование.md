## Упрощаем логирование
Выполняя задание в прошлом уроке, вы могли заметить, что расставлять отметки времени начала и конца каждой операции — довольно утомительная работа. А главное — в ней легко ошибиться и перепутать многочисленные переменные типа `time_point`. К счастью, в C++ есть механизм, который позволяет выполнять парные действия удобно и без риска ошибок.
Как вы думаете, какой механизм упростит измерение времени?

Можем использовать классы. Сейчас увидите, что конструктор и деструктор отлично решают задачу.
Создадим класс LogDuration, объект которого при создании и уничтожении будет запоминать время. При уничтожении он выведет продолжительность операции в cerr:
```cpp
class LogDuration {
public:
    LogDuration() {
    }

    ~LogDuration() {
        const auto end_time = steady_clock::now();
        const auto dur = end_time - start_time_;
        cerr << duration_cast<milliseconds>(dur).count() << " ms"s << endl;
    }

private:
    // В переменной будет время конструирования объекта LogDuration
    const steady_clock::time_point start_time_ = steady_clock::now();
}; 
```
`LogDuration` упростит профилировку. Надо просто создать переменную типа `LogDuration` с любым названием, и она автоматически измерит время, прошедшее от своего создания до выхода из области видимости. Рассмотрим работу класса `LogDuration` на примере:
```cpp
#include <chrono>
#include <iostream>
#include <thread>

using namespace std;
using namespace chrono;
using namespace literals;

class LogDuration {
public:
    LogDuration() {
    }

    ~LogDuration() {
        // эта переменная сохранит время уничтожения объекта:
        const auto end_time = steady_clock::now();
        const auto dur = end_time - start_time_;
        cerr << duration_cast<milliseconds>(dur).count() << " ms"s << endl;
    }

private:
    // Переменная будет инициализирована текущим моментом времени при
    // создании объекта класса.
    // Таким образом, она хранит время создания объекта.
    const steady_clock::time_point start_time_ = steady_clock::now();
};

int main() {
    cout << "Ожидание 5s..."s << endl;

    {
        LogDuration sleep_guard;
        // операция - ожидание 5 секунд
        this_thread::sleep_for(5s);
    }

    cout << "Ожидание завершено"s << endl;
} 
```
Запустим программу и убедимся в корректной работе `LogDuration`:
```
Ожидание 5s...
5000 ms
Ожидание завершено 
```
Всё так, как мы и ожидали. Пора опробовать новый класс в действии.