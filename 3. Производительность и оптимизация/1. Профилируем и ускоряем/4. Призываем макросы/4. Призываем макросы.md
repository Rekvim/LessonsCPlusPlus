## Призываем макросы
В прошлом уроке вы упростили профилировку. Технология, которую вы использовали, называется RAII. Она применяется не только для контроля за ресурсами, но и для планирования действия, которое должно совершиться при выходе из области видимости. Эту технологию вы подробно изучите далее в курсе.

Название переменной, которая позволила создать объект `LogDuration`, не несёт в себе никакой информации. Более того, мы даже не обращаемся к этой переменной. Чтобы скрыть ненужную информацию, используем препроцессор. С ним вы уже работали. Определим такой макрос:
```cpp
#define LOG_DURATION(x) LogDuration UNIQUE_VAR_NAME_PROFILE(x) 
```
Далее нужно разработать макрос `UNIQUE_VAR_NAME_PROFILE`, который будет выдавать уникальное имя переменной. Для профилировщика это не так важно — вряд ли у нас будут две профилировки в одном пространстве имён. Но всё-таки это удобно.

Можем использовать макрос `__LINE__`. Препроцессор заменяет его на номер строки, в которой использован этот макрос. Нам также понадобится оператор слияния лексем `##:`
```cpp
#define UNIQUE_VAR_NAME_PROFILE profile_guard_ ## __LINE__

int main() {
    int UNIQUE_VAR_NAME_PROFILE;
} 
```
Забавно, в этой программе нет `#include`, при этом она совершенно корректна, хотя ничего не делает — даже единственную переменную исключит оптимизатор. Посмотрим, что на выходе у препроцессора:
```cpp
#line 1 "main.cpp"

int main() {
    int profile_guard___LINE__;
} 
```
Этот файл мы получили, применив специальный режим компилятора. В таком режиме он запускает только препроцессор. Для компилятора GCC этот режим можно запустить из командной строки, указав специальный флаг `-E`:
```
gcc -E main.cpp -o main.i 
```
Ожидали мы не этого. Очевидно, препроцессор «приклеил» `__LINE__` слишком рано, до того, как подставил номер строки. Чтобы подставить значение `__LINE__` до приклеивания к profile_guard_, вынесем слияние лексем в отдельное макроопределение, `PROFILE_CONCAT`:
```cpp
#define PROFILE_CONCAT(X, Y) X ## Y
#define UNIQUE_VAR_NAME_PROFILE PROFILE_CONCAT(profile_guard_, __LINE__)

int main() {
    int UNIQUE_VAR_NAME_PROFILE;
} 
Код стал на одну строчку больше. Проверим результат:

#line 1 "main.cpp"

int main() {
    int profile_guard___LINE__;
} 
```
Результат не изменился. Почти смирившись, что ничего не выйдет, сделаем последнюю попытку. Добавим ещё один макрос:
```cpp
#define PROFILE_CONCAT_INTERNAL(X, Y) X ## Y
#define PROFILE_CONCAT(X, Y) PROFILE_CONCAT_INTERNAL(X, Y)
#define UNIQUE_VAR_NAME_PROFILE PROFILE_CONCAT(profile_guard_, __LINE__)

int main() {
    int UNIQUE_VAR_NAME_PROFILE;
} 
```
Посмотрим, что выдал препроцессор:
```cpp
#line 1 "main.cpp"

int main() {
    int profile_guard_6;
} 
```
Такого трюка для определения `UNIQUE_VAR_NAME_PROFILE` — макроса, генерирующего уникальное имя переменной — требуют довольно запутанные правила раскрытия в C++. Параметры макроса при склеивании заменяются на то, что в них было подставлено без изменения. Те параметры, которые не склеиваются, раскрываются, то есть полностью подставляются до того момента, пока в них не останется макросов. Чтобы достичь желаемого, нужно, чтобы `__LINE__` побывал параметром два раза: в первый раз он раскроется в номер строки, во второй раз номер строки приклеится к имени переменной.

Окончательный вид будет таким:
```
#define PROFILE_CONCAT_INTERNAL(X, Y) X ## Y
#define PROFILE_CONCAT(X, Y) PROFILE_CONCAT_INTERNAL(X, Y)
#define UNIQUE_VAR_NAME_PROFILE PROFILE_CONCAT(profileGuard, __LINE__)
#define LOG_DURATION(x) LogDuration UNIQUE_VAR_NAME_PROFILE(x)
```