## Вглубь процессора
Оптимизация — это процесс, позволяющий заменить операции программы на более эффективные и тем самым ускорить вычисления на несколько процентов или в сотни раз. Разберёмся, можно ли оптимизировать программу, не меняя операции, которые она совершает.

Представим, что в некоторой обсерватории есть телескоп. За одну ночь он совершает измерения на `n` участках неба. Результат измерения кодируется одним латинским символом от A до Z. В результате получается строка длины `n`.

Собраны результаты за длительный период работы телескопа. Среди них нужно найти участки неба, где больше всего сильных сигналов — с литерой K или далее. Реализуем функцию подсчёта сильных сигналов по каждому участку неба:
```cpp
#include <string>
#include <vector>

using namespace std;

// Функция анализирует данные телескопа, определяя, сколько сильных сигналов
// зафиксировано по каждому направлению.
vector<int> ComputeStatistics(const vector<string>& measures, int n) {
    int m = measures.size();
    vector<int> result(n);

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (measures[j][i] >= 'K') {
                ++result[i];
            }
        }
    }

    return result;
} 
```
Функция возвращает вектор, элементы которого — это количества сильных сигналов на нулевом участке неба, первом, втором. Протестируем эту функцию, измерив время. Считаем, что прошло 5000 дней и количество участков неба тоже равно 5000. Реальных данных телескопа у нас под рукой нет, поэтому заполним вектор случайными буквами:
```cpp
#include "log_duration.h"

#include <algorithm>
#include <iostream>
#include <numeric>
#include <random>
#include <string>
#include <vector>

using namespace std;

// функция анализирует данные телескопа, определяя, сколько сильных сигналов
// зафиксировано по каждому направлению
vector<int> ComputeStatistics(const vector<string>& measures, int n) {
    int m = measures.size();
    vector<int> result(n);

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            // прибавляем 1, если сигнал не менее 'K'
            result[i] += (measures[j][i] >= 'K' ? 1 : 0);
        }
    }

    return result;
}

string GetRandomString(int size) {
    static mt19937 engine;
    uniform_int_distribution<int> distribution('A', 'Z');

    string res(size, ' ');
    for (char& c : res) {
        c = char(distribution(engine));
    }

    return res;
}

int main() {
    vector<string> data;

    for (int i = 0; i < 5000; ++i) {
        data.push_back(GetRandomString(5000));
    }

    vector<int> statistics;
    {
        LOG_DURATION("ComputeStatistics"s);
        statistics = ComputeStatistics(data, 5000);
    }

    cout << "Всего сильных сигналов: "s << accumulate(statistics.begin(), statistics.end(), 0) << endl;
} 
```
Результат может быть таким:
```
ComputeStatistics: 134 ms
Всего сильных сигналов: 15379777 
```
Подумаем, много это или мало — 134 миллисекунды. За такое время процедура обрабатывает 5000 × 5000, то есть 25 миллионов байт. Получается, что за секунду было бы обработано около 187 мегабайт. Сравним с другой программой, например, видеоплеером. Современные видеоплееры должны декодировать и показать в секунду минимум 25 кадров в разрешении 4K, то есть 4096 × 3072 × 25 байт. Это примерно 315 мегабайт. Что-то подсказывает, что декодирование — куда более сложная операция, чем простой подсчёт количества определённых букв. Значит, в нашей программе что-то не так.

Внесём в программу минимальные изменения — поменяем порядок циклов в основной процедуре подсчёта:
```cpp
vector<int> ComputeStatistics2(const vector<string>& measures, int n) {
    int m = measures.size();
    vector<int> result(n);

    // теперь первым идёт цикл по j
    for (int j = 0; j < m; ++j) {
        for (int i = 0; i < n; ++i) {
            // прибавляем 1, если сигнал не менее 'K'
            result[i] += (measures[j][i] >= 'K' ? 1 : 0);
        }
    }

    return result;
}
```