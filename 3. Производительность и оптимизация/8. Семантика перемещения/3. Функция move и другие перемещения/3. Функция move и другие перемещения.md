## Функция move и другие перемещения
В этом уроке вы познакомитесь:

- с огромным слоном, который хочет вернуться к своим родственникам;
- с побочными эффектами, подстерегающими его на пути;
- с тем, как с этими побочными эффектами бороться;
- а также с группой смелых воинов, которых ожидает неминуемая гибель.
  
Перед дальнейшим чтением можете придумать слону имя, чтобы мысленно к нему обращаться во время урока.

#### Слон большой, серый, одна штука

Вы уже знаете, как компилятор справляется с лишними копированиями и ускоряет код даже без ведома программиста. Но компилятор не панацея от всех бесполезных действий.

Посмотрите на пример:
```cpp
using WhiteElephant = string;

// функция, которая умеет делать очень больших слонов 
WhiteElephant BuyElephant() {
    return WhiteElephant(100000000, 'a');
}

int main() {
    vector<WhiteElephant> crowd_of_elephants;
    WhiteElephant heavy_elephant = BuyElephant();
    crowd_of_elephants.push_back(heavy_elephant);
} 
```
Здесь создаётся `crowd_of_elephants` — толпа слонов. Но в начале она пустая. Пользователь покупает слона и сохраняет его в переменную `heavy_elephant`. После этого слон добавляется в толпу. Всё просто, и не такое видели. Но в момент копирования `heavy_elephant` в толпу слонов станет двое. Один теперь в толпе с другими слонами, а второй остался в переменной `heavy_elephant`. Вряд ли покупатель слонов хотел копировать животных.

В языке С++ есть способ, позволяющий не размножать слонов и другие объекты там, где не нужно. Этот метод использует move-семантику. Вместо семантики копирования — один слон в толпе, второй у хозяина — можно использовать семантику перемещения: забрать слона у хозяина и поместить в толпу.

Если изменим код так, чтобы купленный слон не сохранялся в переменную `heavy_elephant`, а напрямую передавался в метод `push_back`, временный слон, вернувшийся после `BuyElephant`, будет напрямую перемещён в толпу.

```cpp
crowd_of_elephants.push_back(BuyElephant()); 
```

Компилятор видит, что имеет дело с временным объектом, и понимает, что объект будет уничтожен сразу после переноса в вектор. Поэтому компилятор не копирует объект, а переносит его.

Рассмотрим эту идею чуть глубже. Внутри объекта `WhiteElephant` лежит указатель на место в памяти, где последовательно расположены элементы. Чтобы скопировать элемент, нужно пройти по всем элементам и создать их копии. Но если компилятор знает, что объект временный, он может просто забрать указатель на элементы и перенести его в объект внутри вектора.

Передавая в функции временные объекты, программисты делают код не только более лаконичным, но и более быстрым.

#### Нет ничего более постоянного, чем временное

Посмотрим на ситуацию с точки зрения владельца слона. Я, гордый обладатель редкого вида слонов, собираюсь отпустить своё приобретение в саванну к сородичам. Но сначала хочу совершить с ним прогулку. То есть мне нужно сохранить своего слона в переменную: 

```cpp
int main() {
    vector<WhiteElephant> crowd_of_elephants;
    // купил слона
    WhiteElephant heavy_elephant = BuyElephant();
    // гуляю и общаюсь с новым большим другом
    SmallWalk(heavy_elephant);
    // о нет! опять слонов стало два! один у меня, один в толпе
    crowd_of_elephants.push_back(heavy_elephant);
} 
```
Не может быть, чтобы не было способа в этом случае избежать раздвоения слонов при копировании.

Чтобы сказать компилятору, что объект в будущем не понадобится, и его можно не копировать, а перенести, используют специальную функцию `move`. Находится она в библиотеке `<utility>`:

```cpp
#include <utility>
...
int main() {
    vector<WhiteElephant> crowd_of_elephants;
    WhiteElephant heavy_elephant = BuyElephant();
    SmallWalk(heavy_elephant);
    // я отпускаю слона на волю
    crowd_of_elephants.push_back(move(heavy_elephant));
} 
```

Функция `move` позволит хозяину слона сообщить компилятору, что слон больше не нужен, и можно его просто перенести. При этом объект `heavy_elephant` остался у хозяина, но никто не гарантирует, что находится внутри объекта. Скорее всего, он просто пуст, а все данные перенесены в вектор. Теперь отвлекитесь от перемещений слона и решите жестокую историческую задачу о смелых воинах.