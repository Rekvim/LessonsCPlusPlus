## Временные объекты
Вы уже знаете много приёмов ускорения, включая правильный подбор контейнеров, использование профилировщика и даже учёт кэширования процессора. Рассмотрим пример:
```cpp
#include <iostream>
#include <string>

using namespace std;

class Number {
private:
    int a_;

public:
    Number() {
        cout << "Default Ctor"s << endl;
    }
    Number(int num)
        : a_(num) 
    {
        cout << "Ctor(int)"s << endl;
    }
    Number(const Number& other)
        : a_(other.a_) 
    {
        cout << "Copy Ctor"s << endl;
    }
    ~Number() {
        cout << "Dtor"s << endl;
    }
    Number& operator=(const Number& other) {
        a_ = other.a_;
        cout << "Op="s << endl;
        return *this;
    }
    Number operator+(const Number& second) {
        cout << "Op+" << endl;
        return a_ + second.a_;
    }
};

int main() {
    Number a(1), b(1), c;
    c = a + b;
    cout << "End of calculations"s << endl;
} 
```
Что будет выведено на экран:
```
Ctor(int)
Ctor(int)
Default Ctor
Op+
Ctor(int)
Op=
Dtor
End of calculations
Dtor
Dtor
Dtor 
```

Конструктор и деструктор вызываются четыре раза. При этом очевидных объектов только три: `a`, `b` и `c`. Четвёртый — временный — объект возникает здесь:

```cpp
return a_ + second.a_; 
```

У этого объекта нет имени. Невозможно узнать его адрес. Но он должен быть создан, чтобы функция могла его вернуть. После этого вызывается `operator=`, объект копируется в объект `c` и сразу уничтожается.

Программа работает, но создание временного объекта, а потом ещё и его копирование выглядят лишними. Совсем неудобно получилось бы, если объекты класса Number были тяжёлыми, их конструктор и копирование были сложнее, чем $O(1)$, в процессе динамически выделялась память, могли возникнуть исключения. 

В языке С++ есть механизмы, которые помогают избавиться от лишних действий. Вы научитесь их замечать и применять в ближайших уроках.