## Тайные техники передачи аргументов
Продолжим исследовать методы, позволяющие минимизировать количество копирований в коде. Вы уже знаете о возможности конструировать объекты без копирования, но с перемещением. В этом уроке увидите, как организована передача объектов в библиотечных функциях, и разберётесь, какой тип должен быть у аргумента, чтобы избежать лишних копирований.

#### Тайные техники стандартных библиотек

При добавлении слона в толпу слонов использовался метод вектора `push_back`. Причём  он корректно работал и для временного объекта, в том числе для объекта, получаемого из функции `move`, и для постоянного:

```cpp
// копируем постоянного слона в толпу
crowd_of_elephants.push_back(heavy_elephant);
// перемещаем временного слона в толпу
crowd_of_elephants.push_back(BuyElephant());
// перемещаем постоянного слона в толпу при помощи move
crowd_of_elephants.push_back(move(heavy_elephant));
```

Если открыть описание метода `push_back`, обнаружим, что это не один метод, а два:

```cpp
void push_back( const T& value );
void push_back( T&& value );
```

Первый метод принимает константную ссылку на постоянный объект. Значит, в этом методе объект будет копироваться. Второй метод принимает rvalue-ссылку — значит, объект будет перемещён, если это возможно.

Воспользуйтесь описаниями методов и функций и разделите методы и функции по двум группам: поддерживающие перемещение и не поддерживающие.
```cpp
std::map<Key,T,Compare,Allocator>::at 
```
Не поддерживают перемещение
```cpp
std::map<Key,T,Compare,Allocator>::operator[] 
```
Поддерживают перемещение
```cpp
std::set<Key,Compare,Allocator>::insert 
```
Поддерживают перемещение
```cpp
std::stack<T,Container>::push 
```
Поддерживают перемещение

Отдельно нужно сказать о контейнере `array`, который хранит свои данные в стеке. Этот контейнер поддерживает перемещение, но оно не такое эффективное, как у вектора. В векторе достаточно переместить указатель на данные. Никаких дополнительных действий с элементами не произойдёт. Вектор неперемещаемых элементов переместить можно. Но `array` работает иначе. Он не хранит указатель на данные, и для реализации перемещения нужно переместить каждый из элементов. Отсюда следуют два вывода:
- Для перемещения array его элементы должны быть перемещаемыми;
- Сложность перемещения `array` — линейная от количества элементов, что значительно хуже константной сложности перемещения вектора.

#### Тайные техники в жизни программистов

Немного изменим код примера со слоном:

```cpp
int main() {
    WhiteElephant heavy_elephant = BuyElephant();
    vector<WhiteElephant> crowd_of_elephants;
    AddToCrowd(crowd_of_elephants, heavy_elephant);
    AddToCrowd(crowd_of_elephants, BuyElephant());
} 
```

Чтобы добавить слона в толпу, нужно передать объект в функцию `AddToCrowd`. У программиста есть несколько вариантов, как это сделать:

- по значению
void AddToCrowd(vector<WhiteElephant>& crowd, WhiteElephant elephant); 

- по константной ссылке
void AddToCrowd(vector<WhiteElephant>& crowd, const WhiteElephant& elephant); 

- по rvalue-ссылке
void AddToCrowd(vector<WhiteElephant>& crowd, WhiteElephant&& elephant) 

Варианты с передачей по указателю тоже существуют, но рассматривать их не станем. В этом контексте они аналогичны передаче по ссылке.

Вариант с неконстантной ссылкой тоже отложим. Если ссылка будет неконстантной, то в толпу можно будет переместить только неконстантных животных, а это ограничение слишком сильное и ненужное.

Выбирая между оставшимися тремя способами — по значению, по константной ссылке и по rvalue-ссылке — программист будет руководствоваться двумя принципами:
- эффективностью кода или, в данном случае, минимальным количеством копирований;

- удобством для того, кто будет этот метод вызывать.
  
Посчитаем копирования в каждом из случаев:

```cpp
// для постоянных объектов - одно копирование
// для временных объектов - одно копирование
void AddToCrowd(vector<WhiteElephant>& crowd, const WhiteElephant& elephant) {
    crowd.push_back(elephant);
}

// постоянные объекты не поддерживаются
// для временных объектов - одно перемещение
// если объект неперемещаемый, то перемещение станет копированием
void AddToCrowd(vector<WhiteElephant>& crowd, WhiteElephant&& elephant) {
    crowd.push_back(move(elephant));
}

// постоянные объекты - одно копирование и одно перемещение
// временные объекты - два перемещения
// если объект неперемещаемый, то перемещение станет вторым копированием
void AddToCrowd(vector<WhiteElephant>& crowd, WhiteElephant elephant) {
    crowd.push_back(move(elephant));
}
```

Неожиданным лидером по количеству перемещений вместо копирования становится передача аргумента по значению.
- Временные объекты копироваться не будут. Они будут перемещены дважды: первый раз в сам объект аргумента, во второй раз — в контейнер.
- Постоянные объекты, которые можно переносить, скопируются один раз, в аргумент, а в контейнер они будут перемещены.

Но нужно учитывать два недостатка:

- Эта функция будет работать и для перемещаемых, и для неперемещаемых объектов. Только для неперемещаемых объектов она становится неэффективной — функция `move` не поможет переместить неперемещаемое. В этом случае перемещение превращается в тыкву и заменяется на второе копирование, что неприятно и малоэффективно.
- Если перемещение по сложности не уступает копированию — например, как у контейнера `array`, — два перемещения становятся менее эффективными, чем одно копирование, и лучше выбрать вариант с константной ссылкой.

#### Техники стандартных библиотек против техники обычных программистов

Но ведь создатели стандартных библиотек использовали две разные функции! Надо разобраться, почему в их случае это было верно, а в нашем подойдёт вариант с одной функцией, принимающей аргумент по значению.

Стандартные классы и алгоритмы — шаблоны, и они должны поддерживать все возможные шаблонные параметры. Это накладывает строгие требования на дизайн методов класса. Методы и функции должны быть максимально эффективны и для перемещаемых, и для неперемещаемых объектов.

Кроме того стандартные библиотеки обязаны поддерживать и старые стандарты языков. Раньше, до появления возможности перемещать, многие объекты были неперемещаемыми, а библиотеки принимали аргументы по константной ссылке. Если бы создатели библиотек резко перешли на передачу аргументов по значению, код старых стандартов заметно замедлился бы, так как в этом случае количество копирований бы выросло.

Но когда программист пишет своё приложение, он знает, с какими объектами собирается работать. Если объекты перемещаемые, стоит выбрать передачу аргумента по значению. Если неперемещаемые — по константной ссылке. Такой механизм позволяет сохранить эффективность кода и избежать дублирования.

Если будете писать шаблонный класс, который сможет работать с максимально возможным количеством типов и классов, можно использовать приём с двумя одноименными методами или познакомиться поближе с универсальными ссылками. Примером использования универсальной ссылки — метод `std::vector<T,Allocator>::emplace`. У использования универсальных ссылок в шаблонах есть особенность: тип аргумента становится отдельным шаблонным параметром. В сигнатуре тип `Args` не тот же самый, что тип `T`. Это позволяет компилятору подобрать максимально подходящий тип аргумента для объекта, который передаётся.