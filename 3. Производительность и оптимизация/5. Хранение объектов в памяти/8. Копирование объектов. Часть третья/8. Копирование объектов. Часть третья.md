## Копирование объектов. Часть третья
Вы создали свой первый умный указатель `ScopedPtr`, который позволил сохранить объект в динамической памяти и автоматически контролировать время его жизни. У `ScopedPtr` есть и другие полезные свойства:

Исключает неинициализированное состояние. Он либо пустой, либо хранит адрес существующего объекта;

Запрещает копирование указателя. Тем самым исключает ситуацию, когда два указателя одновременно владеют одним объектом;
Вместо неопределённого поведения при разыменовании нулевого указателя `ScopedPtr` выбрасывает исключение `logic_error`, которое можно поймать и обработать приложением.

Эти свойства указателя позволяют сделать управление объектами в динамической памяти проще. Вместо такого:
```cpp
int main() {
    vector<Object*> objects;
    Object* ptr = nullptr;
    try {
        for (int i = 0; i < 5; ++i) {
            ptr = new Object();
            objects.push_back(ptr);
            // Обнуляем ptr (этот указатель уже скопирован в objects)
            ptr = nullptr;
        }
    } catch (...) {
        delete ptr;
    }
    // Удаляем объекты из массива указателей
    for (Object* obj_ptr : objects) {
        delete obj_ptr;
    }
} 
```
Можно написать лаконичнее:
```cpp
int main() {
    vector<Object*> objects;
    try {
        for (int i = 0; i < 5; ++i) {
            // Пока указатель не добавлен в контейнер objects, им владеет умный указатель
            ScopedPtr<Object> ptr(new Object());
            objects.push_back(ptr.GetRawPtr());

            // Вызываем Release, чтобы указатель не удалил объект, уже 
            // вставленный в вектор.
            ptr.Release();
        }
    } catch (...) {
    }
    for (Object* obj_ptr : objects) {
        delete obj_ptr;
    }
} 
```
Тем не менее удалять объекты, на которые ссылаются указатели внутри вектора, всё ещё приходится вручную. Чтобы автоматизировать процесс, разработаем класс-обёртку `PtrVector` — вектор указателей. Он автоматически удаляет объекты в своём деструкторе. Код станет ещё проще:
```cpp
int main() {
    PtrVector<Object> objects;
    for (int i = 0; i < 3; ++i) {
        ScopedPtr<Object> ptr(new Object());
        objects.GetItems().push_back(ptr.GetRawPtr());
        ptr.Release();
    }

    cout << "PtrVector copy has been destroyed"s << endl;

    // Деструктор PtrVector автоматически удалит объекты, на которые
    // ссылаются хранящиеся внутри него указатели
} 
```
Также `PtrVector` будет допускать копирование:
```cpp
PtrVector<Object> objects;

// ...

PtrVector<Object> objects_copy(objects); 
```
Во время которого он создаст копии всех объектов, указатели на которые содержатся в `objects`.