## Связь потоков: в поисках оптимального ввода и вывода

В прошлом уроке речь шла о том, что замена `endl` на `\n` улучшает эффективность. Разберёмся, всегда ли это происходит. Рассмотрим программу для возведения в квадрат чисел, прочитанных из стандартного ввода: 

```cpp
#include <iostream>
#include <string>

#include "log_duration.h"

using namespace std;

// main с аргументами означает, что программа принимает аргументы командной строки,
// при запуске из консоли их количество будет сохранено в переменную argc,
// а значения — в argv.
// Тип const char** будет обсуждаться позже в курсе, работать с ним можно
// отчасти как с вектором: argv[0] — нулевой аргумент, argv[1] — первый. 
// argv[i] можно конвертировать в string
int main(int argc, const char** argv) {
    // Нулевой аргумент — это всегда имя программы,
    // поэтому нам нужен первый
    int arg = stoi(argv[1]);

    if (arg == 1) {
        LOG_DURATION("endl"s);
        int i;
        while (cin >> i) {
            cout << i * i << endl;
        }
    }

    if (arg == 2) {
        // Чтобы "\n" воспринималось не как перевод строки, а как 
        // слэш и буква 'n', добавим перед ним ещё один слеш:
        // два слеша в строковом (и символьном) литерале воспринимаются
        // как один (\) 
        LOG_DURATION("\\n"s);
        int i;
        while (cin >> i) {
            cout << i * i << "\n"s;
        }
    }
} 
```

Эта программа принимает один числовой аргумент: единицу или двойку. Она читает числа из стандартного ввода и выдаёт их квадраты в стандартный вывод, замеряя время. Причём метод завершения строки — `\n` или `endl` — можно менять, используя аргумент командной строки. Скомпилируем программу и назовём исполняемый файл `sqnums`. Запустим её так:

```
$ sqnums 1
```
Она будет радостно выводить квадраты всех введённых чисел до тех пор, пока вы не введёте символ конца файла. Затем выведет общее время работы и при этом будет использовать `endl`. Запустим программу иначе:
```
$ sqnums 2
```
Тут вместо `endl` будет простой `\n`.

Для запуска программы возьмём файл `numbers.txt`, который содержит 50000 чисел от 0 до 99.

Запускать будем, перенаправляя стандартный ввод и вывод:
```
$ sqnums 1 >numbers2.txt <numbers.txt 
```
Перенаправление символами `>` и `<` позволяет проассоциировать потоки `cin` и `cout` с файлами. Так программа будет через поток `cin` получать данные из файла `numbers.txt`. Благодаря `>` данные из cout пойдут в файл `numbers2.txt`, а не в окно консоли. Если хотим использовать `\n`, меняем параметр `1` на `2`:
```
$ sqnums 2 >numbers2.txt <numbers.txt 
Смотрим на результаты:

$ sqnums 1 >numbers2.txt <numbers.txt
endl: 410 ms
$ sqnums 2 >numbers2.txt <numbers.txt
\n: 408 ms 
```
В команде `sqnums 2 >numbers2.txt <numbers.txt` пробел между 2 и `>` важен: без него получится конструкция `2>`, которая выполняет перенаправление потока `cerr`.

Не столь впечатляюще. Раньше мы наблюдали чуть не десятикратное различие, а теперь оно едва заметно. Чтобы понять причину этого, обратимся к другой программе:

```cpp
#include <iostream>

using namespace std;

int main() {
    cout << "Enter x and y: "s;
    cin >> x >> y;
    cout << x + y << endl;
} 
```

Совсем не очевидно, но чтение из `cin` заставляет буфер `cout` и `cerr` опустошаться, как если бы мы добавили `cout.flush()` перед ним. В этом причина медленной работы программы с `\n`. К счастью, есть способ исправить ситуацию, отвязав `cin` от `cout` так: `cin.tie(nullptr);`.

Дополним программу ещё одной веткой и протестируем скорость:
```cpp
#include <iostream>
#include <string>

#include "log_duration.h"

using namespace std;

int main(int argc, const char** argv) {
    // не забываем, что один аргумент — это название программы,
    // поэтому argc должно быть как минимум 2
    if (argc < 2) {
        cerr << "Пожалуйста, задайте как минимум 1 аргумент"s << endl;
        return 1;
    }

    int arg = std::stoi(argv[1]);

    if (arg == 1) {
        LOG_DURATION("endl"s);
        int i;
        while (cin >> i) {
            cout << i * i << endl;
        }
    }

    if (arg == 2) {
        LOG_DURATION("\\n"s);
        int i;
        while (cin >> i) {
            cout << i * i << "\n"s;
        }
    }

    if (arg == 3) {
        LOG_DURATION("\\n with tie"s);
        cin.tie(nullptr);
        int i;
        while (cin >> i) {
            cout << i * i << "\n"s;
        }
    }
} 
```
Запускаем:
```
$ test-stream.exe 3 <numbers.txt >numbers2.txt
\n with tie: 89 ms 
```
Совсем другое дело! Однако будьте осторожны, потому что отвязывание `cin` от `cout` повлияет на всё последующее выполнение. Если разрабатываете основную функцию программы, это не так важно. Но если подобное происходит в функции библиотеки, которая будет применяться в разных программах, такой побочный эффект крайне нежелателен. Избежать его просто — в конце работы привяжите обратно:
```cpp
...
if (arg == 3) {
    LOG_DURATION("\\n with tie"s);
    auto tied_before = cin.tie(nullptr);

    int i;
    while (cin >> i) {
        cout << i * i << "\n"s;
    }

    cin.tie(tied_before);
}
... 
```
Чтобы избежать возможных проблем, используйте для этих целей класс с конструктором и деструктором для выполнения парных действий. В прошлой теме вы так измеряли время.

В этом уроке мы убедились: замена `endl` на `\n` серьёзно ускоряет использование потоков, если это критичное место вашей программы. 

Ещё сильнее ускорить ввод и вывод в `cin` и `cout` может магическая команда `ios_base::sync_with_stdio(false)`, с которой хорошо знакомы участники соревнований по программированию. Использовать её следует осторожно. Эта команда способна помешать работе при подключении сторонних библиотек, выводящих информацию в стандартный вывод.

Команда `sync_with_stdio` отключает синхронизацию между стандартными потоками C и C++, а также между разными потоками выполнения, сохраняя ресурсы.

Не путайте потоки ввода и вывода `stream` и потоки выполнения `thread`:
- Потоки ввода и вывода `stream` передают данные между произвольным источником source и потребителем `sink`.
- Потоки выполнения `thread` позволяют одновременно выполнять несколько операций в программе. Они также используются для ускорения за счёт выполнения на разных ядрах процессора. Термины «многопоточный», «потокобезопасный» всегда относятся к потокам выполнения.