## Эффективный вектор

О векторе сказано уже много. Резюмируем ваши знания. Его главное свойство, объясняющее все сильные и слабые стороны, — это последовательное расположение всех элементов в памяти. Создадим вектор из трёх элементов и добавим один элемент в конец:

```cpp
vector<int> v = {1, 2, 3};
v.push_back(4); 
```

При создании вектора на стеке появится объект под именем `v`, который будет содержать информацию о векторе:
- `int* data` — указатель на выделенный на куче отрезок памяти для трёх элементов типа `int`;
- `size` — количество элементов, которые в данный момент находятся в векторе;
- `capacity` — количество элементов, для которых потенциально есть место в выделенной памяти, тоже три.

Данные всех трёх параметров можно получить через одноимённые методы вектора.

Два неизвестных числа у каждого пользователя могут быть разными. Это не цифры из лотереи, а некий мусор, лежавший в памяти, которую сейчас использует вектор для хранения элементов. `capacity` вектора выросла вдвое: была 4, стала 8. Но `size` вектора увеличился на единицу: был 4, стал 5. Когда появятся новые элементы, вектор просто перезапишет их на место мусора. С дальнейшим добавлением элементов `size` станет равен `capacity`, и вектору снова придётся её удвоить. Некоторые компиляторы могут увеличить `capacity` вектора вдвое, некоторые в 1.5 раза, это зависит от реализации стандартной библиотеки.

Для освобождения от мусора есть специальный метод. Он нечасто используется и называется `shrink_to_fit`. Метод переаллоцирует память так, чтобы `capacity` стала равна `size`. Интересно, что этот запрос необязательно будет выполнен. Реализация контейнера такова, что запрос можно оставить без внимания. Да, и такое бывает. 

Вернёмся к добавлению элементов в вектор.

В каком порядке будут выполнены эти шаги при работе метода `push_back`?
1. Выделение нового блока памяти в два раза больше предыдущего
2. Добавление нового элемента
3. Копирование старых элементов из предыдущего блока памяти в новый
4. Освобождение предыдущего блока памяти, увеличение `capacity` и `size`
5. Проверка, достаточно ли `capacity`, чтобы добавить новый элемент

Ответ:
    
    5, 1, 3, 2, 4

Как только добавим в вектор ещё два элемента, место кончится опять. Снова придётся перевыделять память, увеличивая `capacity` в два раза, и копировать туда элементы старого блока. Согласитесь, это неэффективно, если мы заранее знаем, сколько элементов должно быть в векторе. Именно для таких случаев есть метод `reserve`, который вы уже встречали в курсе.

Не забудьте ответ на этот вопрос. Указатель вектора имеет свойство инвалидироваться или, иначе говоря, становиться неверным, недействительным.

Реализация `SimpleVector` похожа на реализацию стандартного вектора. Внутри вектора есть указатель на участок памяти, где располагаются элементы, и по ним можно итерировать. В конце этой темы вернёмся к `SimpleVector` и улучшим его реализацию, добавив метод `Reserve`.