## Больше о путях
У пути есть два формата строкового представления: native и generic. В native-формате путь выглядит так, как он должен быть представлен в операционной системе. Метод `path::string` возвращает путь в этом представлении. Оно рекомендуется в большинстве случаев.

Формат generic одинаковый на всех операционных системах. Он определяет папки прямым слешем. Чтобы получить generic-представление, вызовите метод `generic_string`. Это метод класса `path`. Такой формат полезен при конструировании пути из `string`. Например, путь, аналогичный пути из прошлого урока, можно задать так:
```
path p = path("a/folder/and/../a/file.txt"s, path::generic_format); 
```
Тут вы видите второй параметр при конструировании пути из `string`. По умолчанию он равен `path::generic_format::auto_format`. Это значение подразумевает, что компилятор постарается универсальным образом интерпретировать путь.

Под Windows путь в native-формате иногда содержит оба вида слешей, но предпочтительнее обратный. Можно явно заменить в переменной типа `path` все слеши на предпочтительные методом `make_preferred`:
```cpp
path p = path("a/folder/and/../a/file.txt"s, path::generic_format);

cout << "p.string():                      "s << p.string() << endl;
p.make_preferred();
cout << "p.string() после make_preferred: "s << p.string() << endl;
cout << "p.generic_string():              "s << p.generic_string() << endl; 
```
Возможный вывод:
```
p.string():                      a/folder/and/../a/file.txt
p.string() после make_preferred: a\folder\and\..\a\file.txt
p.generic_string():              a/folder/and/../a/file.txt 
```
Рассмотрим другие операции с путями, которые не вошли в прошлый урок.
#### Нормализация
Пути, содержащие элементы папки`.`, папки `..` или несколько слешей подряд, легко упростить. Это делается методом `lexically_normal`:
```cpp
path p = "a"_p / "folder"_p / "and"_p / ".."_p / "a"_p / "file.txt"_p;

cout << "Исходный вид: "s << p.string() << endl;
p = p.lexically_normal();
cout << "После lexically_normal(): "s << p.string() << endl; 
```
Возможный вывод:
```
Исходный вид: a/folder/and/../a/file.txt
После lexically_normal(): a/folder/a/file.txt 
```
Полученный путь называется нормальным.

#### Получение родительской папки

Чтобы получить родительскую папку, используйте метод пути `parent_path`. Но он действует довольно наивно — просто убирает последний элемент пути, если это был не единственный элемент.

Проблемы возникли для относительных путей и для тех, которые содержат папки `.` и `..`. Значит, для правильной работы метода `parent_path` путь нужно сделать нормальным и абсолютным перед его вызовом.
#### Другое
В библиотеке `filesystem` есть и другие функции, которые устроены по аналогии с описанными. Полный их список — на сайте cppreference.

Вот некоторые из них:
- `exists` — проверка существования файла или папки. Может принимать статус или путь;
- `copy`, `copy_file` — копирование файлов и папок;
- `current_path` — получение и изменение текущего пути;
- `equivalent` — проверка, что два пути указывают на один объект;
- `file_size` — получение размера файла;
- `remove`, `remove_all` — удаление файлов и папок;
- `resize_file` — изменение размера файлов. Увеличивать размер можно потоком ofstream, а уменьшать — этой функцией.

Нет никакой гарантии, что за время, прошедшее с проверки условия `if` до попытки открытия, другая программа не удалит файл. К тому же, за это время кто-нибудь может создать папку на его месте. Более того, в программе есть серьёзная ошибка: если вы не указали второй параметр у функции `status`, он может выбросить исключение, которое точно не будет обработано, поскольку этот код расположен прямо в `main`.

Может показаться маловероятным, что файл удаляется сразу после проверки существования. Но следует учитывать две вещи:
1. Для программиста не существует понятия «маловероятно». Любая ошибка может не проявляться лишь до поры до времени.

2. Некоторые программы устанавливают обработчики событий на изменение файловой системы. Например, на создание файлов. Так делают антивирусы. Когда проверяете на существование только что созданный файл, какой-нибудь антивирус может одновременно пытаться его удалить, заподозрив в нём вредоносный код.

В условиях совместного доступа всех программ к файловой системе следует всегда контролировать ошибки, даже если предыдущие проверки показали, что ошибки быть не должно. Операционная система в некоторых случаях будет вам помогать, оберегая открытые файлы от модификации другими программами. В общем случае в различных ОС есть возможности для совместной работы с файловой системой. Они не входят в стандартную библиотеку и в этот курс тоже.