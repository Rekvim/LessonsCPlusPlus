## Бинарные файлы: читаем и пишем байты
В файлах хранятся байты. Поэтому не всегда удобно использовать операции `>>` и `<<`, которые читают и пишут данные определённого формата. Иногда задача в том, чтобы прочитать или записать определённое количество байтов.

В потоках чтения есть метод `get`. Если вызвать его без параметров, он прочтёт один байт и возвратит целое число. Обычно оно находится в пределах от 0 до 255, но если достигнут конец файла или произошла ошибка, это число равно специальному отрицательному значению, которое можно получить вызовом `istream::char_traits::eof()`. Название этого метода — аббревиатура от end of file.

Чтобы прочитать N байтов, можно использовать такой цикл:
```cpp
size_t ReadExact(istream& input, char* dst, size_t count) {
    for (size_t i = 0; i < count; ++i) {
        int c = input.get();
        if (c == istream::traits_type::eof() || !input) {
            return i;
        }
        dst[i] = static_cast<char>(c);
    }

    return count;
} 
```
Указатель здесь позволяет не ограничиваться определённой структурой данных. Можно вызывать этот метод для чтения в `string`, `vector<char>`, `array<char, N>` и другие типы. Однако у сырого указателя есть свои минусы: даже при включении отладочных определений выход за пределы памяти не будет обнаружен. Подобная концепция идёт ещё из языка C, она будет подробно разобрана в спринте 12.

Делать свою функцию `ReadExact` необязательно — для чтения определённого количества байтов у потока `istream` есть специальный метод `read`. Он устроен аналогично, за исключением типа возврата — результатом будет не количество прочитанных символов, как в функции `ReadExact`, а сам поток, как во многих других методах потоков. Чтобы узнать количество прочитанных символов, после `read` вызовите метод gcount. Сравним по скорости собственную реализацию, использующую `get`, со встроенным методом `read`:
```cpp
#include "log_duration.h"

#include <fstream>
#include <iostream>
#include <random>
#include <string>

using namespace std;

size_t ReadExact(istream& input, char* dst, size_t count) {
    for (size_t i = 0; i < count; ++i) {
        int c = input.get();
        if (c == istream::traits_type::eof() || !input) {
            return i;
        }
        dst[i] = static_cast<char>(c);
    }

    return count;
}

string GenerateRandomString(size_t size) {
    string random_str(size, 0);
    static mt19937 engine;

    for (char& c : random_str) {
        c = static_cast<char>(uniform_int_distribution<int>('A', 'Z')(engine));
    }

    return random_str;
}

int main() {
    // размер файла 10 мегабайт
    static const int FILE_SIZE = 10 * 1024 * 1024;
    static const int READ_COUNT = 10;

    // создаём файл нужного размера
    {
        ofstream test_out("test.txt");
        test_out << GenerateRandomString(FILE_SIZE);
    }

    vector<char> buffer(FILE_SIZE);

    // прочитаем его заданное количество раз двумя способами
    {
        LOG_DURATION("multiple get");
        ifstream test_in("test.txt");
        for (int i = 0; i < READ_COUNT; ++i) {
            test_in.seekg(0);
            ReadExact(test_in, buffer.data(), FILE_SIZE);
        }
    }

    {
        LOG_DURATION("stream read");
        ifstream test_in("test.txt");
        for (int i = 0; i < READ_COUNT; ++i) {
            test_in.seekg(0);
            test_in.read(buffer.data(), FILE_SIZE);
        }
    }
} 
```
Каждым методом прочитано в общей сложности 100 мегабайт. Посмотрим на результат:
```
multiple get: 8933 ms
stream read: 351 ms 
```
В этом примере метод `read` читает со скоростью примерно 280 Мбайт/с, а многократные `get` показывают всего 11 Мбайт/с.

Справедливости ради стоит отметить, что измерение скорости операций с файлом не всегда надёжно. Из-за особенностей диска время может сильно варьироваться. Чтение даже одного байта в некоторых ситуациях может занимать десятки секунд. Напротив, если файл был недавно прочитан, его содержимое, скорее всего, находится в кэше диска, и чтение будет очень быстрым. Но в нашем случае результат воспроизводимый.

Можно сделать такой вывод: `get` хорош, если требуется ровно один символ, в зависимости от которого нужно решить, что делать дальше. Но для чтения большого файла он не годится. Можно также использовать знакомый `getline`, чтобы прочитать всё до определённого символа. Запомните: каждая потоковая операция выполняет несколько вспомогательных вызовов, обрабатывает флаги ошибок и требует немалых накладных расходов. Следует свести количество потоковых операций к минимуму.

Также `get` неприемлем, если нужно прочитать файл целиком и что-нибудь сделать с каждым символом. Вместо этого используйте буфер — не слишком маленький, но и не занимающий много памяти. Хороший размер буфера — один килобайт. В этом случае накладные расходы сокращаются более чем в тысячу раз и становятся незначительными по сравнению с самим чтением данных.

Аналоги `get` и `read` для записи — методы `put` и `write`. На них распространяются те же правила, что и на методы чтения: не следует использовать `put` для записи многих символов подряд. Напишем собственную версию утилиты `cp`, которая копирует файлы. При этом применим буфер:

```cpp
#include <array>
#include <fstream>
#include <iostream>
#include <string>

using namespace std;

int main(int argc, const char** argv) {
    // при неверных аргументах выводим ошибку и выходим с кодом
    if (argc != 3) {
        cerr << "Usage: "s << argv[0] << " <in file> <out file>"s << endl;
        return 1;
    }

    ifstream in_file(argv[1]);
    if (!in_file) {
        cerr << "Can't open input file"s << endl;
        return 2;
    }

    ofstream out_file(argv[2]);
    if (!out_file) {
        cerr << "Can't open output file"s << endl;
        return 2;
    }

    // размер буфера один килобайт
    static const int BUFF_SIZE = 1024;
    std::array<char, BUFF_SIZE> buffer;

    do {
        in_file.read(buffer.data(), BUFF_SIZE);
        out_file.write(buffer.data(), in_file.gcount());
    } while (in_file);
} 
```

В таком варианте всегда производится попытка открыть выходной файл. Если входной файл не был открыт, будет создан ненужный пустой файл. Хуже того, такой код может обнулить существующий выходной файл и ничего в него не записать. Это приведёт к очень неприятным последствиям, если, например, перепутать входной и выходной файл при запуске утилиты.

Вам могло показаться странным, что сначала прочитанное пишется в файл, и только потом проверяется корректность операции чтения. Но таковы особенности работы с `read` — операция считается успешной, только если прочитано ровно столько символов, сколько мы запросили. Последняя часть файла, скорее всего, окажется меньше буфера, и поток будет считать, что `read` не удался. Надёжный способ узнать, сколько символов прочитано, — метод `gcount`. Даже если случилась какая-либо ошибка во время чтения, его значение будет 0, и `write` ничего не запишет.

Протестируем программу, назвав её my_cp. Копируем текстовый файл canterburry.txt и сравним его с исходным утилитой diff:
```
my_cp canterburry.txt canterburry-copy.txt
diff canterburry.txt canterburry-copy.txt 
```
Вывод diff пуст, значит, файл скопировался правильно. Пусть теперь программа копирует саму себя:
```
my_cp "my_cp.exe" "my_cp_copy.exe"
my_cp_copy "canterburry.txt" "canterburry-copy.txt" 
```

Файл скопировался неправильно. Выходит, программа работает некорректно и не может скопировать бинарный файл.

Это опасная ошибка, которая исправляется добавлением флага `binary` при открытии обоих файлов — входного и выходного. Без этого флага поток может вносить некоторые изменения в данные при чтении и записи. Например, автоматически исправлять концы строк или пропускать некоторые непечатные символы. Используйте `binary` везде, кроме случаев, когда вы уверены, что придётся работать именно с текстовым файлом.

Нужно модифицировать две строки с объявлением потоковых переменных, добавив в вызов конструктора второй параметр:
```cpp
    ifstream in_file(argv[1], ios::in | ios::binary);
    if (!in_file) {
        cerr << "Can't open input file"s << endl;
        return 2;
    }

    ofstream out_file(argv[2], ios::out | ios::binary);
    if (!out_file) {
        cerr << "Can't open output file"s << endl;
        return 2;
    } 
```