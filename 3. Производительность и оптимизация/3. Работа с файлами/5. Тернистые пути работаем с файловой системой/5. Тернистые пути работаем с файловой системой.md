## Тернистые пути: работаем с файловой системой

Пройдя почти все уроки этой темы, вы научились выполнять только базовые операции с файлами: чтение, запись и создание нового файла. Вы узнали о способах проверить существование файла и определить его размер, но такие способы правильно работают только при наличии прав на чтение, а это избыточно. Для других операций с файлами в C++ существует стандартная библиотека `filesystem`.

При компоновке программ с использованием `filesystem` могут потребоваться дополнительные опции компиляции. Для `gcc` до версии 9.1 нужен ключ `-lstdc++fs`.

### Пути

В разных ОС файловые системы имеют свои особенности. В одних разделитель пути обозначается прямым слешем, в других — обратным. В одних все абсолютные пути начинаются с диска либо с указания на сетевую папку, в других достаточно слеша в начале. Предназначение `filesystem` — дать наиболее универсальный интерфейс файловой системы, который бы работал корректно на разных платформах.

Базовое понятие `filesystem` — путь. Он представляется классом `std::filesystem::path`. Это может быть как абсолютный, так и относительный путь. Он способен задавать существующий или несуществующий файл. Путь состоит из секций — промежуточных папок. При комбинировании путей можно не задумываться о том, какой слеш нужен в данной операционной системе, и использовать операцию `/`:
```cpp
#include <filesystem>
#include <iostream>

using namespace std;

int main() {
    using filesystem::path;

    path p = path("a") / path("folder") / path("and") / path("..") / path("a") / path("file.txt");

    // выводим естественное представление пути в std::string
    cout << p.string() << endl;
} 
```
Под Windows вывод такой:
```
a\folder\and\..\a\file.txt 
```
Под Linux и MacOs слеши прямые:
```
a/folder/and/../a/file.txt 
```
Другое различие путей в разных операционных системах — кодировка. В Windows используются 16-битные кодировки, в распространённых дистрибутивах Linux — utf-8. Поэтому в Windows путь нельзя сохранить в `string` без потери поддержки путей, содержащих буквы разных языков. Для представления пути под Windows подходит тип `wstring`, полностью аналогичный `string` за тем исключением, что вместо `char` в нём `wchar_t`. Класс `filesystem::path` способен корректно обработать любые пути. Он содержит псевдоним `path::string_type` строкового типа, подходящего для путей в данной операционной системе. Если ваша программа принимает пути к файлам через аргументы командной строки, то под Windows не получится обойтись функцией `main` с параметрами `int, const char**`. Вместо этого выберите другую точку входа: `int wmain(int argc, const wchar_t** argv)`. Чтобы устранить неоднозначность, все пути можно сразу конвертировать к `filesystem::path`. У него есть конструкторы, принимающие как `string`, так и `wstring`.

### Литерал для путей

Строковые литералы с суффиксом `s` позволяют создавать объект `string` эффективно и коротко. Аналогичного суффикса для создания путей в стандартной библиотеке нет. Но невелика беда, ведь ничто не мешает создать его самим!

Суффикс, который определяет программа, должен начинаться со знака подчёркивания. Так можно избежать конфликтов с литералами стандартной библиотеки, которые уже существуют или будут добавлены в будущем. Определим для пути суффикс `_p`:

```cpp
path operator""_p(const char* data, std::size_t sz) {
    return path(data, data + sz);
} 
```
Ещё одно преимущество такой записи — оператор принимает размер литерала, вычисляемый на этапе компиляции. Это даёт небольшой выигрыш в производительности: не нужно проходить второй раз, чтобы определить её длину. Именно поэтому мы стремимся везде использовать `s` и `sv`. Сам `path` создан конструктором, принимающим два указателя — на начальный символ и на конечный.

Такой суффикс значительно сокращает запись пути:
```
"a"_p / "folder"_p / "and"_p / ".."_p / "a"_p / "file.txt"_p 
```

В наших примерах не будем создавать namespace, в маленьких программах это допустимо.
#### Операции с путями
Пути можно использовать вместо string в конструкторах файловых потоков fstream, ofstream, ifstream, чтобы открыть файл. Опишем другие возможные применения путей.
##### Получение абсолютного пути из относительного
Если путь относительный, его можно сделать абсолютным, приписав к началу текущую папку. Вам понадобится функция `absolute`. Если путь уже абсолютный, функция ничего не изменит:

```cpp
path p = "a"_p / "folder"_p / "and"_p / ".."_p / "a"_p / "file.txt"_p;

cout << "Исходный вид: "s << p.string() << endl;
p = filesystem::absolute(p);
cout << "После absolute(): "s << p.string() << endl;
p = filesystem::absolute(p);
cout << "После второго absolute(): "s << p.string() << endl; 
```
Возможный вывод:
```
Исходный вид: a/folder/and/../a/file.txt
После absolute(): /tmp/1610305631.7592149/a/folder/and/../a/file.txt
После второго absolute(): /tmp/1610305631.7592149/a/folder/and/../a/file.txt 
```
Функция выбрасывает исключение `filesystem_error` в случае ошибки. Если указать второй параметр типа `std::error_code&`, вместо исключения в него будет записываться ошибка.
Создание папки
В `filesystem` есть две функции для создания папок:
- `create_directory`
- `create_directories`
  
Обе принимают путь и необязательный параметр типа `std::error_code&`, наличие которого запрещает исключения. Отличие первой функции от второй в том, что она может создать только одну папку, а вторая — сразу серию вложенных. Если папка уже существует, функция не сообщает об ошибке, в отличие от реализации аналогичной функции в некоторых других языках.

Приведём пример:
```cpp
#include <filesystem>
#include <fstream>
#include <iostream>

using namespace std;
using filesystem::path;

path operator""_p(const char* data, std::size_t sz) {
    return path(data, data + sz);
}

void CreateFile(path p) {
    ofstream file(p);
    if (file) {
        cout << "Файл создан: "s << p.string() << endl;
    } else {
        cout << "Ошибка создания файла: "s << p.string() << endl;
    }
}

int main() {
    error_code err;

    path p = "tmp"_p / "a"_p / "folder"_p;

    CreateFile(p / "file.txt"_p);

    filesystem::create_directory(p, err);
    if (err) {
        cout << "Ошибка создания папки через create_directory: "s << err.message() << endl;
    } else {
        cout << "Успешно создана папка через create_directory: "s << p.string() << endl;
    }

    filesystem::create_directories(p, err);
    if (err) {
        cout << "Ошибка создания папки через create_directories: "s << err.message() << endl;
    } else {
        cout << "Успешно создана папка через create_directories: "s << p.string() << endl;
    }

    CreateFile(p / "file.txt"_p);

    path p2 = p.parent_path() / "folder2"_p;
    filesystem::create_directory(p2, err);
    if (err) {
        cout << "Ошибка создания папки через create_directory: "s << err.message() << endl;
    } else {
        cout << "Успешно создана папка через create_directory: "s << p2.string() << endl;
    }

    CreateFile(p2 / "file.txt"_p);
} 
```
Возможный вывод:
```
Ошибка создания файла: tmp/a/folder/file.txt
Ошибка создания папки через create_directory: No such file or directory
Успешно создана папка через create_directories: tmp/a/folder
Файл создан: tmp/a/folder/file.txt
Успешно создана папка через create_directory: tmp/a/folder2
Файл создан: tmp/a/folder2/file.txt 
```
##### Различение файла и папки

Чтобы получить информацию об объекте файловой системы, используйте `filesystem::status`. Эта функция принимает путь и возвращает объект типа `filesystem::file_status`. Как и другие функции библиотеки `filesystem`, она имеет необязательный второй параметр типа `std::error_code`, заменяющий исключения.

Имея `file_status`, можно проверить, является ли объект файлом или папкой:
```cpp
void PrintFileOrFolder(filesystem::path p) {
    error_code err;
    auto status = filesystem::status(p, err);
    
    if (err) {
        return;
    }

    if (status.type() == filesystem::file_type::regular) {
        cout << "Путь "s << p.string() << " указывает на файл"s << endl;
    } else if (status.type() == filesystem::file_type::directory) {
        cout << "Путь "s << p.string() << " указывает на папку"s << endl;
    } else {
        cout << "Путь "s << p.string() << " указывает на другой объект"s << endl;
    }
} 
```
Функция `status` не считает ошибкой ситуацию, когда путь указывает на несуществующий объект.
### Получение всех файлов в папке
Можно пройтись циклом `for` по всем объектам в папке, используя класс `filesystem::directory_iterator`:
```cpp
#include <filesystem>
#include <fstream>
#include <iostream>

using namespace std;
using filesystem::path;

path operator""_p(const char* data, std::size_t sz) {
    return path(data, data + sz);
}

...

int main() {
    path p = "a"_p / "folder"_p;
    filesystem::create_directories(p);
    filesystem::create_directory(p / "subfolder"_p);
    std::ofstream(p / "file.txt"_p) << "File content"s;

    for (const auto& dir_entry: filesystem::directory_iterator(p)) {
        PrintFileOrFolder(dir_entry.path());
    }
} 
```
Возможный вывод:
```
Путь a/folder/file.txt указывает на файл
Путь a/folder/subfolder указывает на папку 
```
Порядок обхода директории не регламентирован. Гарантируется только, что каждый файл будет пройден один раз.

Элемент папки `dir_entry` имеет тип `filesystem::directory_entry`, который помимо самого пути уже содержит в себе закешированный статус и другую информацию. Чтобы не выполнять лишних обращений к файловой системе, можно использовать этот статус, изменив функцию `PrintFileOrFolder`:
```cpp
void PrintFileOrFolder(filesystem::file_status status) {
    if (status.type() == filesystem::file_type::regular) {
        cout << "Путь указывает на файл"s << endl;
    } else if (status.type() == filesystem::file_type::directory) {
        cout << "Путь указывает на папку"s << endl;
    } else {
        cout << "Путь указывает другой объект"s << endl;
    }
}
void PrintFileOrFolder(filesystem::path p) {
    error_code err;
    auto status = filesystem::status(p, err);
    
    if (err) {
        return;
    }

    PrintFileOrFolder(status);
} 
```
Цикл в функции main тоже нужно заменить:
```cpp
    for (const auto& dir_entry: filesystem::directory_iterator(p)) {
        PrintFileOrFolder(dir_entry.status());
    } 
```
Другие подробности о путях вас ждут в следующем уроке. А пока что решите задачу на применение `filesystem`.