## Тонкости открытия файлов
Вы узнали о двух режимах открытия файла — через `ifstream` для чтения и через `ofstream` для записи. Открывать для чтения можно только существующий файл, открывать для записи — существующий и несуществующий. При открытии через `ofstream` несуществующий файл будет создан, а существующий — очищен.

Есть также универсальный вариант — `fstream`, который позволяет осуществлять как чтение, так и запись. `fstream` позволяет всё, что могут делать `ifstream` и `ofstream`. 

Особенности его поведения можно устанавливать специальными флагами. Их задают при открытии файла конструктором или методом `open`:
- ios::in — разрешить чтение,
- ios::out — разрешить запись,
- ios::app — писать только в конец файла, дополняя его,
- ios::ate — первая запись будет в конец файла,
- ios::trunc — удалить содержимое файла при открытии,
- ios::binary — бинарный режим. Будет рассмотрен в следующих уроках.

Комбинировать флаги вы можете операцией `|`. Например, режим по умолчанию для `fstream` — это `ios::in | ios::out`. Все возможные комбинации флагов и особенности их работы есть в документации по `basic_filebuf`.

Эти флаги можно указывать и для однонаправленных потоков, чтобы изменить их поведение. Например, если для `ofstream` укажете `ios::app`, поток будет не удалять содержимое файла, а дописывать все данные в конец.
Рассмотрим пример:
```ccp
#include <fstream>
#include <iostream>
#include <string>

using namespace std;

int main(int argc, const char** argv) {
    // 1
    {
        fstream fout("telefon.txt", ios::out);
        fout << "У меня зазвонил телефон."s << endl;
        fout << "- Кто говорит?"s << endl;
    }

    // 2
    {
        fstream fout("telefon.txt", ios::in | ios::out);
        fout << "- Слон."s << endl;
    }

    // 3
    {
        fstream fin("telefon.txt", ios::in);
        string str;
        while (getline(fin, str)) {
            cout << str << endl;
        }
    }
} 
```
В этом примере файл `telefon.txt` открывался трижды. Вначале файл был создан или очищен, в него записался текст. Во второй секции мы дописали текст «- Слон.», а в третьей вывели содержимое файла на экран.

Обратите внимание, что файл во второй секции был открыт сразу на чтение и запись. Это позволяет в числе прочего не удалять содержимое файла при открытии: прочитать сохранённые данные и при необходимости внести в них изменения.

Результат получился такой:
```
- Слон.
зазвонил телефон.
- Кто говорит? 
```
Слово «Слон» записалось поверх слов «У меня», и получилась бессмыслица. Произошло это потому, что файл состоит из байтов, и при записи новый текст не вставляется, как в методе `insert` у вектора, а записывается поверх уже существующего текста. Ошибка в том, что мы пишем в начало файла, а правильно было бы писать в конец. Дело во флагах  `ios::in` | `ios::out`. При таком режиме открытия указатель записи ставится на начало файла, и запись производится поверх уже существующего текста. Если бы файл открывался с флагами `ios::out` | `ios::app`, данные попали бы в конец, как и нужно. Используйте эту комбинацию, если просто хотите дописать в файл, не производя чтений.

Чтение не понадобилось, `ios::in` тут исключительно для сохранения данных. В реальных программах не стоит включать лишние флаги доступа, поскольку они могут помешать открытию файла. Например, если файл имеет права `-wx`, его можно открыть только на запись, но не на чтение.

Чтобы исправить ситуацию, укажем позицию записи методом `seekp`. Последняя буква `p`, от слова *put*, говорит, что этот метод меняет именно позицию записи. Есть также метод, предназначенный, чтобы узнать эту позицию — `tellp`.

Заменим вторую секцию на такую:
```cpp
    // 2
    {
        fstream fout("telefon.txt", ios::in | ios::out);
        fout.seekp(72);
        fout << "- Слон."s << endl;
        cout << "Writing at pos: "s << fout.tellp() << endl;
    } 
```
Содержимое файла исправилось. И вывод программы тоже:
```
Writing at pos: 83
У меня зазвонил телефон.
- Кто говорит?
- Слон. 
```
Видно, что после записи новых символов позиция записи увеличилась. Здесь мы подставили явно число 72, заранее вычислив количество символов в файле на данный момент. Так делать неудобно, поэтому у `seekp` есть второй параметр, обозначающий точку отсчёта. Он может принимать следующие значения:
- `ios::beg` — отсчитывать от начала файла,
- `ios::end` — отсчитывать от конца файла,
- `ios::cur` — отсчитывать от текущего места.

При использовании `ios::end` и `ios::cur` допустимо отрицательное значение позиции. Например, если мы хотим сместиться на десять символов назад, можно написать `stream.seekp(-10, ios::cur)`. Перейти при записи в самый конец файла можно командой `stream.seekp(0, ios::end)`. Слегка модифицируем авторский текст, заменив второй блок на такой:
```
    // 2
    {
        fstream fout("telefon.txt", ios::in | ios::out);
        fout.seekp(-17, ios::end);
        fout << "на линии?"s << endl << "- Слон."s << endl;
        cout << "Writing at pos: "s << fout.tellp() << endl;
    } 
```
Запустим и проверим вывод:
```
Writing at pos: 84
У меня зазвонил телефон.
- Кто на линии?
- Слон. 
```

Указано число 17, превышающее количество букв и символов, которые мы прошли назад от конца файла. Это связано с тем, что литералы в исходном коде записаны в кодировке UTF-8, и в ней же они будут сохраняться в файл. В этой кодировке каждая русская буква занимает два байта. Знак вопроса занимает один байт, а перевод строки — два байта. Всего получается 17 байт. Вид перевода строки зависит от операционной системы и режима открытия. Под MacOS и Linux он будет занимать один байт, под Windows — два.

У методов `seekp` и `tellp` есть аналоги, получающие и устанавливающие позицию чтения. Эти методы работают аналогичным образом, но влияют на операции чтения. Они называются `seekg` и `tellg` — последняя буква от слова get означает, что речь идёт о чтении.