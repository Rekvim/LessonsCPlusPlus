## Не очень чистые функции — побочные эффекты
Назначение любой функции — вычисление или совершение действия. Причём это «или» очень важно. Не стоит совмещать в одной функции несколько операций. Результат вычисления возвращается оператором return, а результат действия — некоторое изменение во внешнем для функции мире. Оно называется побочный эффект.
Каким может быть побочный эффект функции? Выберите один или несколько вариантов.

Изменение глобальной переменной. Надеемся, что вы ими не пользуетесь.

Изменение поля класса неконстантным методом. Это типичный пример побочного эффекта.

Изменение `mutable` поля класса константным методом. Несмотря на то, что метод константный, он может иметь побочный эффект.

Прямое или косвенное изменение статического поля класса или статической переменной. Даже константный метод класса может поменять статическую переменную, создав побочный эффект.

Изменение параметра, переданного по неконстантной ссылке или указателю. Значения, переданные в функцию по ссылке, — это тоже внешний мир для неё.

Запись в поток ввода-вывода. Поток наверняка что-нибудь меняет во внешнем мире, например выводит данные на экран или в файл.

Чтение из потока. Следующее чтение прочтёт уже новые данные. А значит, чтение что-нибудь меняет во внешнем мире.

Всё это — побочные эффекты. Когда они допустимы и как с ними управляться, вы узнаете из этого урока.

#### Функции с побочными эффектами и без них

Функция без побочных эффектов при повторных вызовах с одними и теми же аргументами будет выдавать один и тот же результат. Исключение — функция получения времени, которая зависит от внешнего состояния, не меняя его. 

Но есть и требование, из которого исключений нет: функция без побочных эффектов должна принимать все параметры по константной ссылке, константному указателю, либо по значению. Если эта функция — метод класса, то он должен быть константным и не изменять `mutable` объекты этого класса.

Наконец, побочным эффектом было бы изменение глобальных переменных. В курсе обычно об этом не говорится в надежде, что вы и так ими не пользуетесь.

Какой `mutable` объект приходится использовать в методе без побочных эффектов при многопоточной работе? — std::mutex.

Используйте любой объект: если возвратить его состояние в исходное, можно считать, что побочного эффекта нет. Однако при многопоточной работе даже это не спасёт: другие потоки могут получить доступ к объекту в изменённом состоянии. Но блокирование и разблокирование мьютекса можно не считать побочным эффектом — оно не влияет на результат работы функций.

Функция с побочными эффектами в идеале вообще не имеет `return`. Пример такой функции — сеттер класса:
```cpp
class Person {
public:
    void SetCat(Cat cat) {
        my_cat_ = std::move(cat);
    }

private:
    Cat my_cat_;
};
```
Но возвращение всё же допустимо. Особенно если речь идёт о возвращении отчёта о совершённом действии. Так, например, делает метод `std::map::insert`: он возвращает итератор на добавленный элемент и флаг успеха.
Хорошая ли сигнатура у метода `std::map::insert`?
```cpp
std::pair<iterator,bool> insert(const value_type& value);
std::pair<iterator,bool> insert(value_type&& value); 
```

— Возвращаемый тип невнятный, лучше было оформить его структурой.

Сигнатура никак не подскажет, что означает `iterator` и `bool`. Однако для метода из стандартной библиотеки это вполне допустимо — знание стандартной библиотеки входит в умение программировать на C++. Структуры в аналогичном случае используют новый алгоритм `copy`, реализованный в библиотеке ranges С++20.

Ещё один пример возвращающей функции с побочным эффектом — `PushStudents` из класса `Cohort`. Эта функция возвращает список студентов, которым было отправлено уведомление:
```cpp
class Cohort {
public:
    std::vector<Student> PushStudents();

// ...

};
```
Что указывает на наличие побочного эффекта этой функции? — Метод не константный.

Какие из этих функций и методов содержат побочный эффект? 

- std::ofstream::open. Побочный эффект — файл создан или очищен.

- std::ifstream::open. Побочный эффект — файл открыт операционной системой.

- std::istream& operator>> (const istream&, int&). Побочный эффект — из потока изъяты данные.

#### Возврат через параметр

Побочный эффект может касаться параметров, передаваемых по неконстантной ссылке или указателю. Это ещё один способ возврата из функции.

Таким способом можно заставить функцию возвращать несколько значений, и он действительно был популярным до появления распаковки, а в некоторых случаях и после.
Рассмотрим новый вариант функции выдачи диплома:
```cpp
enum class GraduateFailReason {
    ALL_SUCCESS,
    NOT_ALL_SPRINTS_PASSED,    // не все спринты пройдены
    FINAL_TASK_NOT_APPROVED,   // финальное задание не прошло ревью
    INCOMPLETE_FUNDING,        // неполная оплата
    DIPLOMA_ALREADY_RECEIVED   // диплом уже получен
};

class Cohort {
public:
    GraduateFailReason Graduate(int student_id, Diploma& out_diploma);
    // ...
};
```
Пришлось добавить новое значение в `enum` для состояния успеха — `ALL_SUCCESS`.
Укажите недостатки такой реализации:

Правильный ответ
Нет возможности NRVO для диплома.
NRVO возможно только для значения, возвращаемого через return.

Правильный ответ
Нужно иметь уже сконструированный диплом для вызова функции.
Ссылка, которую передали в функцию, требует, чтобы объект уже существовал.

Неправильный ответ
Из сигнатуры функции не ясно, что она возвращает данные в параметр.
Неконстантная ссылка указывает на то, что объект будут менять. Вполне логично, что функция будет возвращать диплом именно через параметр.

Неправильный ответ
Функция обязана даже в случае ошибки создать объект Diploma и возвратить его.
Она может не менять объект out_diploma.

Правильный ответ
Из кода вызова метода не ясно, что возврат производится в параметр.
Пример будет чуть ниже.

Неправильный ответ
У такого метода нет недостатков, он идеален.
Увы, есть, и немало.
Как вам задача?


Вызывать метод будут как-нибудь так:
```cpp
Diploma new_diploma;

auto err = cohort100.Graduate(student_to_graduate, new_diploma);

if (err == ALL_SUCCESS) {
    cout << "Поздравляем с успешным завершением курса! Ваш диплом:\n"sv << new_diploma << endl;
} else {
    cout << "Ошибка, код "sv << static_cast<int>(err) << endl;
} 
```
Из вызова метода совершенно не ясно, что параметр `new_diploma` выходной: `cohort100.Graduate(student_to_graduate, new_diploma)`.
Чтобы сделать код более внятным, можно заменить ссылку на указатель. Тогда вызов как бы скажет, что функция собирается изменить параметр: `cohort100.Graduate(student_to_graduate, &new_diploma)`. Но добавится другая проблема — указатель в сигнатуре намекает на возможность передачи `nullptr`, что в этом случае не подразумевается.

Распаковка, `variant` и `optional` позволяют избавиться от возвращения через параметр. Это нужно делать, чтобы лучше соответствовать прямому назначению синтаксических элементов: `return` — для возврата, параметры — для передачи данных в функцию.

В ряде случаев возврат через параметр всё же обоснован. Например, чтобы сообщить функции о ненужности какого-либо вычисления. Рассмотрим пример метода, вычисляющего сразу ряд статистик — суммы, суммы квадратов, среднего арифметического, среднего гармонического и стандартного отклонения:
```cpp
void ComputeStatistics(float* sum, float* sq_sum, float* arithmetic_mean, float* harmonic_mean, float* std_dev);
```
В каждый параметр может быть передано значение `nullptr`, чтобы показать, что вычисление соответствующей статистики не требуется. Лучше было бы реализовать для каждой статистики отдельную функцию, но такой подход потребует нескольких проходов для вычисления нескольких статистик, что будет менее эффективно.

Как ещё можно улучшить эффективность этой функции, если на этапе написания кода вызова уже известно, какие статистики надо вычислить для каждого конкретного случая?  — Использовать шаблонные параметры для определения нужности вычисления.

Шаблонные параметры позволят использовать `if constexpr` и избавиться от условных переходов при вычислении статистик.

#### Изменение состояние аргумента

Ещё один случай, когда побочный эффект обоснован, — это не прямой возврат через параметр, а изменение состояния параметра. Так мы часто передаём в функцию неконстантную ссылку на `ostream&`:

```cpp
void RenderColor(std::ostream& out, Rgb rgb) {
    out << "rgb("sv << static_cast<int>(rgb.red)  //
        << ',' << static_cast<int>(rgb.green)     //
        << ',' << static_cast<int>(rgb.blue) << ')';
}
```

Такая функция вполне допустима, потому что мы знаем, что основное назначение потока — предоставить интерфейс для вывода в него. В месте вызова это будет ясно, нет никакой причины передавать cout по константной ссылке.

Рассмотрим другой пример — менеджер задач Практикума:
```cpp
struct TaskPassResult {
    bool is_passed;
    // ...
};

class Task {
public:
    TaskPassResult RunCode(std::string_view code) const;
};

class TaskManager {
public:
    void RegisterTaskResult(int student_id, int task_id, TaskPassResult result);
    const Task& GetTask(int task_id) const;
}; 
```
Метод для прохождения задания и получения оценки за него можно реализовать в классе когорты так:
```cpp
class Cohort {
public:
    void PassTask(TaskManager& task_manager, int student_id, int task_id, std::string_view solution_code) {
        auto result = task_manager.GetTask(task_id).RunCode(solution_code);
        if (result.is_passed) {
            SetTaskPassed(student_id, task_id);
        }
        task_manager.RegisterTaskPass(student_id, task_id, std::move(result));
    }

    void SetTaskPassed(int student_id, int task_id);
};
```
При вызове такого метода неясно, что он собирается изменять объект TaskManager:
```cpp
cohort100.PassTask(task_manager, student_id, task_id, code);
```
Чтобы сделать побочный эффект более явным, применим декомпозицию — разбиение задачи на подзадачи:
```cpp
class Cohort {
public:
    // теперь TaskManager передаётся по константной ссылке
    [[nodiscard]] TaskPassResult PassTask(const TaskManager& task_manager, int student_id, int task_id, std::string_view solution_code) {
        auto result = task_manager.GetTask(task_id).RunCode(solution_code);
        if (result.is_passed) {
            SetTaskPassed(student_id, task_id);
        }
        return result;
    }

    void SetTaskPassed(int student_id, int task_id);
};

// ...
// метод не меняет task_manager, неявного побочного эффекта больше нет
auto result = cohort100.PassTask(task_manager, student_id, task_id, code);
task_manager.RegisterTaskPass(student_id, task_id, std::move(result));
```
Декомпозиция — это прекрасно! Ведь чем меньше делает функция, тем она понятнее, тем более предсказуемо её поведение и тем лучше она соответствует своему названию. Не забывайте, функция — это именованное действие. Если действие сложное, будет замечательно разбить его на несколько и дать имя каждому.

Порой объектам требуется более сложное взаимодействие, и так просто исключить передачу по неконстантной ссылке не получится. Но наличие сложного взаимодействия — уже признак того, что в программе что-то идёт не так и нужно задуматься, как можно улучшить архитектуру кода.

#### Подведём итог

Функциональные языки программирования стремятся к тому, чтобы функции вовсе не имели побочных эффектов — результат должен зависеть только от аргументов. Но даже тогда функции не могут быть полностью чистыми, ведь программа должна оставить что-нибудь после себя — хотя бы вывести данные в файл, сеть, окно консоли или отобразить интерфейс. Всё это побочные эффекты.

В императивном языке C++ избежать побочных эффектов тем более не удастся. Но это не что-то плохое, ведь помимо вычисления возможно ещё одно назначение функции — выполнение действия. Главное, не смешивать два назначения функции и чётко говорить о наличии побочного эффекта названием и сигнатурой. В C++ это можно делать особенно выразительно благодаря константности. Наличие const во всех необходимых местах показывает отсутствие побочного эффекта.

Желательно, чтобы побочный эффект был виден в месте вызова. Иногда всё понятно по назначению объекта: например, ostream передаётся в функцию для создания побочного эффекта. В других случаях это менее очевидно, и тогда желательно подумать, как исключить неявный побочный эффект.

Мы чуть не забыли важный аспект любой программы — тестирование. Подумайте, как юнит-тесты должны взаимодействовать с побочным эффектом? — Корректность побочного эффекта должна быть проверена юнит-тестами наравне с корректностью возвращаемого значения.


Какие из этих функций и методов имеют побочный эффект? Их писал грамотный программист, и побочный эффект определяется сигнатурой функции. Глобальные переменные этот программист не использует. И вы тоже так делайте.


— Функция void Swap(int& l, int& r);. Функция принимает параметр по неконстантной ссылке — признак побочного эффекта.

— Функция char RemoveLastChar(std::string& str);. Несмотря на наличие возвращаемого значения, функция имеет побочный эффект.

— Метод класса. Метод принимает параметры по значению и константной ссылке, но он не константный — побочный эффект.
```cpp
class Park {
public:
    std::vector<Tickets> Enter(const std::vector<Person>& who, 
                               std::chrono::system_clock::time_point when);
}; 
```

Вы изучили разные способы передачи аргументов и возврата из функции. Вариантов много: ссылка, константная ссылка, Forwarding-ссылка, указатель, значение, пара итераторов, `optional`, `variant`, умный указатель. Но правильный способ обычно только один. Как вы узнали из этих тем, первое, что нужно понять, — требуется ли передача владения. Огромную роль играет понятность сигнатуры функции — без этого очень просто допустить ошибку. Важна также и прозрачность в месте вызова. Иногда, особенно при написании простых функций или функций, работающих с тяжёлыми объектами, нужно думать о производительности.