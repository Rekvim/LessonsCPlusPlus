## Возврат оптом — получаем много объектов

В прошлой теме вы узнали, как передать набор объектов в функцию. Варианты были такие:

- пара итераторов;
- контейнер;
- количество с указателем либо итератором;
- `span`.
- 
Для возврата из функции эти способы также годятся, но применять их надо с умом. И первое, что нужно решить, — передаёт ли функция владение набором объектов или оставляет его себе.

#### Возврат контейнера

Если функция вызывалась для того, чтобы сформировать некоторый набор и возвратить его, передача владения естественна. В этом случае самый простой способ — возвратить контейнер с элементами. Он подходит, если вы чётко знаете контекст использования функции и не собираетесь его менять. При этом можно полагаться на NRVO:
```cpp
class Cohort {
public:
    // ...
    PushResult PushStudents() {
        StudentList students_to_push = GetNotReadyStudents();
        for (Student& student : students_to_push) {
            PushStudent(student);
        }

        return students_to_push;
    }
};
```
#### Возврат контейнера по ссылке
Класс может реализовывать геттер для получения контейнера без передачи владения. В этом случае удобно использовать псевдоним, чтобы можно было поменять контейнер, ничего не нарушив в месте его применения:
```cpp
class Cohort {
public:
    using StudentMap = std::unordered_map<int, Student>;

    const StudentMap& GetAllStudents() const {
        return all_students_;
    }

private:
    StudentMap all_students_;
};
```
Возвращать неконстантную ссылку, чтобы произвести какие-либо операции с контейнером, не нужно. Это может привести к неконсистентности данных класса и отбирает у него возможность контролировать своё содержимое, что часто приводит к ошибкам:
```cpp
class Cohort {
public:
    using StudentMap = std::unordered_map<int, Student>;

    // плохо:
    StudentMap& GetAllStudents() {
        return all_students_;
    }

private:
    StudentMap all_students_;
};

// ...

Cohort cohort100;

// ...

// не делайте так:
cohort100.GetAllStudents[new_id] = move(new_student);
```
Для допустимых изменений контейнера класса используйте отдельные методы:
```cpp
class Cohort {
public:
    using StudentMap = std::unordered_map<int, Student>;

    const StudentMap& GetAllStudents() const {
        return all_students_;
    }

    int RegisterStudent(Student new_student) {
        // тут можно выполнить дополнительную инициализацию,
        // например открыть студенту доступ к первому спринту
    }

private:
    StudentMap all_students_;
};

// ...

Cohort cohort100;

// ...

int new_id = cohort100.RegisterStudent(move(new_student));
```
#### Возврат пары итераторов

Отметьте, в каких случаях уместен возврат пары итераторов? — Без передачи владения.


Возвращать пару итераторов можно, только если владение не передаётся. Иначе получится, что функция отказалась от владения объектами и возвращённые итераторы указывают в пустоту. Это приведёт к неопределённому поведению.

Возврат пары итераторов более универсален, чем возврат контейнера. Классы могут определить методы `begin` и `end` для последующего использования в `for` по диапазону. С таким вы уже сталкивались при написании класса поисковой системы:
```cpp
class Cohort {
public:
    using StudentMap = std::unordered_map<int, Student>;

    StudentMap::const_iterator begin() const {
        return all_students_.begin();
    }

    StudentMap::const_iterator end() const {
        return all_students_.end();
    }

private:
    StudentMap all_students_;
};

// ...

Cohort cohort100;

// ...

for (const auto& student: cohort100) {
    // ...
} 
```
#### Приём выходного итератора
Вы знаете немало алгоритмов, которые принимают итератор для того, чтобы выдавать ответ. Например, `std::copy`:
```cpp
template<class InputIt, class OutputIt>
OutputIt copy(InputIt first, InputIt last, OutputIt d_first);
```
Передаёт ли `copy` владение какими-либо объектами? — Передаёт.

Этот алгоритм передаёт владение, но только не теми объектами, которые ему переданы на вход, а их копиями. Его реализация может быть крайне простой:
```cpp
template<class InputIt, class OutputIt>
OutputIt copy(InputIt first, InputIt last, OutputIt d_first) {
    while (first != last) {
        *d_first++ = *first++;
    }
    return d_first;
}
```
Этот алгоритм записывает прямо в итератор, инкрементируя его после каждой записи. В качестве выходного итератора можно передать как специальный итератор c побочным эффектом разыменования `back_inserter` или `inserter`, так и обычный итератор. Но если передаётся обычный итератор, нужно убедиться, что в контейнере уже достаточно места для новых элементов.

Ещё один пример необычного итератора, который можно использовать для возврата из функции — `ostream_iterator` из заголовка `<iterator>`. Полученные данные он пишет напрямую в указанный поток.

Напишем функцию, выдающую простые числа на заданном диапазоне:
```cpp
#include <cmath>
#include <iostream>
#include <iterator>
#include <string>

using namespace std;

// не самый эффективный тест на простоту числа
bool IsPrime(int n) {
    if (std::abs(n) < 2) {
        return false;
    }

    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}

template<typename OutputIt>
void GetPrimeNumbers(int from, int to, OutputIt output_iter) {
    for (int i = from; i < to; ++i) {
        if (IsPrime(i)) {
            *output_iter++ = i;
        }
    }
}

int main() {
    // результат выведен в cout через пробел
    GetPrimeNumbers(0, 100, ostream_iterator<int>(cout, " "));
}
```
Результат выполнения программы:
```
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
```
Выходной итератор — это довольно универсальный способ возврата набора из функции с передачей владения. В отличие от прямого возврата вектора, он позволяет записывать данные в любой контейнер, причём даже если в нём уже есть элементы.

#### Приём выходного указателя или span

Метод потоков ввода `read` принимает указатель и количество желаемых элементов. Он реализован для общих потоков произвольного типа. Для привычного случая потоков `char` сигнатура могла бы быть такой:
```cpp
istream& istream::read(char* buffer, int buffer_size);
```
Этот метод возврата вполне допустим при соблюдении следующих условий:
- заранее известно, сколько нужно объектов, и под них выделена память;
- объекты располагаются в памяти последовательно, например хранятся в векторе или array;
- объекты можно сконструировать заранее, а владение принять через присваивание.
- 
В стандарте C++20 можно использовать `span`, чтобы передавать один параметр вместо двух. О `span` говорилось в уроке о передаче множества объектов в функцию. Дополнительно можно прочитать в [документации](https://en.cppreference.com/w/cpp/container/span.html).

#### Приём callback

В предыдущей теме вы подробно изучили вопрос передачи функционального объекта в качестве параметра. Его же можно использовать и для возврата из функции. Этот способ напоминает выходной итератор, вместо которого можно применить callback, вызываемый при поступлении нового объекта:
```cpp
template <typename Callback>
void GetPrimeNumbers(int from, int to, Callback callback) {
    for (int i = from; i < to; ++i) {
        if (IsPrime(i)) {
            callback(i);
        }
    }
}

int main() {
    GetPrimeNumbers(0, 100, [](int p){
        cout << p << " "sv;
    });
}
```
Использовать callback вместо уже готового итератора немного сложнее, потому что нужно написать лямбда-функцию, но зато этот способ ещё более универсальный. Например, так можно вывести только числа-близнецы:
```cpp
#include <optional>

// ...

template<typename Callback>
void GetPrimeNumbers(int from, int to, Callback callback) {
    for (int i = from; i < to; ++i) {
        if (IsPrime(i)) {
            callback(i);
        }
    }
}

int main() {
    optional<int> prev;
    GetPrimeNumbers(0, 100, [&prev](int p) {
        if (prev && p - *prev == 2) {
            cout << *prev << "-"sv << p << " "sv;
        }
        prev = p;
    });
}
```
Вывод программы:
```
3-5 5-7 11-13 17-19 29-31 41-43 59-61 71-73
```
У возврата через callback много преимуществ:
- это эффективно;
- можно использовать как с передачей владения, так и без неё;
- наиболее универсальный способ, можно реализовать любую прихоть;
- можно начать обрабатывать значения по ходу их появления, избегая создания контейнера;
- лямбда-функция может дать команду остановить вычисление через возвращаемое значение.

Но также есть и недостатки:

- иногда лямбда-функции трудно читать;
- их не протестировать юнит-тестами;
- эффективный способ приёма через шаблонный параметр имеет невнятную сигнатуру.

#### Будущее
В C++20 введено понятие корутин — это специальные функции, которые могут возвратить значение, не прекращая свою работу, чтобы потом сделать ещё возвраты. Корутины нарушают привычную логику стека вызовов и в C++20 реализованы не полностью. Полная поддержка корутин ожидается только в стандарте 2023 года.

#### Подведём итоги

С возвратом набора однотипных объектов всё сложнее, чем с передачей его в функцию. При передаче владение объектами и контейнером продолжает находиться под контролем вызывающей функции. А при возврате функция, создавшая набор объектов, завершается и прекращает владение чем-либо.

Подведём итог урока, выбрав наиболее приемлемый способ получения набора объектов для разных случаев.

Возвращается уже готовый набор объектов, которыми владеет класс. В этом случае возвращаем контейнер по константной ссылке:
```cpp
class Cohort {
public:
    const std::vector<int>& GetGradesByStudent(int student_id) const {
        return grades_by_student_.at(student_id);
    }

private:
    std::map<int, std::vector<int>> grades_by_student_;
};
```
Мы точно знаем, в каком контексте будет использоваться возвращаемое значение, либо производительность не важна. В этом случае возвращаем контейнер:
```cpp
class Cohort {
public:
    std::vector<int> GetUngradedStudents() const {
        std::vector<int> result;
        for (const auto& [id, grades] : grades_by_student_) {
            if (!grades.empty()) {
                result.push_back(id);
            }
        }
        return result;
    }

private:
    std::map<int, std::vector<int>> grades_by_student_;
};
```
Хранить элементы — это основное назначение класса, и мы хотим итерироваться по объекту класса. Тогда нужен возврат итераторов методами begin и end.
```cpp
class JSONArray {
public:
    using Container = std::vector<JSONelement>;

    Container::iterator begin() {
        return elements_.begin();
    }
    
    Container::iterator end() {
        return elements_.end();
    }

    // константные итераторы и cbegin, cend

private:
    Container elements_;
};
```
Хотим позволить вызывающей стороне складывать в любой контейнер по её желанию или даже сразу выводить в поток. В этом случае принимаем выходной итератор:
```cpp
class Cohort {
public:
    template <typename OutputIt>
    void GetUngradedStudents(OutputIt dst) const {
        for (const auto& [id, grades] : grades_by_student_) {
            if (!grades.empty()) {
                *dst++ = id;
            }
        }
    }

private:
    std::map<int, std::vector<int>> grades_by_student_;
};
```
Предполагаем, что вызывающая сторона может не сохранять объекты, а сразу обрабатывать, либо хотим дать ей возможность прервать вычисление. Тогда нужен наиболее универсальный способ — возврат через callback:
```cpp
template<typename Callback>
void GetPrimeNumbers(int from, int to, Callback callback) {
    for (int i = from; i < to; ++i) {
        if (IsPrime(i)) {
            callback(i);
        }
    }
}
```