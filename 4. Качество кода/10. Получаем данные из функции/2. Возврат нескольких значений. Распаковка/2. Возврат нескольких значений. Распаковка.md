## Возврат нескольких значений. Распаковка
Продолжим разрабатывать бэкенд для Практикума — напишем сигнатуру метода вычисления лучшего студента и его рейтинга:
```cpp
class Cohort {
public:
    using Rating = int;
    std::pair<const Student&, Rating> FindBestStudent() const;
};
```
Так можно вернуть из функции два значения. Принять их удобнее всего, воспользовавшись прекрасной возможностью C++17 — распаковкой.
```cpp
Cohort cohort100;
// ...
auto [best_student, rating] = cohort100.FindBestStudent();
```
Напишите название класса, который подойдёт для передачи большего количества значений. Укажите только имя без квалификации. — Ваш ответ неправильный.

Правильный ответ — `tuple`. Он позволит вернуть целый набор значений. Например, ещё и время, когда студент стал лучшим:
```cpp
class Cohort {
public:
    using Rating = int;
    using Clock = std::chrono::system_clock;
    std::tuple<const Student&, Rating, Clock::time_point> FindBestStudent() const;
}; 
```
Теперь напишем метод, который напомнит студентам о приближающемся дедлайне:
```cpp
class Cohort {
public:
    using StudentList = std::vector<Student>;
    std::pair<StudentList, StudentList> PushStudents();
};
```

Метод возвращает два значения: список студентов, которых поторопили, и список успевающих студентов — им отправлять уведомления не понадобилось. А теперь задумайтесь: если бы этой фразы не было, вы бы ни за что не догадались, что функция возвращает именно это. Из сигнатуры ясно, что функция делит студентов на две категории, и можно догадаться, по какому признаку. Но никак не получится понять, что порядок в паре именно такой. Для этого пришлось бы смотреть в реализацию функции или на фразу в начале этого абзаца.

Чтобы устранить неоднозначность, удобно создать структуру, предназначенную для хранения возвращаемого значения:
```cpp
class Cohort {
public:
    using StudentList = std::vector<Student>;
    struct PushResult {
        StudentList pushed_students;
        StudentList ready_students;
    };
    PushResult PushStudents();
};
```
Кстати, распаковка при этом продолжает работать:
```cpp
auto [pushed, ready] = cohort100.PushStudents(); 
```
Нужно иметь в виду, что во время распаковки, как и во время конструирования, учитывается только порядок полей структуры, а не их названия. Поэтому, если разработчику вдруг придёт в голову поменять поля местами, программа начнёт работать неправильно, но не сообщит об ошибке. Такого разработчика, скорее всего, не отблагодарят коллеги. Меняя структуру, убедитесь, что меняется порядок типов полей. Этим вы гарантируете, что во всех местах, где распаковку забыли исправить, возникнут ошибки. Покажем это на примере:
```cpp
struct NamedPoint {
    string name;
    int x;
    int y;
};

NamedPoint getLastPoint(); 
```
Предположим, что мы получаем результат функции getLastPoint и распаковываем его таким способом:
```cpp
auto [name, x, y] = getLastPoint();
string full_text = name + " ("s + to_string(x) + ","s + to_string(y) + ")"s; 
```
Если поменять поля `x` и `y` местами, то конструкция `auto [name, x, y] = getLastPoint();` приведёт к нежелательному результату: переменная `x` программы получит координату `y`, а переменная `y` — координату `x`.

Поскольку типы полей структуры не изменились, компилятор не сможет заметить ошибку и предупредить нас о том, что что-то идёт не так. Предположим теперь, что мы изменили структуру, поменяв порядок типов полей:
```cpp
struct NamedPoint {
    int x;
    int y;
    string name;
};
```
В этом случае конструкция `auto [name, x, y] = getLastPoint();` тоже будет работать некорректно: координаты запишутся в переменные name и `x`, а имя — в `y`. Но в отличие от предыдущего случая компилятор сможет предупредить вас. В следующей строке возникнет ошибка:
```cpp
string full_text = name + " ("s + to_string(x) + ","s + to_string(y) + ")"s;
//ошибка: no match for 'operator+' (operand types are 'int' and 'std::basic_string<char>') 
```
Причина ошибки в том, что переменную `name` использовали как `string`, но после перестановки полей она приобрела тип `int`. Так типы помогли проконтролировать, что изменения внесены во все нужные места. Выполняя рефакторинг, всегда задавайтесь вопросом: сможете ли вы надёжно отследить места, на которые повлияли исправления кода?

Теперь об оптимизации. Чтобы понять, будет ли применяться NRVO при возврате кортежа или структуры, вспомним, что означает эта аббревиатура.
Чему соответствует первая буква аббревиатуры NRVO? — Named

Как видно из названия, эта оптимизация применяется только если производится непосредственный возврат именованного значения — переменной. Когда значение обёрнуто в инициализатор или находится внутри функции, NRVO не случается:
```cpp
class Cohort {
public:
    // ...
    PushResult PushStudents() {
        StudentList ready_students = GetReadyStudents();
        StudentList students_to_push = GetOtherStudents(ready_students);
        for (Student& student : students_to_push) {
            PushStudent(student);
        }

        return {ready_students, students_to_push};  // неэффективно
    }
};
```
В такой реализации может произойти копирование двух, возможно немаленьких, списков. В подобных случаях не забывайте `move`:
```cpp
class Cohort {
public:
    // ...
    PushResult PushStudents() {
        StudentList ready_students = GetReadyStudents();
        StudentList students_to_push = GetOtherStudents(ready_students);
        for (Student& student : students_to_push) {
            PushStudent(student);
        }

        return {std::move(ready_students), std::move(students_to_push)}; // правильно
    }
};
```

На этом заканчивается урок, но не хитрости с возвратом нескольких значений. Ещё один пример похожей ситуации вас ждёт в уроке о побочных эффектах.

В этой теме вам будет предложена большая задача, состоящая из трёх частей. Первая из них — ниже. При решении будьте аккуратны — вам предстоит его расширять. 

Во второй и третьей частях задачи будут проверены ваши умения писать расширяемый код и читать чужой.