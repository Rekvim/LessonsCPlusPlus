## Хорошие и плохие хеш-функции
Мы рассмотрели уже две хеш-функции для автомобильных номеров. Одна — простая — учитывала только цифровую часть. Другая — её вы написали сами — учитывала весь номер, но предварительно конвертировала его в строку. В этом уроке выясним, можно ли утверждать, что одна из них лучше другой, и разберёмся, что такое хорошая хеш-функция. Вы увидите: `unordered_map` может быть эффективным, только если выбранная хеш-функция хороша.
В этом уроке нам понадобится генератор случайных номеров:
```cpp
class PlateGenerator {
    char GenerateChar() {
        uniform_int_distribution<short> char_gen{0, static_cast<short>(possible_chars_.size() - 1)};
        return possible_chars_[char_gen(engine_)];
    }

    int GenerateNumber() {
        uniform_int_distribution<short> num_gen{0, 999};
        return num_gen(engine_);
    }

    int GenerateRegion() {
        uniform_int_distribution<short> region_gen{0, static_cast<short>(possible_regions_.size() - 1)};
        return possible_regions_[region_gen(engine_)];
    }

public:
    VehiclePlate Generate() {
        return VehiclePlate(GenerateChar(), GenerateChar(), GenerateNumber(), GenerateChar(), GenerateRegion());
    }

private:
    mt19937 engine_;

    // допустимые значения сохраним в static переменных
    // они объявлены inline, чтобы их определение не надо было выносить вне класса
    inline static const array possible_regions_
        = {1,  2,  102, 3,   4,   5,   6,   7,   8,  9,   10,  11,  12, 13,  113, 14,  15, 16,  116, 17, 18,
           19, 20, 21,  121, 22,  23,  93,  123, 24, 84,  88,  124, 25, 125, 26,  27,  28, 29,  30,  31, 32,
           33, 34, 35,  36,  136, 37,  38,  85,  39, 91,  40,  41,  82, 42,  142, 43,  44, 45,  46,  47, 48,
           49, 50, 90,  150, 190, 51,  52,  152, 53, 54,  154, 55,  56, 57,  58,  59,  81, 159, 60,  61, 161,
           62, 63, 163, 64,  164, 65,  66,  96,  67, 68,  69,  70,  71, 72,  73,  173, 74, 174, 75,  80, 76,
           77, 97, 99,  177, 199, 197, 777, 78,  98, 178, 79,  83,  86, 87,  89,  94,  95};

    // постфикс s у литерала тут недопустим, он приведёт к неопределённому поведению
    inline static const string_view possible_chars_ = "ABCEHKMNOPTXY"sv;
}; 
```
Протестируем генератор номеров, выведя десять случайных:
```cpp
...

int main() {
    static const int N = 10;
    PlateGenerator plate_gen;

    for (int i = 0; i < N; ++i) {
        cout << plate_gen.Generate() << endl;
    }
} 
```
Проверяем:
```
BT905B173
HO221X87
NC278N11
YY996Y95
YY970P17
ET798M13
XB421A16
MY878T59
XH035T159
KO681Y22 
```
Номера выглядят как случайные. Протестируем с помощью этого генератора различные хеш-функции. Начнём с простой, учитывающей только цифровую часть:
```cpp
class VehiclePlate {
private:
    auto AsTuple() const {
        return tie(letters_, digits_, region_);
    }

public:
    bool operator==(const VehiclePlate& other) const {
        return AsTuple() == other.AsTuple();
    }

    bool operator<(const VehiclePlate& other) const {
        return AsTuple() < other.AsTuple();
    }

    VehiclePlate(char l0, char l1, int digits, char l2, int region)
        : letters_{l0, l1, l2}
        , digits_(digits)
        , region_(region) {
    }

    string ToString() const {
        ostringstream out;
        out << letters_[0] << letters_[1];
        out << setfill('0') << right << setw(3) << digits_;
        out << letters_[2] << setw(2) << region_;

        return out.str();
    }

    const array<char, 3>& GetLetters() const {
        return letters_;
    }

    int GetDigits() const {
        return digits_;
    }

    int GetRegion() const {
        return region_;
    }

private:
    array<char, 3> letters_;
    int digits_;
    int region_;
};

struct PlateHasherTrivial {
    size_t operator()(const VehiclePlate& plate) const {
        return static_cast<size_t>(plate.GetDigits());
    }
}; 
```
Для проверки эффективности контейнера с такой хеш-функцией добавим в него 50 000 случайных номеров и столько же поищем. Будем сравнивать `unordered_set` и обычный `set`. Чтобы поставить контейнеры в равное положение, вначале сгенерируем случайные номера и сохраним их в вектор:
```cpp
#include "log_duration.h"

#include <algorithm>
#include <iterator>
#include <set>
#include <unordered_set>

...

int main() {
    static const int N = 50'000;

    PlateGenerator generator;
    vector<VehiclePlate> fill_vector;
    vector<VehiclePlate> find_vector;

    generate_n(back_inserter(fill_vector), N, [&]() {
        return generator.Generate();
    });
    generate_n(back_inserter(find_vector), N, [&]() {
        return generator.Generate();
    });

    int found;
    {
        LOG_DURATION("unordered_set");
        unordered_set<VehiclePlate, PlateHasherTrivial> container;
        for (auto& p : fill_vector) {
            container.insert(p);
        }
        found = count_if(find_vector.begin(), find_vector.end(), [&](const VehiclePlate& plate) {
            return container.count(plate) > 0;
        });
    }
    cout << "Найдено повторов (1): "s << found << endl;

    {
        LOG_DURATION("set");
        set<VehiclePlate> container;
        for (auto& p : fill_vector) {
            container.insert(p);
        }
        found = count_if(find_vector.begin(), find_vector.end(), [&](const VehiclePlate& plate) {
            return container.count(plate) > 0;
        });
    }
    cout << "Найдено повторов (2): "s << found << endl;
} 
```
Соберём программу с оптимизацией и проверим результат:
```
unordered_set: 371 ms
Найдено повторов (1): 9
set: 52 ms
Найдено повторов (2): 9 
```
Оба алгоритма выдали одинаковый ответ, но unordered_set, вопреки теоретической оценке сложности, оказался вовсе не быстрее, а, наоборот, примерно в семь раз медленнее.
Как вы думаете, почему так происходит? Возникает много коллизий, `unordered_set` не может работать эффективно при таких условиях.

Мы подобрали неудачную хеш-функцию, она провоцирует коллизии. Хорошо, что это всего лишь коллизии номеров в контейнере, а не машин на дорогах! Однако результат не лучший.

Сможете ли вы оценить примерное количество коллизий? Сколько номеров попадает в одну корзинку? — Не много, но и не мало — примерно 50 номеров в каждой корзинке.

Хеш-функция может принимать всего 1000 разных значений. Это значит, что будет задействовано примерно 1000 корзин. Так как номеров 50 000, на каждую корзину приходится по 50 номеров. Это очень большое количество коллизий. Вот почему желательно, чтобы хеш-функция учитывала все данные.

Модифицируем хеш-функцию, чтобы она учитывала не только цифровую часть, но и код региона:
```cpp
struct PlateHasherRegion {
    size_t operator()(const VehiclePlate& plate) const {
        return static_cast<size_t>(plate.GetDigits() + plate.GetRegion() * 1000);
    }
};

...

unordered_set<VehiclePlate, PlateHasherRegion> container; 
```
Умножая регион на 1000 и прибавляя цифровую часть, мы как бы объединяем два числа в одно, получая одно пятизначное или шестизначное число.

![alt text](image.png)

Проверяем результат:
```cpp
unordered_set: 19 ms
Найдено повторов (1): 9
set: 58 ms
Найдено повторов (2): 9 
```
Скорость увеличилась многократно, и теперь неупорядоченный контейнер заметно выигрывает у своего «коллеги» `set`. Но увеличим размер ещё, пускай количество номеров станет равно миллиону.

Попробуйте предугадать, насколько эффективно unordered_set сможет справиться с миллионом. Помните, что количество кодов региона — 122. Как много коллизий можно ожидать? — В одну корзину попадут 8–9 номеров, эффективность снизится.

Имеем 122 кода региона и 1000 цифровых частей. Всего получится 122 000 различных хешей, которые могут определять различные корзины. При распределении миллиона номеров получится по восемь-девять объектов в каждой корзине.

Запустим программу и проверим эффективность контейнеров:
```
unordered_set: 2055 ms
Найдено повторов (1): 3791
set: 2455 ms
Найдено повторов (2): 3791 
```
Неупорядоченный контейнер по-прежнему выигрывает, но уже не так сильно, как хотелось бы. Теперь представьте, что контейнер обрабатывает данные с камеры, установленной в Санкт-Петербурге. Подавляющее количество автомобильных номеров будут иметь коды регионов 78, 98, 178. Количество коллизий тогда будет существенно больше, а контейнер — менее эффективным.

Хорошо, последняя попытка. Возьмём хешер, который вы реализовали в прошлом уроке. Он использует строковое представление номера, а значит, учитывает все его данные. Ваша реализация могла выглядеть так:
```cpp
struct PlateHasherString {
    size_t operator()(const VehiclePlate& plate) const {
        return hasher(plate.ToString());
    }

    hash<string> hasher;
};

...

unordered_set<VehiclePlate, PlateHasherString> container;
``` 
На этот раз эффективность должна быть на высоте. Проверим это:
```
unordered_set: 2651 ms
Найдено повторов (1): 3791
set: 2462 ms
Найдено повторов (2): 3791 
```
Однако нет, эффективность даже ухудшилась. Теперь контейнер проигрывает и set. Мы используем промежуточный поток, операции со string. Это не быстрое дело.

Хеш-функция учитывает все данные, а значит, коллизий будет минимальное количество. На этот раз причина в другом: мы выбрали медленную хеш-функцию и теперь вынуждены использовать промежуточный поток, а также операции со `string` при каждом добавлении и поиске номера. `set` не требует вычисления строкового представления номера и работает быстрее.