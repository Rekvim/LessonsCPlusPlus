## Устройство unordered_map и unordered_set

В этом уроке разберёмся, что позволило контейнеру `unordered_map` работать в разы быстрее, чем его «коллега» `map`. Вы увидите, как использовать его для своих классов, заменив собственный контейнер из прошлого урока на стандартный.

Для начала обратимся к документации. Ранее вы использовали методы `unordered_map::operator[]` и `unordered_map::insert`. Согласно сайту cppreference.com, сложность этих методов в среднем действительно лучше, чем у map. Она оценивается как $O(1)$, если хеш-функция имеет константную сложность.

Но в худшем случае возникает $O(N)$, где $N$ — количество элементов в контейнере. Чтобы понять, какой случай будет худшим, а какой средним, нужно разобраться, как работает `unordered_map` и как получилось добиться такой удивительной средней сложности $O(1)$.

В устройстве `unordered_map` и `unordered_set` лежат идеи, похожие на те, что вы применили при решении задачи в прошлом уроке. Эти контейнеры хранят объекты в корзинках и используют хеш-функцию, чтобы определить, в какой корзинке разместить объект. В `unordered_map` и `unordered_set` реализованы алгоритмы для определения количества корзинок и разрешения коллизий.

Главное отличие `unordered_set` от контейнера, который вы разрабатывали в задаче, — он не использует отдельную корзинку для каждого возможного значения хеш-функции. Благодаря этому хеши объектов могут быть очень большими, а количество выделенных корзинок всё равно будет невелико. Заботиться о том, чтобы объекты располагались компактно в отведённых для них корзинках, не нужно: контейнер сам организует размещение объектов по корзинкам.

В хорошем случае коллизий мало или нет вовсе. Каждая корзинка хранит максимум одно значение, добавление очень быстрое — вычисляем хеш объекта, быстро находим по индексу корзинку и добавляем. Проверка наличия и печать всех элементов будет такой же быстрой. Но хороший случай вероятен только при хорошей хеш-функции. При некоторых условиях он практически гарантирован.

Заменим контейнер из предыдущего урока на `unordered_set`:
```cpp
#include <unordered_set>

// реализация class VehiclePlate из предыдущего урока

int main() {
    unordered_set<VehiclePlate> plate_base;

    plate_base.insert({'B', 'H', 840, 'E', 99});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'H', 'E', 968, 'C', 79});
    plate_base.insert({'T', 'A', 326, 'X', 83});
    plate_base.insert({'H', 'H', 831, 'P', 116});
    plate_base.insert({'A', 'P', 831, 'Y', 99});
    plate_base.insert({'P', 'M', 884, 'K', 23});
    plate_base.insert({'O', 'C', 34, 'P', 24});
    plate_base.insert({'M', 'Y', 831, 'M', 43});
    plate_base.insert({'B', 'P', 831, 'M', 79});
    plate_base.insert({'K', 'T', 478, 'P', 49});
    plate_base.insert({'X', 'P', 850, 'A', 50});

    for (auto& plate : plate_base) {
        cout << plate << endl;
    }
}
 ```
При попытке собрать и запустить эту программу получим такое сообщение: `error: static assertion failed: hash function must be invocable with an argument of key type static_assert``(__is_invocable<const _H1&, const _Key&>{}`.

Эта ошибка показывает, что контейнер не нашёл хеш-функцию для класса. Мы определили хеш-функцию в методе `Hash`, но не сказали контейнеру, что именно её нужно использовать для хеширования.

Чтобы сообщить `unordered_set` и `unordered_map`, как именно вычислять хеш произвольного объекта, нужно создать специальный класс — хешер и указать его в качестве шаблонного параметра контейнера. К хешеру предъявляется только одно требование: объект этого класса должен быть вызываемым — например, переопределять оператор «круглые скобки». Вызов этого объекта должен возвращать число типа `size_t` (этот тип используется в `unordered_set` и `unordered_map` для хеширования).

Проще всего понять, как реализовать хешер, на примере:
```cpp
...

class VehiclePlateHasher {
public:
    size_t operator()(const VehiclePlate& plate) const {
        return static_cast<size_t>(plate.Hash());
    }
};

int main() {
    // явно указываем хешер шаблонным параметром
    unordered_set<VehiclePlate, VehiclePlateHasher> plate_base;

    plate_base.insert({'B', 'H', 840, 'E', 99});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'H', 'E', 968, 'C', 79});
    plate_base.insert({'T', 'A', 326, 'X', 83});
    plate_base.insert({'H', 'H', 831, 'P', 116});
    plate_base.insert({'A', 'P', 831, 'Y', 99});
    plate_base.insert({'P', 'M', 884, 'K', 23});
    plate_base.insert({'O', 'C', 34, 'P', 24});
    plate_base.insert({'M', 'Y', 831, 'M', 43});
    plate_base.insert({'B', 'P', 831, 'M', 79});
    plate_base.insert({'K', 'T', 478, 'P', 49});
    plate_base.insert({'X', 'P', 850, 'A', 50});

    for (auto& plate : plate_base) {
        cout << plate << endl;
    }
} 
```
В стандартной библиотеке уже определены хешеры для стандартных объектов: строк, чисел, указателей, `optional` и некоторых других. Эти хешеры реализованы в шаблонном классе `hash`.

Скомпилируем заново. Ошибка поменялась, теперь компилятору не нравится отсутствие операции сравнения: `error: no match for 'operator==' (operand types are 'const VehiclePlate' and 'const VehiclePlate')`. Вы уже разработали эту операцию в задании прошлого урока. В этом уроке реализуем его, используя операцию сравнения объектов `tuple` из стандартной библиотеки:

```cpp
#include <tuple>

...

class VehiclePlate {
private:
    auto AsTuple() const {
        return tie(letters_, digits_, region_);
    }

public:
    bool operator==(const VehiclePlate& other) const {
        return AsTuple() == other.AsTuple();
    }
...
}; 
```
Ура, программа скомпилировалась! Проверяем результат:
```
KT478P49
TA326X83
XP850A50
OK942K78
HE968C79
BH840E99
PM884K23
HH831P116
AP831Y99
MY831M43
BP831M79
OC034P24 
```
Результат правильный, но порядок вывода отличается от того, который был в нашем контейнере. Трудно понять почему. Проверим, подчиняется ли этот порядок какому-нибудь закону. Для этого переложим все номера в другой unordered_set и выведем его содержимое:
```cpp
...

int main() {
    unordered_set<VehiclePlate, VehiclePlateHasher> plate_base;

    ...

    cout << "Первый контейнер:"s << endl;
    for (auto& plate : plate_base) {
        cout << plate << endl;
    }

    cout << "Второй контейнер:"s << endl;
    unordered_set<VehiclePlate, VehiclePlateHasher> plate_base2(plate_base.begin(), plate_base.end());
    for (auto& plate : plate_base2) {
        cout << plate << endl;
    }
} 
```
Проверяем результат работы программы:

Первый контейнер:
```
KT478P49
TA326X83
XP850A50
OK942K78
HE968C79
BH840E99
PM884K23
HH831P116
AP831Y99
MY831M43
BP831M79
OC034P24
```
Второй контейнер:
```
BP831M79
MY831M43
AP831Y99
HH831P116
PM884K23
OC034P24
BH840E99
HE968C79
OK942K78
XP850A50
TA326X83
KT478P49 
```
Оба контейнера содержат одинаковые элементы, но выдают их в разном порядке, значит, порядок `unordered_set` действительно произвольный, он не определяется содержимым. Заметим, что элементы одной корзинки вывелись рядом, однако это тоже может зависеть от реализации `unordered_set`.

Аналогично устроен контейнер `unordered_map`, которым можно смело заменять map, если порядок элементов неважен. Как и в `unordered_set`, в этом контейнере требуется, чтобы ключи удовлетворяли двум условиям:

- имели хешер — класс, вычисляющий хеш-функцию. Тип хешера указывается третьим параметром шаблона `unordered_map` и вторым параметром шаблона `unordered_set`;

- имели возможность сравнения операцией `operator==`.

В случае `unordered_map` эти условия должны быть соблюдены для ключей, а значения могут быть произвольными.

Если не хотите определять `operator==`, можно поменять компаратор, задаваемый шаблонным параметром после хешера. Компаратор похож на хешер и тоже использует `operator()` для выполнения действия. В отличие от хешера, он не вычисляет характеристику одного объекта, а определяет понятие равенства.

Компаратор можно менять в обычных `map` и `set`. Для этих контейнеров равенства недостаточно, они должны определять, какой элемент больше, а какой меньше. Компаратор по умолчанию в них — `std::less`. Он использует `operator<`. Если хотите использовать свой класс в set или в качестве ключа в `map`, достаточно определить для элементов этого типа операцию сравнения `<`. В случае с `VehiclePlate` можно определить операцию сравнения, используя уже готовый метод `AsTuple`:
```cpp
class VehiclePlate {
private:
    auto AsTuple() const {
        return tie(letters_, digits_, region_);
    }

public:
    bool operator<(const VehiclePlate& other) const {
        return AsTuple() < other.AsTuple();
    }
...
}; 
```
Компаратор обязан удовлетворять некоторым свойствам, иначе контейнер будет работать некорректно, что может привести к неопределённому поведению. Например, проверка на равенство, которая используется в `unordered_set`, должна обладать симметричностью, то есть условия `a == b` и `b == a` для произвольных `a` и `b` должны быть истинными или ложными одновременно. Операция сравнения для map, напротив, симметричностью обладать не может, так как невозможно, чтобы оба элемента были меньше друг друга.