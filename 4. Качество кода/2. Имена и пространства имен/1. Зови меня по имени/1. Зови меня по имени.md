## Зови меня по имени

— Меня зовут Иван Андреевич Иванов.
— А меня Петр Васильевич Петров.

Такой диалог можно услышать где-нибудь в общественном месте. Имена мы используем, чтобы обратиться к человеку. Имена есть у всех, причём не только у людей: у домашних животных, у железнодорожных станций, у улиц и площадей, городов, компаний, брендов, сайтов и у многого другого. А в C++ имена есть... Впрочем, давайте вы сами скажете.

У каких сущностей кода в C++ есть имена? — У переменных, параметров функции, классов, структур, enum, union-деклараций, функций, псевдонимов типов, шаблонных параметров

Ещё имена есть у пространств имён, которые вы будете проходить в этой теме. И отдельно нужно сказать, у чего имён нет — у макросов, определённых через `#define` или параметры компиляции. Макросы обрабатываются во время препроцессирования, и компилятор получает код, где никаких макросов уже нет. Поэтому названия макросов не стоит считать именами. Эти идентификаторы живут по своим законам и не конкурируют с другими.

Имя — это идентификатор. Оно:

- состоит из латинских букв: больших и маленьких, цифр и знака подчёркивания;

- не может начинаться с цифры;

- может состоять даже из одного символа, например, знака подчёркивания: `_` — допустимое имя для сущности в C++.

Имена людей в реальной жизни могут совпадать. Имена разных сущностей кода тоже. Но они не должны совпадать с ключевыми словами, набор которых в C++ жёстко ограничен. Если в одной программе встретились одинаковые имена, они конкурируют между собой. Компилятор по строгим правилам будет определять, какую сущность имел в виду программист, когда написал имя, принадлежащее нескольким сущностям. Если выбрать не удалось, компилятор выдаст ошибку.

Некоторые сущности кода, которые обычно имеют имя, могут вдруг оказаться безымянными. Бывает, что хозяева не дали имя своей собачке, и её зовут просто Собака. Но в C++ назвать структуру словом `struct` нельзя, потому что это слово ключевое. Поэтому она будет безымянной. Всё, что вы можете сделать с такой структурой, — это сразу объявить переменную такого типа:
```cpp
int main() {
    // Объявляем переменную point. 
    // Её тип - безымянная структура с полями x и y типа int.
    struct {
        int x;
        int y;
    } point;
    point.x = 5;
    point.y = 10;
} 
```
Помимо структуры и класса, безымянным может быть параметр функции или шаблона, если они не используются, но должны быть указаны. Вспомните, например, самый плохой в мире хешер, который всегда выдаёт 42, вне зависимости от значения своего параметра:
```cpp
struct DummyHasher { 
    size_t operator() (const std::string& s) const {
        return 42;
    }
}; 
```
Параметр `s` не используется, о чём может предупредить компилятор:
```
In member function 'size_t DummyHasher::operator()(const string&) const':
prog.cc:6:43: warning: unused parameter 's' [-Wunused-parameter]
    6 |     size_t operator() (const std::string& s) const {
      |                        ~~~~~~~~~~~~~~~~~~~^ 
```
Объявив параметр операции `()` безымянным, можно устранить это предупреждение:
```cpp
struct DummyHasher { 
    size_t operator() (const std::string&) const {
        return 42;
    }
}; 
```

Другой способ указать, что параметр может быть неиспользуемым — пометить его атрибутом `[[maybe_unused]]:`
```cpp
struct DummyHasher { 
    size_t operator() ([[maybe_unused]] const std::string& s) const {
        // Теперь компилятор не будет предупреждать о том, что s не используется
        return 42;
    }
};
```
Разрешается не писать имена параметров и при объявлении функции. А вот переменные и сами функции безымянными быть не могут.

В некоторых случаях имя может быть составным — разбиваться на лексемы. Так бывает с операциями. Операция — это обычная функция, имя которой состоит из ключевого слова `operator` и знака операции, например, `operator+`. Ещё один пример составного имени — имя деструктора класса, которое содержит знак `~`.

Укажите имена в коде следующей программы. В случае сомнений можете свериться со списком ключевых слов на сайте cppreference.com.
```cpp
#include <iostream>

using namespace std;

template <int X>
struct S {
    int operator()() const {
        return X;
    }
};

int main() {
    S<42> get42, _;
    cout << "Hello world, "s << get42() << endl;
} 
```
```
std, X, S, operator(), main, get42, _, cout, endl
```
В этом уроке мы говорили о синтаксисе программы — структуре её кода, но не о семантике — том, что программа делает. Вы увидели, у каких сущностей кода программы есть имена, и какими эти имена бывают. В заданиях к этому уроку вам предстоит отвлечься от имён и поработать с уже готовым кодом, написанным другими программистами. Материалы этих заданий пригодятся в последующих уроках.

В заданиях говорится о компьютерных языках JSON и XML, которые задают форматы структурирования данных. Для вас подготовлены простые библиотеки для чтения этих форматов. Ваша задача — самостоятельно в них разобраться и научиться использовать.