## Защита от случайного изменения
Проектируя новый модуль, приложение, библиотеку или сервис, программист задумывается над удобством API. API — это список предоставляемых услуг, возможности чужого кода, описанные на формальном языке.

API — первое, что программист читает перед тем, как подключить к своему проекту новую библиотеку или интегрироваться с новым сервисом. Крупные компании разрабатывают документацию к своим API. Она делает их использование максимально удобным для разработчика. Примеры:

- Яндекс.Метрика;
- Матрица расстояний от Яндекс.Маршрутизации;
- Яндекс.Переводчик.

Вы тоже уже имели дело с API. Просто оформлено оно было немного не так, как в примерах выше. — Точно! Это же были заголовочные файлы.


Внимание к проектированию API — залог того, что коллеги вспомнят вас добрым словом. Эта тема поможет лучше понять инструмент проектирования, которым вы уже активно пользуетесь — константность объектов и методов.

В этом уроке вы на двух примерах разберётесь, как константность защищает объекты от случайных изменений. Первый пример будет очевидным, а второй — не совсем.

### Очевидный пример

Рассмотрим функцию, которая копирует из одного вектора в другой все элементы, кроме равных определённому значению. Она будет обёрткой над стандартным алгоритмом remove_copy. В коде также есть небольшой тест к функции:

```cpp
template <typename T>
void CopyIfNotEqual(vector<T>& src, vector<T>& dest, T value) {
    remove_copy(src.begin(), src.end(), back_inserter(src), value);
}

void TestCopyIfNotEqual() {
    vector<int> values = {1, 9, 2, 3, 5, 8, 4, 3, 5};
    vector<int> values_copy;
    CopyIfNotEqual(values, values_copy, 3);
    vector<int> expected = {1, 9, 2, 5, 8, 4, 5};
    assert(expected == values_copy);
}
```
Подробно о функции `back_inserter` — здесь.

Что случится с этим кодом при запуске? — Код запустится, но упадёт в процессе работы.


Код падает на assert. Результат не соответствует ожидаемому.
Невнимательный автор функции `CopyIfNotEqual` допустил ошибку и вызвал `back_inserter(src)` вместо `back_inserter(dest)`. Компилятор эту ошибку не заметил и прошёл мимо. Ошибка обнаружилась только при работе программы. Это очень неприятный вид ошибок, их нужно всеми силами избегать. Дело в том, что в большом проекте невозможно знать, когда функция будет вызвана. Может быть, до падения пройдёт несколько дней, а на коротких временных промежутках баг будет незаметен. Спасти от неприятности может ключевое слово из пяти букв.
Что это за слово? — `const`


При добавлении в сигнатуру функции слова `const` проблема будет обнаружена на этапе компиляции.

Добавим `const` к переменной `src` и попробуем скомпилировать:
```cpp
template <typename T>
void CopyIfNotEqual(const vector<T>& src, vector<T>& dest, T value) {
    remove_copy(src.begin(), src.end(), back_inserter(src), value); 
```
Компилятор сообщит об ошибке:

```
CopyNotEqual.cpp:9:16:   required from 'void CopyIfNotEqual(const std::vector<T>&, std::vector<T>&, T) [with T = int]'
CopyNotEqual.cpp:15:42:   required from here
C:/Program Files/mingw-w64/x86_64-8.1.0-posix-seh-rt_v6-rev0/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h:489:2: error: passing 'const std::vector<int>' as 'this' argument discards qualifiers [-fpermissive]
  container->push_back(__value);
  ^~~~~~~~~ 
```
При разработке API — в частности, сигнатур функций — константность, объявленная в нужных местах, спасает объекты от случайных изменений и помогает найти ошибки в коде ещё на этапе компиляции.

### Неочевидный пример

Вызывая функцию с одними и теми же входными данными, пользователь ожидает получить один и тот же результат. Если бы было иначе, весь мир программирования выглядел бы совершенно по-другому. Но как, никто не знает. Посмотрите на пример:
```cpp
int main() {
    int value = 4;
    auto increase = [value] (int x) {
        return value + x;
    };

    cout << increase(5) << endl;
    cout << increase(5) << endl;
    return 0;
} 
```
Ожидаемо, результат вывода:
```
9
9 
```
Захват переменной `value` происходит по значению. Это значит, что её значение скопируется в объект `increase`, и при каждом вызове в теле лямбда-функции будет использоваться копия переменной `value`.

Теперь предположим, что невнимательный программист написал лямбда-функцию так:
```cpp
int main() {
    int value = 4;
    auto increase = [value] (int x) {
        value += x;
        return value;
    };

    cout << increase(5) << endl;
    cout << increase(5) << endl;
    return 0;
} 
```
Этот код не скомпилируется. Далее вы узнаете почему, а пока предположим, что всё заработало. Что могло быть выведено на экран? — 9 14

В этом случае переменная `value`, скопированная внутрь объекта increase, при каждом вызове лямбды будет увеличиваться на `x`. И тогда, если вызвать эту функцию дважды с одним и тем же значением, результат будет разным:
```cpp
cout << increase(5) << endl; // значение value изменилось и стало равно 4 + 5 = 9
cout << increase(5) << endl; // value = 9, x = 5, результат 14
```
Чтобы такого не могло произойти, при проектировании лямбда-функции используют константность. Вспомним, что такое лямбда-функция. Это объект некого безымянного класса с подобным определением:

```cpp
class <unnamed> {
public:
    int value;
    int operator()(int x) const { return value + x; }
}; 
```

Так как метод `operator()` объявлен константным, при попытке изменения полей объекта внутри метода возникает ошибка компиляции. Программист просто не может написать функцию, изменяющую значение `value`.