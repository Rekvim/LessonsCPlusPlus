### Логическая константность и mutable

Вспомните задачу о подборе пароля, которую вы делали в уроке об экспоненциальной сложности алгоритмов. Теперь она немного переписана: есть отдельный класс, умеющий взламывать пароли, небольшой класс-помощник для проверки строчек на равенство и функция-обёртка, которая должна вернуть пароль к некоему сервису Шмандекс:

```cpp
#include <iostream>
#include <string>

using namespace std;

template <typename Checker>
class PasswordCracker {
public:
    PasswordCracker(Checker check)
        : check_(check)
    {
    }
    void SetCheck(Checker check) {
        check_ = check;
    }
    string BruteForce() const {
        return BruteForceInternal(""s, 0);
    }

private:
    string BruteForceInternal(const string& begin, int n) const {
        if (n == 5) {
            return check_(begin) ? begin : ""s;
        }

        for (char c = 'A'; c != 'Z' + 1; ++c) {
            string res = BruteForceInternal(begin + string({c}), n + 1);
            if (!res.empty()) {
                return res;
            }
        }

        return {};
    }
    Checker check_;
};

class PasswordChecker {
public:
    PasswordChecker(string match)
        : match_(match)
    {
    }
    bool operator()(const string& s) const {
        return s == match_;
    }
    void operator=(const PasswordChecker& other) {
        match_ = other.match_;
    }

private:
    string match_;
};

string GetShmandexPass(const PasswordCracker<PasswordChecker>& pass_cracker) {
    // если раскомментировать код ниже, программа не скомпилируется
    // PasswordChecker check("BUY"s);
    // pass_cracker.SetCheck(check);
    return pass_cracker.BruteForce();
}

int main() {
    PasswordChecker check("HELLO"s);
    PasswordCracker password_cracker(check);
    cout << GetShmandexPass(password_cracker) << endl;
}
```

У класса `PasswordCracker` есть метод, изменяющий значение поля объекта, — SetCheck. Внутри функции `GetShmandexPass` этого происходить не должно, поэтому объект pass_cracker передаётся по константной ссылке. Пока всё идёт отлично.

Но предположим, возникла необходимость улучшить класс `PasswordCracker`. Алгоритм подбора пароля занимает слишком много времени, и даже если функция проверки check одинаковая, каждый раз поиск будет запущен с нуля. Можно добавить в класс `PasswordCracker` простой механизм кеширования.

Пусть вместе с проверяющей функцией пользователь передаёт ключ-строку. Внутри класса `PasswordCracker` будет храниться словарь, содержащий связки «ключ — найденный пароль». Теперь поиск пароля, который уже найден, будет выполнен за логарифмическое время:
```cpp
template <typename Checker>
class PasswordCracker {
public:
    PasswordCracker(Checker check, string key)
        : check_(check)
        , curr_check_key_(move(key))
        , cached_passwords_()
    {
    }
    void SetCheck(Checker check, string key) {
        check_ = check;
        curr_check_key_ = move(key);
    }
    string BruteForce() const {
        // если готовый пароль есть в словаре, вернём его
        auto result = cached_passwords_.find(curr_check_key_);
        if (cached_passwords_.end() != result) {
            return result->second;
        }
        // если готового пароля нет, перейдём к подбору
        auto pass = BruteForceInternal(""s, 0);
        // не забудем добавить новый пароль в словарь готовых паролей
        cached_passwords_[move(curr_check_key_)] = pass;
        return pass;
    }
private:
    string BruteForceInternal(const string& begin, int n) const {
        if (n == 5) {
            return check_(begin) ? begin : ""s;
        }
        for (char c = 'A'; c != 'Z' + 1; ++c) {
            string res = BruteForceInternal(begin + string({c}), n + 1);
            if (!res.empty()) {
                return res;
            }
        }
        return {};
    }
    Checker check_;
    string curr_check_key_;
    //словарь для кеширования найденных паролей
    unordered_map<string, string> cached_passwords_;
}; 
```
Чтобы проверить, что кеширование работает, вызовем взлом одного и того же пароля дважды:
```cpp
int main() {
    PasswordChecker check("HELLO"s);
    PasswordCracker password_cracker(check, "HI");
    cout << GetShmandexPass(password_cracker) << endl;
    cout << GetShmandexPass(password_cracker) << endl;
} 
```
Что произойдёт при компиляции и запуске примера? — Программа не компилируется.

Программа не запустится, потому что не скомпилируется. Компиляция не проходит из-за ошибки:
```
cache.cpp: In member function 'std::__cxx11::string PasswordCracker<F>::BruteForce(std::__cxx11::string) const':
cache.cpp:22:26: error: no match for 'operator[]' (operand types are 'const std::map<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >' and 'std::__cxx11::string' {aka 'std::__cxx11::basic_string<char>'})
         cached_passwords_[key] = pass; 
```

Компилятор не нашёл `operator[]` для контейнера `const map`. Метод `operator[]` не работает с константными объектами, чтобы сохранить инвариант контейнера.

В этот момент программист сталкивается с дилеммой — убрать константность у метода `BruteForce` и у аргумента функции `GetShmandexPass` или нет. Как вы помните, если убрать константность у аргумента `GetShmandexPass`, внутри этой функции можно будет изменить проверяющую функцию. Этого хотелось избежать.

В целом общее правило заключается в том, что если для достижения цели нужно убрать константность, то стоит перед этим подумать много-много раз. Скорее всего, есть другой, более правильный путь. Константность защищает ваш код, делает его более логичным, передаёт поиск ошибок компилятору. Чтобы понять, как действовать в предложенном случае, нужно ввести понятие логической константности.

Логическая константность — это свойство объекта сохранять своё наблюдаемое состояние. Иначе говоря, те значения полей и свойства этих полей, которые важны для пользователя. У нашего класса есть два поля: функция проверки — её изначально передаёт пользователь, и словарь готовых паролей, к которому у пользователя нет доступа. Значение поля с функцией проверки крайне важно для пользователя, это часть наблюдаемого состояния, и логическая константность должна гарантировать её неизменность. Но словарь паролей — поле, нужное только для реализации класса, но не для использования извне. Логическая константность не пострадает, если словарь будет изменён. Кеш паролей — не часть наблюдаемого состояния объекта.

Для полей, подобных кеш-словарю, есть ключевое слово `mutable`. Оно позволяет изменять это поле у константных объектов:
```cpp
mutable unordered_map<string, string> cached_passwords_; 
```
Добавив это слово перед словарём, можно и константность оставить, и воспользоваться ускорением работы алгоритма через кеширование.