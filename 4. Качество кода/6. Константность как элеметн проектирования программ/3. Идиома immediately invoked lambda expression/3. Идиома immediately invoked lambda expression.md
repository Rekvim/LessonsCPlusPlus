### Идиома immediately invoked lambda expression

Иногда описанное в прошлом уроке решение, где вектор объявлялся константным, вызывает сложности. В этом уроке вы сначала с ними столкнётесь, а потом научитесь их мужественно преодолевать.

Допустим, сортированный вектор, с которым мы работали, должен ещё избавиться от дубликатов. Можно сделать это так:

vector<int> sorted_v = Sorted({1, 5, 9, 7, 15, 6});
auto it = unique(sorted_v.begin(), sorted_v.end());
sorted_v.erase(it, sorted_v.end()); 

Но что здесь не так? — Кажется, числа в векторе раньше были другие; Слово `begin` написано с опечаткой; Куда-то делась константность вектора.

Можно сделать иначе — через функцию `Unique`, подобную функции `Sorted` из прошлого урока:

```cpp
vector<int> Unique(vector<int> nums) {
    auto it = unique(nums.begin(), nums.end());
    nums.erase(it, nums.end());
    return nums;
}
```

Тогда инициализация вектора начнёт выглядеть немного странно:

```cpp
const vector<int> sorted_v = Unique(Sorted({1, 5, 9, 7, 15, 6, 1, 5, 9}));
```

Этот код будет работать. Но функция `Unique` — не всегда хорошая идея. Эта функция может быть очень специфичной и требоваться только в одном месте кода. Или её действия хотелось бы видеть в месте использования, а не искать, где она определена. Иногда просто не хочется придумывать название для единожды использованной функции и помещать её в глобальное пространство имён. Всё это нужно учесть.

Задачу, с которой вы столкнулись, можно сформулировать так: найти элегантный способ сохранить константность и при этом позволить нетривиальную инициализацию объекта рядом с его объявлением.

Такой способ в С++ реализуется через идиому immediately invoked lambda expression, IILE. Её суть в том, что лямбда-функция вызывается ровно в том же месте, где создаётся.

Решим задачу, используя идиому IILE:
```cpp
const vector<int> sorted_v = [] {
    vector<int> nums = Sorted({1, 5, 9, 7, 15, 6, 1, 5, 9});
    auto it = unique(nums.begin(), nums.end());
    nums.erase(it, nums.end());
    return nums;
}();
```

После тела лямбды, за закрывающей фигурной скобкой, стоят круглые скобки. Так программист указывает, что лямбда должна быть создана, а потом сразу вызвана.

Другие примеры использования идиомы IILE — вычисление времени конструирования объекта или взятие мьютекса перед конструированием. Причём так, что никакого кода в сам конструктор добавлено не будет. Выглядит это так:

```cpp
const vector<int> sorted_v = [] {
    LOG_DURATION("Sorted vector initialization"s);
    return Sorted({1, 5, 9, 7, 15, 6, 1, 5, 9});
}();
```

Здесь лямбда-функция используется как обёртка над функцией `Sorted`. Такой подход удобен, когда у программиста нет доступа к коду, конструирующему объект, или если нужно измерить время только для данного конкретного объекта, а не для всех случаев вызова функции `Sorted`.

Используя идиому IILE, нужно не забывать об удобстве для читателя кода. Ведь код пишется однажды, а читается много раз. Если заменить явное указание типа объекта на `auto`, код может быть понят неправильно:

```cpp
const auto sorted_v = [] {
    ......
}();
```

Увидев первую строчку, читатель решит, что `sorted_v` — это объект лямбда-функции. И мало кто обратит внимание на круглые скобки в конце. Дальше читатель запутается, ему придётся возвращаться и разбираться, что скрыто за `auto`. Чтобы показать явно, что вам нужна не лямбда-функция, а результат её вызова, можно воспользоваться функцией `std::invoke`. Для этого не забудьте подключить файл <functional>:

```cpp
const auto sorted_v = invoke([] {
    ......
});
```
Не заметить вызов функции куда сложнее, чем круглые скобки в конце.