## Неожиданные последствия неопределённого поведения
В предыдущем уроке вы познакомились с положительными аспектами неопределённого поведения и с тем, как оно помогает компилятору генерировать оптимальный код. В этом уроке вы узнаете, как неопределённое поведение осложняет жизнь программистам.

Рассмотрим программу, которая определяет, считается ли небесное тело планетой:
```cpp
#include <iostream>
#include <string_view>

using namespace std;

const int NUM_PLANETS = 9;
const string_view PLANETS[] = {
    "Mercury"sv, "Venus"sv, "Earth"sv,
    "Mars"sv, "Jupiter"sv, "Saturn"sv,
    "Uranus"sv, "Neptune"sv, "Pluto"sv,
};

bool IsPlanet(string_view name) {
    for (int i = 0; i < NUM_PLANETS; ++i) {
        if (PLANETS[i] == name) {
            return true;
        }
    }
    return false;
}

void Test(string_view name) {
    cout << name << " is " << (IsPlanet(name) ? ""sv : "NOT "sv) << "a planet"sv << endl;
}

int main() {
    Test("Earth"sv);
    Test("Jupiter"sv);
    Test("Pluto"sv);
    Test("Moon"sv);
} 
```
Запустим программу и увидим, что Земля, Юпитер и Плутон — планеты, а Луна — нет:
```
Earth is a planet
Jupiter is a planet
Pluto is a planet
Moon is NOT a planet 
```
Показав программу своим друзьям, узнаём, что Плутон с 2006 исключён из списка планет и теперь считается карликовой планетой. Недолго думая, исправим ошибку:
```cpp
const string_view PLANETS[] = {
    "Mercury"sv, "Venus"sv, "Earth"sv,
    "Mars"sv, "Jupiter"sv, "Saturn"sv,
    "Uranus"sv, "Neptune"sv,
}; 
```
Запустим программу и убедимся, что программа по-прежнему работает:
```
Earth is a planet
Jupiter is a planet
Pluto is NOT a planet
Moon is NOT a planet 
```
Довольные собой, опубликуем код программы на GitHub, чтобы поделиться ей с сообществом. Вскоре один из пользователей сообщает, что программа работает неверно. Более того, она считает планетой не только Плутон, но и Луну:
```
Earth is a planet
Jupiter is a planet
Pluto is a planet
Moon is a planet 
```
Несколько раз проверяем на своём компьютере — программа работает как часы. Тратим много времени на переписку с пользователем и выясняем, что проблема проявляется при сборке компилятором gcc 10.1 с ключом оптимизации `-O2` и не проявляется при сборке компиляторами Visual Studio 2019 и Clang 10.0.

Как следует поступить в этой ситуации? — Внимательно посмотреть на код программы. Возможно, причина не в компиляторе.

Проблема в том, что в программе появилось неопределённое поведение. Взглянем ещё раз на код, где внесены изменения:
```cpp
const int NUM_PLANETS = 9;
const string_view PLANETS[] = {
    "Mercury"sv, "Venus"sv, "Earth"sv,
    "Mars"sv, "Jupiter"sv, "Saturn"sv,
    "Uranus"sv, "Neptune"sv,
};

bool IsPlanet(string_view name) {
    for (int i = 0; i < NUM_PLANETS; ++i) {
        if (PLANETS[i] == name) {
            return true;
        }
    }
    return false;
} 
```
Из массива планет убран Плутон, однако константа `NUM_PLANETS` по-прежнему равна девяти.

Компилятор gcc анализирует поток выполнения программы и видит, что переменная `i` принимает значения от 0 до 8 включительно. Эта же переменная использована, чтобы обратиться к элементам массива `PLANETS`. В нём 8 элементов. 

Компилятор видит, что функция IsPlanet возвращает true при значениях i, находящихся в диапазоне от 0 до 7. Когда значение i равно 8, возникает неопределённое поведение. В итоге функция IsPlanet либо возвращает true, либо в ней происходит неопределённое поведение. 

При оптимизации компилятор может исключить второй вариант развития событий и генерирует код, всегда возвращающий true. Проверьте на сервисе Compiler Explorer по ссылке: https://godbolt.org/z/5qxTbe 
```
IsPlanet(std::basic_string_view<char, std::char_traits<char> >):
        movl    $1, %eax // В регистре eax — результат функции 1, соответствующий значению true
        ret 
```
Компилятор в ходе оптимизации функции исключил цикл поиска названия планеты и оставил возврат значения `true`.

Можно было бы ожидать, что программа, дойдя до элемента с индексом 8, попытается обратиться к элементу за пределами массива. Мусор в этой области памяти программа интерпретирует как объект `string_view`. Сравнив его с параметром `name`, программа, вероятно, вернёт `false`. Если судить по коду, сгенерированному компилятором clang, так и происходит. Создаётся иллюзия, что программа работает правильно.

Действительно, за неопределённым поведением может скрываться всё что угодно. Даже такие, казалось бы, неочевидные вещи, как выкидывание всего кода функции.