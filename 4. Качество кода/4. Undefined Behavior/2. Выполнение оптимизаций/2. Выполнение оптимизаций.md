## Выполнение оптимизаций
В предыдущем уроке вы узнали, как неопределённое поведение позволяет убирать накладные расходы, и убедились, что без него это было бы невозможно. Теперь вы увидите, как неопределённое поведение помогает компилятору делать некоторые оптимизации.

Рассмотрим операцию сложения двух целых чисел. В C++ при операциях над типами int и int32_t переполнение приводит к неопределённому поведению. То есть если результат выйдет за пределы диапазона [INT_MIN, INT_MAX], поведение программы станет неопределённым.

При сложении целых чисел без знака, например, `unsigned int` или `uint32_t`, переполнение строго определено: результат сложения берётся по модулю $2^N$, где $N$ — количество битов в данном типе. То есть если прибавить к значению `UINT_MAX` единицу, гарантируется, что результат будет равен нулю. Такое поведение напоминает циферблат электронных часов, у которых следом за `23:59:59` наступает `00:00:00`.

Теперь вспомним, что при возникновении неопределённого поведения программа способна делать всё что угодно. Компилятор может использовать свободу, чтобы сгенерировать оптимальный код.

Компилятор предполагает, что программист написал код без неопределённого поведения. Примерно как при использовании оператора `[]` для доступа к элементу `vector`: компилятор верит, что индекс элемента имеет допустимое значение.

Какое поведение этой программы будет допустимым?
```
#include <climits>
#include <iomanip>
#include <iostream>

bool TestSigned(int n) {
    return n < n + 1;
}

bool TestUnsigned(unsigned int n) {
    return n < n + 1;
}

using namespace std;
int main() {
    cout << boolalpha;
    cout << TestSigned(INT_MAX) << endl;
    cout << TestUnsigned(UINT_MAX) << endl;
} 
```

Правильный ответ
Программа выведет текст:

    false
    false
     

Правильный ответ
Программа выведет текст:

    false
    true
     

Правильный ответ
Программа выведет текст:

    true
    false
     

Правильный ответ
Программа выведет текст:

    true
    true

Правильный ответ
Программа не выведет ничего.

Правильный ответ
Программа выведет текст:

    true
     

Правильный ответ
Программа выведет текст:

    false
     

Правильный ответ
Программа упадёт.


В программе есть неопределённое поведение при вычислении `INT_MAX + 1`внутри функции `TestSigned`. Поэтому ожидать можно всего что угодно

В зависимости от вашего компилятора и опций компиляции результаты работы программы могут отличаться. Программа, собранная компилятором Microsoft Visual C++ 2019, выводит:
```
false
false 
```
Та же программа, собранная компилятором gcc 10.1:
true
false 
Эти различия объяснимы — при переполнении целого числа со знаком неопределённое поведение разрешает программе вести себя как угодно.
Взглянем на ассемблерный код функций `TestSigned` и `TestUnsigned`, сгенерированный компилятором gcc. Для этого используем Compiler Explorer:
```
TestSigned(int):
        movl    $1, %eax // Записываем в регистр eax результат, равный 1 (значение true)
        ret

TestUnsigned(unsigned int):
        // проверяем, равен ли аргумент функции, переданный в регистре edi,
        // значению UINT_MAX (в двоичном представлении совпадает со значением -1)
        cmpl    $-1, %edi
        // Если да, записываем единицы во все разряды регистра al, иначе нули
        setne   %al
        // выходим из функции
        ret 
```
Разберёмся, почему компилятор сгенерировал такой разный код для функций с одинаковым телом:
```cpp
return n < n + 1;
```
Когда n имеет тип int, компилятор может размышлять так:

- Если значение n меньше максимально возможного целого числа, сумма n+1 будет помещаться в диапазон типа int. В таком случае n всегда будет меньше, чем n+1. Поэтому функция должна вернуть true.

- Если значение n равно максимально возможному целому числу, сумма n+1 приведёт к переполнению знакового целого, а это неопределённое поведение. В таком случае программа может сделать всё что угодно. Например, отформатировать диск. Или вернуть true.

В результате компилятор gcc создаёт функцию, которая при любых входных значениях возвращает значение true.

К такому же результату компилятор может прийти, рассчитывая, что программист пишет код без неопределённого поведения. Ведь в такой программе ситуация, где параметр n равен максимально возможному целому числу, невозможна. Остаётся только вариант, когда функция всегда возвращает true.

В случае беззнакового числа n компилятор также рассматривает две ситуации:

- Когда `n` меньше наибольшего беззнакового целого числа, сумма `n+1` будет не больше максимального беззнакового числа. Тогда выражение `n < n + 1` будет равно `true`.

- Когда `n` равно наибольшему беззнаковому числу, сумма `n+1` будет определённой и равна нулю. В таком случае выражение `n < n + 1` будет иметь значение `false`.

Поэтому функция `TestUnsigned` получилась  большего размера и, как показывают замеры времени, чуть дольше работает. Чтобы убедиться, используйте онлайн-сервис Quick Bench. Он позволяет измерить относительное время работы кода на C++. Ссылка на сравнение времени выполнения функций `TestSigned` и `TestUnsigned`: https://quick-bench.com/q/FhuBkdyrQw4QH2y0H1O9DzDb_EI.

Другие компиляторы могут придерживаться иных стратегий оптимизаций. Например, Visual C++ 2019 генерирует примерно одинаковый код для обеих функций:
```
n$ = 8
bool TestSigned(int) PROC                         ; TestSigned, COMDAT
        lea     eax, DWORD PTR [rcx+1] // помещаем в eax значение n+1
        cmp     ecx, eax // сравниваем n и n+1
        setl    al // если n<n+1, в регистре AL будет значение 255
        ret     0
bool TestSigned(int) ENDP                         ; TestSigned

n$ = 8
bool TestUnsigned(unsigned int) PROC                   ; TestUnsigned, COMDAT
        lea     eax, DWORD PTR [rcx+1] // Помещаем в eax значение n+1
        cmp     ecx, eax // Сравниваем n и n+1
        setb    al  // если n<n+1, в регистре AL будет значение 255
        ret     0
bool TestUnsigned(unsigned int) ENDP                   ; TestUnsigned 
```
Код, сгенерированный Visual C++, сложил `INT_MAX` (значение `0x7FFFFFFF`) c единицей и  получил число `0x80000000`, равное значению `INT_MIN`. В таком случае выражение  `n<n+1` принимает значение `false`.

Теперь разница в работе функции `TestSigned`, скомпилированной разными компиляторами, становится объяснимой. При параметре `n`, равном `INT_MAX`, проявляется неопределённое поведение, и программа ведёт себя произвольно. Компилятор g++ максимально эксплуатирует неопределённое поведение, генерируя код, который всегда возвращает `true`.

При этом оба компилятора ведут себя вполне законно. Область определения функции `TestSigned`, то есть значения аргумента, где значение функции определено, — полуинтервал `[INT_MIN, INT_MAX)`. Значение `INT_MAX` находится вне области определения, и на нём функция имеет право вести себя как угодно.

Даже если программа собирается компилятором одного производителя, неопределённого поведения следует избегать. Ведь когда обновите компилятор или измените параметры компиляции, неопределённое поведение может проявить себя самым неожиданным образом.

В этом уроке вы узнали, как неопределённое поведение помогает компилятору генерировать оптимальный код. Но задача программиста — не допускать неопределённого поведения.