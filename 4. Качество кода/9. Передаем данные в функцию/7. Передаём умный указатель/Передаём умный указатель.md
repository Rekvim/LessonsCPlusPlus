## C++20 Ranges

C++ постоянно растёт. В него добавляются новые возможности. Например, стандарт 2011 года дал нам `auto`, move-семантику, цикл `for` по диапазону, лямбда-функции. C++20 также привнёс массу возможностей. Среди них есть библиотека `ranges`, которая позволяет передавать один объект вместо пары итераторов. Но это лишь один из вариантов её использования.

Для работы с `ranges` понадобится соответствующий компилятор. Подойдёт GCC версии не ниже 10. Скачать GCC для Windows можно с сайта http://winlibs.com. Протестировать `ranges` вы можете и онлайн на сайте Coliru.

#### Простой пример
Рассмотрим программу, сортирующую и выводящую в `cout` диапазон чисел:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <ranges>
#include <string_view>

namespace rng = std::ranges;
using namespace std;

template <rng::input_range Range>
void Print(const Range& range) {
    for (const auto& x : range) {
        cout << x << " "sv;
    }
    cout << endl;
}

int main() {
    vector v = { 4, 1, 7, 2, 3, 8 };
    rng::sort(v);
    Print(v);

    return 0;
} 
```

Собирать его GCC нужно с ключом `-std=c++20`. Программа выводит такой текст:
```
1 2 3 4 7 8
```
Разберём пример подробно.
##### Подключение файлов и манипуляции с пространствами имён
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <ranges>
#include <string_view>

namespace rng = std::ranges;
using namespace std; 
```
Среди включаемых файлов есть заголовок нужной библиотеки — `<ranges>`. Её имена находятся в пространстве `std::ranges.` Чтобы не писать эту квалификацию каждый раз, мы создали для него псевдоним `rng`.

##### Сортировка

```cpp
std::vector v = {4, 1, 7, 2, 3, 8};
rng::sort(v);
```
Функция sort из `std::ranges` в отличие от `std::sort` принимает не пару итераторов, а один диапазон. Любой контейнер неявно конвертируется к диапазону. Но это не единственный способ создать диапазон. О некоторых других способах — ниже.

##### Функция Print
```cpp
template <rng::input_range Range>
void Print(const Range& range) {
    for (const auto& x : range) {
        cout << x << " "sv;
    }
    cout << endl;
}

// ...

Print(v);
```
Какой необычный синтаксис, который не вписывается в стандарт 17 года, вы видите в этом коде? — «Тип» шаблонного параметра `rng::input_range`.


Шаблонный параметр имеет необычный тип — `rng::input_range`. Это не соответствует C++17, где было только два варианта:

- для типового параметра — слово `class` или `typename`;

- для нетипового параметра — целочисленный тип, enum-тип, указатель или `bool`.

Теперь типовые параметры могут быть концептом — набором требований к типу. Это новая сущность кода, которая имеет имя. Она введена стандартом C++20. В данном случае мы ссылаемся на `std::ranges::input_range` — концепт, описывающий требования к диапазону.

Этот код можно упростить и убрать слово `template` благодаря ещё одному нововведению:

```cpp
void Print(const rng::input_range auto& range) {
    for (const auto& x : range) {
        cout << x << " "sv;
    }
    cout << endl;
}
```
Здесь в качестве типа параметра `range` указано `auto`, ограниченное концептом `rng::input_range`. Это намекает на неявную шаблонность.

Использование концептов позволяет делать две вещи:
1. Контролировать ошибки и получать внятные сообщения об ошибках.
2. Контролировать перегрузку функций — можно определить несколько одноимённых функций. Будет выбрана та, параметры которой соответствуют всем ограничениям.

Добавим в `main` строку `Print(2)` и получим ошибку, начинающуюся так:
```
ranges1.cpp: In function ‘int main()’:
ranges1.cpp:20:10: error: use of function ‘void Print(const Range&) [with Range = int]’ with unsatisfied constraints
   20 |   Print(2); 
```
Формулировка понятно сообщает, что произошло: use of function with unsatisfied constraints. Если пройти по тексту ошибки далее, можно увидеть подробности:
```
.../range_access.h:862:13:   required for the satisfaction of 'range<_Tp>' [with _Tp = int]
.../range_access.h:909:13:   required for the satisfaction of 'input_range<Range>' [with Range = int]
.../range_access.h:862:21:   in requirements with '_Tp& __t' [with _Tp = int]
.../range_access.h:864:15: note: the required expression 'std::ranges::__cust::begin(__t)' is invalid
864 |  ranges::begin(__t);
      |  ~~~~~~~~~~~~~^~~~~
.../range_access.h:865:13: note: the required expression 'std::ranges::__cust::end(__t)' is invalid
  865 |  ranges::end(__t);
      |  ~~~~~~~~~~~^~~~~
```

Из них понятно, что препятствием стала невозможность применить `begin` и `end` к указанному типу.

Можно сделать вызов `Print` более универсальным, если добавить вторую версию, работающую для остальных типов:
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <ranges>
#include <string_view>

namespace rng = std::ranges;
using namespace std;

template <rng::input_range Range>
void Print(const Range& range) {
    for (const auto& x : range) {
        cout << x << " "sv;
    }
    cout << endl;
}

template <typename T>
void Print(const T& x) {
    cout << x << endl;
}

int main() {
    vector v = { 4, 1, 7, 2, 3, 8 };
    rng::sort(v);
    Print(v);
    Print(123);
    Print("abc"sv);

    return 0;
} 
```
Программа выведет такой текст:
```
1 2 3 4 7 8
123
a b c
```
Почему символы `abc` вывелись через пробелы? — Оказалось, что `string_view` удовлетворяет концепту `input_range`.

#### Параметры-проекции
Кратко рассмотрим другие возможности `ranges`. Начнём с дополнительных параметров, имеющихся в некоторых алгоритмах `std::ranges`. Они называются параметрами-проекциями и позволяют передать функцию, которая будет применяться ко всем элементам перед основными действиями алгоритма. Особенно это полезно для алгоритмов вроде `std::sort` и `std::lower_bound`, принимающих компараторы. Если элементы нужно отсортировать, принимая во внимание не их, а значения некоторой функции, достаточно передать параметр-проекцию с этой функцией. Необходимость в громоздком компараторе отпадает.

Рассмотрим пример использования алгоритма `sort` с параметром-проекцией:
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

namespace rng = std::ranges;
using namespace std;

struct Lecture {
    int course;
    int local_idx;
    int complexity;
};

vector<Lecture> ReadLectures();

int main() {
    vector<Lecture> lectures = ReadLectures();

    // как раньше
    sort(lectures.begin(), lectures.end(), [](const Lecture& lhs, const Lecture& rhs) {
        return lhs.complexity < rhs.complexity;
    });

    // как теперь
    rng::sort(lectures, less<>{}, [](const Lecture& x) {
        return x.complexity;
    });

    return 0;
} 
```
При вызове `std::ranges::sort` мы указали три параметра: сам диапазон, компаратор `std::less` и параметр-проекцию — лямбда-функцию, которая применяется перед сравнением компаратора. Такая сортировка отсортирует `lectures` по сложности. Можно сортировать сразу по двум полям, используя `tuple`:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

namespace rng = std::ranges;
using namespace std;

struct Lecture {
    int course;
    int local_idx;
    int complexity;
};

vector<Lecture> ReadLectures();

int main() {
    vector<Lecture> lectures = ReadLectures();

    rng::sort(lectures, less<>{},
        [](const Lecture& x) { 
            return std::tuple{x.course, x.local_idx}; 
        });

    return 0;
}
```

#### Представления и адаптеры
Создать диапазон из контейнера — только одна из массы возможностей. Помимо неё в библиотеке `ranges` предусмотрены представления и адаптеры, которые позволяют генерировать данные, не храня их, либо преобразовывать уже существующий диапазон. Они располагаются в пространстве имён `std::ranges::views`. Рассмотрим некоторые из них.

##### view::iota
Этот вид позволяет заменить старый добрый `for`, сделав его синтаксис более внятным:
```cpp
#include <iostream>
#include <ranges>
#include <string_view>
#include <vector>

namespace rng = std::ranges;
namespace view = rng::views;

using namespace std;

int main() {
    const int days = 3;   // количество дней с играми
    const int games = 2;  // количество игр с питомцем в день

    // раньше:
    for (int i = 0; i < days; i++) {
        cout << "День "sv << i << endl;
        for (int j = 0; j < games; j++) {
            cout << "  Игра "sv << j << endl;
        }
    }

    // сейчас:
    for (int i : view::iota(0, days)) {
        cout << "День "sv << i << endl;
        for (int j : view::iota(0, games)) {
            cout << "  Игра "sv << j << endl;
        }
    }
}
```
При написании цикла в старом стиле переменную нужно повторить три раза. Тут возникает огромный простор для ошибок. Почти каждый(ая) программист(ка) на C++ наверняка писал(а) сам(а) или находил(а) в чужом коде нечто подобное:
```cpp
// раньше:
for (int i = 0; i < days; i++) {
    cout << "День "sv << i << endl;
    for (int j = 0; j < games; i++) {
        cout << "  Игра "sv << j << endl;
    }
}
```
В чём ошибка? — В итерационном выражении второго цикла.

Использование `iota` страхует от подобной ошибки.
##### view::take

Вид `take` — это пример адаптера: он преобразует уже существующий диапазон, оставляя из него только начало. Так можно перебрать первые пять элементов вектора:
```cpp
vector<int> numbers = ReadNumbers();

for (int& x : numbers | view::take(5)) {
    ++x;
}
```
Использование комбинатора `|` позволяет объединять несколько адаптеров, применяя их последовательно. Например, чтобы вывести элементы с 10-го по 17-й, можно комбинировать `take` с адаптером `drop`, который пропускает указанное число элементов входного диапазона:
```cpp
for (int x : numbers | view::drop(10) | view::take(8)) {
    cout << x << ' ';
}
```
Вот другие полезные адаптеры:
- `reverse` — выдаёт диапазон в обратном порядке;
- `transform` — применяет указанную функцию к каждому элементу;
- `filter` — оставляет только элементы, удовлетворяющие предикату.
- 
Полный список всех адаптеров можно найти в [документации](https://en.cppreference.com/w/cpp/header/ranges.html).
Это был лишь поверхностный взгляд на нововведения C++20. Ваш компилятор может не поддерживать эти возможности или поддерживать лишь ограниченно, поэтому задания в уроке не будет.