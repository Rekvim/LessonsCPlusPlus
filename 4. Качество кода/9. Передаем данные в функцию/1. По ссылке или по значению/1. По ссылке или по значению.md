## По ссылке или по значению

Когда вы хотите попросить кого-нибудь выполнить какое-либо действие, иногда достаточно сообщить, какое действие вам нужно. Представьте застолье. Вы сидите среди других гостей и вдруг обнаруживаете, что у вас нет вилки. В этой ситуации достаточно сказать другому гостю, которому повезло больше: «Передай, пожалуйста, вилку».

Но некоторые действия требуют дополнительной информации. Например: «Положи мне, пожалуйста, салат с крабами, две ложки». Здесь нужно сообщить параметры действия — какой именно салат и какое именно количество.

Так же и в программировании. Бывает, что функция или метод не принимает параметры. Например, функция, возвращающая самое большое число типа `int`, — `std::numeric_limits<int>::max`. Значение, которое она вернёт, определяется на этапе компиляции и ни от чего не зависит. Ещё один пример функции, не принимающей аргументы, — `std::chrono::system_clock::now`. Она возвращает текущее время. Отличие этой функции от предыдущей в том, что её значение меняется. Но большинству функций и методов всё-таки нужны аргументы, параметризующие действие или вычисление, которое они совершают. В этой теме разберёмся, как правильно передавать аргументы в функцию и какие тут могут быть варианты.

Чтобы определиться с типом аргумента, прежде всего нужно понять, принимает ли функция владение объектом. Сохраняет ли она его куда-либо для последующего использования после завершения своей работы или просто учитывает информацию объекта, чтобы параметризовать совершаемое действие. От этого будет зависеть, какая сигнатура правильная.

### По ссылке или по значению

Основная дилемма, возникающая при написании функции, — принимать параметр по константной ссылке или по значению. Для ответа на этот вопрос можно сформулировать золотое правило:

    Передача по ссылке должна быть чем-то обоснована.

При прочих равных выбирайте передачу по значению. Почему — узнаете позже.

Самое частое и допустимое обоснование передачи ссылки — трудность копирования объекта. Разумеется, оно имеет смысл, когда копировать объект тяжелее, чем копировать ссылку. Копирование объекта — трудная операция, если его размер на стеке превосходит 16 байт либо если объект владеет динамической памятью, которая будет перевыделена при копировании. Когда размер объекта не превышает 16 байт, передавать по ссылке нет смысла. Маленький объект, который легче скопировать, чем передать по ссылке, будем называть лёгким.
```cpp
// Параметр n - лёгкий объект, передавать его через const int& нет смысла
int ComputeFactorial(int n) {
    return n <= 0 ? 1 : n * ComputeFactorial(n - 1);
}

struct Elephant {
    array<ElephantLeg, 4> heavy_leg;
    ElephantTrunk heavy_trunk;
    ElephantBody heavy_body;
};

// Передавать elephant по значению не нужно - это тяжёлый объект, который
// имеет большое значение sizeof
uint64_t ComputeWeight(const Elephant& elephant); 
```
Передача по ссылке желательна, когда копирование объекта имеет побочный эффект. Например, класс односвязного списка вполне может уместиться в 16 байт — указатель на первый элемент и размер. Но копирование приведёт к сложной процедуре обхода списка и выделению динамической памяти:
```cpp
// Копирование вектора - трудная операция, 
// она имеет побочный эффект - выделение памяти.
// Нужно принять параметр по константной ссылке
std::vector<int> FindPrimeNumbers(const std::vector<int>& source);
```
Если сейчас класс лёгкий, но в будущем планируется расширение, лучше принимать по ссылке. Приём по значению из-за лёгкости оправдан, только когда объект по смыслу лёгкий, например, `string_view`:
```cpp
struct User {
    int user_id_;
    int score_;
};

// Принимаем User по ссылке, несмотря на то, что он хранит только
// два значения int. В дальшейшем, скорее всего, расширим его.
void PrintUserInfo(const User& user);
```
Если же функция принимает владение объектом, использовать ссылку не нужно — пусть копирование произойдёт при вызове функции:
```cpp
class SearchServer {
public:
    // принимаем вектор по значению - функция принимает владение объектом
    void SetStopWords(std::vector<std::string> stop_words) {
        stop_words_ = std::move(stop_words);
    }

private:
    std::vector<std::string> stop_words_;
};
```
Это не относится к случаю, когда объект трудно перемещать, как например `std::array`. Как вы знаете из темы о move-семантике, передача по значению позволяет получить дополнительную выгоду — временный или ненужный объект будет перемещаться вместо копирования. Мы подробно разберём передачу владения в уроке о Forwarding reference.

Даже если функция не принимает владение, может случиться, что ей всё равно нужна копия объекта. Тогда передавать по значению тоже выгодно:
```cpp
// Функция внутри сортирует список, не меняя его. 
// При передаче по ссылке могут происходить лишние копирования
int GetNthNumber(const vector<int>& input_vector, size_t n) {
    auto input_vector_copy = input_vector;
    sort(input_vector_copy.begin(), input_vector_copy.end());
    return input_vector_copy[n];
}

// Лучше принимать по значению.
// При передаче в такую функцию временного объекта копирования не возникает
int GetNthNumber(vector<int> input_vector, size_t n) {
    sort(input_vector.begin(), input_vector.end());
    return input_vector[n];
}
```
Бывает, что назначение функции — поменять объект, переданный в аргументе, не принимая владение. Это, пожалуй, единственный случай, когда всё однозначно — принимать нужно по неконстантной ссылке.

Мы закончили разбор случаев. Казалось бы, вопрос о способе передачи объекта очень простой, но ответ выглядит сложным. Со временем ваша интуиция будет сама подсказывать правильный способ передачи. Выберите верный вариант на основе рекомендаций этого урока.

Лёгкий объект — по значению
Принимается владение и лёгкое перемещение — по значению
Нужна копия и лёгкое перемещение — по значению
Тяжёлый объект — по константной ссылке
Есть побочный эффект копирования, в том числе выделение динамической памяти — по константной ссылке
Объект лёгкий, но будет расширяться — по константной ссылке
Функция поменяет объект — по неконстантной ссылке

Остался незатронутым один случай — объект неизвестного типа или трудноперемещаемый. При этом функции нужна копия или она принимает владение. Этот случай разберём в уроке «Совершенный способ — Forwarding reference».

Выберите правильный тип аргумента и обоснование. Если подходит несколько обоснований, выбирайте первое из них.
Какой тип должен быть на месте `<?>`?
```cpp
int Square(<?> x) {
    return x * x;
}
```   

Правильный ответ
int — объект лёгкий

int — функция принимает владение

int — функции нужна копия

const int& — копирование имеет побочные эффекты

const int& — объект тяжёлый


Выберите правильный тип аргумента и обоснование. Если подходит несколько обоснований, выбирайте первое из них.
Какой тип должен быть на месте `<?>`?
```cpp
int CountEvenNumbers(<?> x);
```

vector<int> — объект лёгкий

vector<int> — функция принимает владение

vector<int> — функции нужна копия

Правильный ответ
const vector<int>& — копирование имеет побочные эффекты

const vector<int>& — объект тяжёлый

Выберите правильный тип аргумента и обоснование. Если подходит несколько обоснований, выбирайте первое из них.
Какой тип должен быть на месте `<?>`?
```cpp
Date ParseDate(
    const string& text,
    <?> settings_x = nullptr
);
``` 

const ParsingSettings* — объект лёгкий

const ParsingSettings* — функция принимает владение

const ParsingSettings* — функции нужна копия

Правильный ответ
const ParsingSettings* const& — копирование имеет побочные эффекты

const ParsingSettings* const& — объект тяжёлый

Выберите правильный тип аргумента и обоснование. Если подходит несколько обоснований, выбирайте первое из них.
Какой тип должен быть на месте `<?>`?
```cpp
class ImageProcessor {
public:
    void SetProcessorSettings(<?> processor_settings);

private:
    ProcessorSettings processor_settings_;
};
```

Правильный ответ
ProcessorSettings — объект лёгкий

ProcessorSettings — функция принимает владение

ProcessorSettings — функции нужна копия

const ProcessorSettings& — копирование имеет побочные эффекты

const ProcessorSettings& — объект тяжёлый
Как вам задача?


Выберите правильный тип аргумента и обоснование. Если подходит несколько обоснований, выбирайте первое из них.
Какой тип должен быть на месте `<?>`?
```cpp
int CountLetters(<?> str, char letter);
```


Правильный ответ
string_view — объект лёгкий

string_view — функция принимает владение

string_view — функции нужна копия

const string_view& — копирование имеет побочные эффекты

const string_view& — объект тяжёлый

Выберите правильный тип аргумента и обоснование. Если подходит несколько обоснований, выбирайте первое из них.

Какой тип должен быть на месте `<?>`?
```cpp
int CheckTentacle(Octopus* octopus_ptr, <?> tentacle);
```
Правильный ответ
shared_ptr<Tentacle> — объект лёгкий

shared_ptr<Tentacle> — функция принимает владение

shared_ptr<Tentacle> — функции нужна копия

const shared_ptr<Tentacle>& — копирование имеет побочные эффекты

const shared_ptr<Tentacle>& — объект тяжёлый

#### Необязательные параметры
Бывает, что параметр функции или метода необязателен. В этом случае можно задать значение по умолчанию:

```cpp
void PrintStat(std::ostream& out = std::cout);
```

Вызвать функцию выше вы можете вовсе без аргументов. Но у такого способа есть минус: функция никак не поймёт, опущен ли аргумент или значение по умолчанию указано явно. Два таких вызова абсолютно эквивалентны:
```cpp
PrintStat();
PrintStat(cout);
```
Как корректно обработать случай отсутствия содержательного значения? Отметьте варианты, которые могут пригодиться в определённых случаях, даже если у них есть недостатки.

Правильный ответ
Использовать специальный или не полностью инициализированный объект. Например, отдельное значение `enum`.
Это удобно для `enum` или объектов, для которых выделенное значение возможно. Минус: это возможно не во всех случаях. Также из сигнатуры не всегда ясно, что функция корректно обрабатывает специальное значение.

Правильный ответ
Использовать указатель вместо ссылки.
У указателя есть выделенное значение `nullptr`, которое означает отсутствие объекта по этому указателю. Минус: при использовании указателя из сигнатуры функции не ясно, что для него допустимо нулевое значение. Если в проекте, который вы разрабатываете, есть договорённость о допустимости `nullptr` для всех указателей, сигнатура становится вполне говорящей.

Правильный ответ
Использовать тип `optional`.
Сигнатура функции с `optional` явно показывает, что значение необязательно. Минус: его нельзя использовать со ссылкой.

Правильный ответ
Создать две версии функции. Одну из них — с меньшим количеством аргументов.
Это самый верный способ, наглядный с точки зрения сигнатур функций. Минус: иногда код придётся дублировать.

Самый предпочтительный и самый современный способ — `optional`. Он явно показывает, что передача объекта необязательна:

```cpp
// Можно указать письмо, если его нужно отправить по дороге в магазин.
// Но это необязательно:
void GoToShop(Shop& destination, const vector<Food>& shopping_list, 
              std::optional<Letter> letter_to_send = std::nullopt); 
```

Однако передать через `optional` объект по ссылке не так просто — для этого придётся обернуть её в `std::reference_wrapper`. В h-файле подобная декларация может выглядеть слишком перегружено, например: `std::optional<std::reference_wrapper<Letter>>`. Есть соблазн заменить `std::reference_wrapper` на обычный указатель, чтобы упростить сигнатуру до такой: `std::optional<const Letter*>`. Это выглядит лучше, но в таком случае `optional` не нужен, ведь как указатель можно передать `nullptr`. Правильный тип в таком случае `const Letter*`:

```cpp
// Можно указать письмо, если его нужно отправить по дороге в магазин.
// Но это необязательно:
void GoToShop(Shop& destination, const vector<Food>& shopping_list, 
              const Letter* letter_to_send = std::nullptr); 
```

Указатель похож на ссылку по возможностям и, как вы узнаете далее, по внутреннему устройству. В отличие от ссылки, он позволяет передать `nullptr`, то есть отсутствие объекта.