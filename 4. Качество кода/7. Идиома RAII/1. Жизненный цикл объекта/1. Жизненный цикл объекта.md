## Жизненный цикл объекта
С идиомой RAII вы уже встречались. В модуле о проектировании кода важно остановиться на ней отдельно и рассмотреть подробнее. Удачная реализация идиомы RAII помогает программисту избегать ошибок, связанных с созданием и разрушением объектов, а также делает код более лаконичным и простым для понимания.

Вспомним, что такое жизненный цикл объекта, и как разные переменные свою жизнь начинают и заканчивают.

Вся программа разделена на блоки. Блоком считается часть программы, ограниченная фигурными скобками:
```cpp
int Function () {
    // Начало блока 1
    ...
    while (condition) {
        // Начало блока 2
        if (condition) {
            // Начало блока 3
            ...
        }  // Конец блока 3
        ...
        } // Конец блока 2
    ...
}  // Конец блока 1 
```
Как видно из примера, блоки могут быть вложены друг в друга.

### Жизнь автоматических объектов

Объекты, объявленные внутри блока без использования динамической памяти, считаются автоматическими и «живут» на стеке. При создании объектов вызывается их конструктор. В конце блока все автоматические объекты разрушаются. Вызываются их деструкторы. Вызов деструкторов в конце блока будет обратным вызову конструкторов.

Допустим, есть функция, которая запускается каждый рабочий день. Назовём её `RunWorkingDay`. В блоке этой функции создаются три автоматических объекта: сотрудник `georgy`, сотрудник `alexey` и их менеджер `margarita`.
```cpp
void RunWorkingDay() {
    Employee georgy;
    Employee alexey;
    Manager margarita;
    ...
}
```

При создании этих объектов вызываются их конструкторы. Внутри конструкторов сотрудники приходят в офис, включают компьютеры, наливают кружечку кофе, узнают утренние новости. В общем, готовятся начать работу. На протяжении всего блока функции `RunWorkingDay` сотрудники взаимодействуют, делают важные и полезные дела. Когда рабочий день подходит к концу, сотрудники покидают офис. Они гладят офисного кота Кукуню, относят кружку в посудомойку, прощаются с офис-менеджером. Всё это происходит в деструкторе объектов, которые неявно вызываются в конце блока. Причём порядок ухода домой обратен порядку прихода на работу: первой уйдёт с работы `margarita`, потом `alexey` и последним выйдет из офиса трудоголик `georgy`.

### Жизнь динамических объектов

Если объекты создаются в динамической памяти, их жизненным циклом начинает управлять программист. Это удобно, когда нужно продлить срок жизни объекта за границами блока, где он был создан. С другой стороны, могут появиться проблемы с утечкой памяти, если программист вызовет new, но забудет вовремя вызвать `delete`.

Укажите правильный порядок вызова деструкторов объектов в этом коде при условии, что все условия для блоков `if` верны:

```cpp
void RunWorkingDay() {
    Employee georgy;
    Employee alexey;
    Tester* nickolay = nullptr;
    Manager* margarita = new Manager();
    if (NeedToTestNewFeature()) {
        Tester oleg;
        nickolay = new Tester();
        ...
    }
    if (NeedToHelpAndSupport()) {
        Employee* alexandra = new Employee();
        ...
        delete alexandra;
    }
    if (AllTested()) {
        delete nickolay;
    }
    ...
} 
```

— `oleg`, `alexandra`, `nickolay`, `alexey`, `georgy`

Первым уйдёт с работы, закончив тестирование новой фичи, `oleg`. Потом для помощи и поддержки появится  `alexandra`. После запуска всех тестов `nickolay` будет отпущен отдыхать. `alexey` уйдёт пораньше, потому что ему нужно забирать детей из музыкальной школы. georgy пришёл первым и уйдёт последним, потому что у него ключи от офиса. А вот менеджер `margarita` будет причиной утечки памяти в программе. Её деструктор вызван не будет.

### А если что-то пошло не так?

Под «пошло не так» имеются в виду исключения. Если внутри блока выброшено исключение, все деструкторы автоматических объектов, созданных до этого, будут вызваны в обратном порядке. Это уже знакомая вам раскрутка стека. Раскрутка будет продолжаться до тех пор, пока кто-нибудь не поймает исключение или пока программа не закончит работу аварийно.

Проблемы в исключении в конструкторе нет. В таких случаях объект считается не созданным, его деструктор не вызывается и стек начинает раскручиваться. 

Но если исключение генерируется внутри деструктора, возникает проблема. Программа переходит в неопределённое состояние и не может гарантировать вызов всех необходимых деструкторов. Поэтому деструкторы должны гарантировать отсутствие исключений.

### Жизнь полей объектов

Часто объекты содержат другие объекты — как матрёшки. При создании большой матрёшки сначала будут проинициализированы маленькие, и только потом большая матрёшка будет считаться созданной:
```cpp
// да, на английском "Матрёшка" будет Babushka с ударением на 'u'
class BigBabushka {
public:
    BigBabushka() = default;
    ~BigBabushka() = default;
private:
    SmallBabushka small_babushka_; 
    MediumBabushka medium_babushka_;
}
```
При вызове конструктора `BigBabushka` сначала будет вызван конструктор `SmallBabushka`, потом конструктор `MediumBabushka` и только после этого `BigBabushka` будет считаться созданной. Матрёшка будет собрана, начиная с самой маленькой. Если конструктор `BigBabushka` сгенерирует исключение, для всех уже созданных внутренних матрёшек будут вызваны соответствующие деструкторы, и выделенная память не утечёт.

При вызове деструктора `~BigBabushka` всё произойдёт в обратном порядке. Сначала будет уничтожен объект `BigBabushka`, потом `MediumBabushka`, затем `SmallBabushka`. То есть разбирать матрёшку будем, начиная с самой большой и до самой маленькой.

Принцип создания и уничтожения объектов, являющихся полями другого объекта, повторяет принцип работы стека: порядок разрушения обратен порядку создания.

В каком порядке будут вызваны конструкторы и деструкторы в этом примере, если при включении кофемашины в розетку произойдёт короткое замыкание?
```cpp
class CoffeeMachine {
public:
    CoffeeMachine() = default;
    ~CoffeeMachine() = default;
private:
    vector<CoffeeCapsule> capsules_;
    PowerConnection power_connection_;
}

void RunWorkingDay() {
    Employee georgy;
    Employee alexey;
    Manager* margarita = new Manager();

    CoffeeMachine coffee_machine_jora;
    georgy.DrinkCoffee(coffee_machine_jora);
    margarita.DrinkCoffee(coffee_machine_jora);
    ...
} 
```

— `Employee()`, `Employee()`, `Manager()`, `vector<CoffeeCapsule>()`, `PowerConnection()`, `~vector<CoffeeCapsule>`, `~Employee()`, `~Employee()`

В примерах этого урока объект `margarita` постоянно вызывал утечку памяти. Умные указатели могли бы предотвратить эту ситуацию. Умные указатели — отличная иллюстрация идиомы RAII. Она заключается в том, что инициализация объекта должна быть совмещена с началом жизни объекта, а освобождение ресурсов, используемых этим объектом, должно происходить при уничтожении объекта.