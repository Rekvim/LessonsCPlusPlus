## Идея RAII

Аббревиатура RAII расшифровывается как Resource Acquisition Is Initialization. На русский язык эту фразу принято переводить как «получение ресурса есть инициализация». Ёмко, но может быть не очень ясно.

Под ресурсом имеется в виду что-либо выданное объекту во временное пользование третьей стороной. Классические примеры — мьютексы, дескрипторы файлов или память. Эти ресурсы предполагают временное и бережное использование объектом, который об этих ресурсах попросил.

Под инициализацией понимается создание некой автоматической переменной, которая сразу инициализируется. Эта автоматическая переменная становится залогом того, что ресурс, которым она владеет и который она получила при создании, будет освобождён в конце жизни этой переменной. Иначе говоря, в конструкторе автоматическая переменная инициализируется и ресурс выделяется, а в деструкторе ресурс освобождается. 

Посмотрите на пример:
```cpp
Light* TurnOn(size_t power) {
    // выделяем ресурсы, чтобы свет горел
}
TurnOff(Light* light) {
    // освобождаем ресурсы и выключаем свет
}

void Work() {
    Light* light = TurnOn(100);
    ...
    TurnOff(light);
}
```
Зайдя в комнату, нужно включить лампочку мощностью 100 ватт. Внутри функции `TurnOn` будет запрошено и выделено нужное количество ресурса, чтобы лампочка загорелась. Как известно, выходя, следует гасить свет. То есть нужно вызвать метод `TurnOff`, который отключит лампу от напряжения в электрической сети и освободит ресурс. Если забыть вызвать `TurnOff`, свет так и будет гореть.

Другая опасность поджидает в тот момент, когда посередине функции `Work` происходит исключение и всем нужно срочно эвакуироваться из помещения. В этот момент люди обычно думают о важных документах, личных вещах, комнатных растениях и домашних любимцах, но не о том, что выбегая из комнаты, нужно нажать на выключатель.

Программисты используют идиому RAII, чтобы облегчить жизнь себе и пользователям их кода. Вместо того чтобы вешать грозные напоминания о выключении света, они просто устанавливают датчик. Он выключит свет, когда в помещении станет пусто:
```cpp
class MoveSensor {
public:
    MoveSensor(Light* light)
        : light_(light)
    {
    }
    ~MoveSensor() {
        TurnOff(light_);
    }
private:
    Light* light_;
} 
```
Установим сенсор в нашу комнату и перепишем функцию `Work`:
```cpp
void Work() {
    MoveSensor sensor(TurnOn(100));
    ...
} 
```
При выходе из блока будут вызваны деструкторы всех автоматических переменных, в том числе и деструктор объекта `sensor`, где свет выключится без дополнительных действий со стороны пользователя. То же произойдёт, если будет объявлена срочная эвакуация.

Какое утверждение о классе class MoveSensor верно? — Что-то не так с «правилом пяти».

«Правило пяти» говорит, что если класс требует хотя бы одну из специальных функций-членов (деструктор, конструктор копирования, конструктор перемещения, оператор присваивания или оператор перемещения), то, скорее всего, он требует и все остальные специальные методы.

В нашем случае определён конструктор и деструктор. Но что произойдёт, если мы попытаемся скопировать сенсор?
```cpp
void Work() {
    MoveSensor sensor(TurnOn(100));
    MoveSensor other_sensor = sensor;
    ...
}
```

— Указатели на `Light` скопируются, и при вызове деструкторов лампочка будет выключена дважды.

Чтобы предотвратить подобные ошибки владения ресурсами, с копированием и присваиванием классов-RAII-обёрток поступают аккуратно: или хитро определяют, как объект должен быть скопирован, или просто запрещают копирование. Здесь просто запретим копирование объектов типа `MoveSensor`:
```cpp
class MoveSensor {
public:
    MoveSensor(Light* light)
        : light_(light)
    {
    }
    ~MoveSensor() {
        TurnOff(light_);
    }
    MoveSensor(const MoveSensor&) = delete;
    MoveSensor& operator=(const MoveSensor&) = delete;
private:
    Light* light_;
}
```