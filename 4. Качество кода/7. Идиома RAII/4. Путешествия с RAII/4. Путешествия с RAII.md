## Путешествия с RAII
Рассмотрим новую задачу по мотивам задачи о бронировании. Применим идиому RAII к ресурсам, которые предоставляет другой класс, а не сторонняя система.

Перед вами два класса:
##### hotel_provider.h

```cpp
#pragma once
#include <iostream>
#include <string>

class HotelProvider {
public:
    using BookingId = std::string;

    struct BookingData {
        std::string hotel_id;
        std::string date_from;
        std::string date_to;
        int persons;
    };

    BookingId Book(const BookingData& data) {
        using namespace std;
        cerr << "Hotel::Book: "s << data.hotel_id << endl;
        return "B1"s;
    }

    void Cancel(const BookingId& id) {
        using namespace std;
        cerr << "Cancel hotel booking "s << id << endl;
    }
};
```
##### flight_provider.h
```cpp
#pragma once
#include <iostream>
#include <string>

class FlightProvider {
public:
    using BookingId = std::string;

    struct BookingData {
        std::string flight_id;
        std::string person;
        std::string date;
    };

    BookingId Book(const BookingData& data) {
        using namespace std;
        cerr << "Flight::Book: "s << data.flight_id << endl;
        return "F1"s;
    }

    void Cancel(const BookingId& id) {
        using namespace std;
        cerr << "Cancel flight "s << id << endl;
    }
}; 
```
Они очень похожи. Один управляет бронированием гостиниц, а другой — полётов. Работа методов классов тоже достаточно тривиальна. При вызове Book на экран выводится сообщение и возвращается `BookingId`. При вызове `Cancel` также выводится сообщение.

Используем эти два класса, чтобы написать систему управления командировками сотрудников. Не будем загромождать класс обработкой данных, оставим только самую суть.

##### trip_manager.h

```cpp
#pragma once
#include <string>
#include <vector>
#include "hotel_provider.h"
#include "flight_provider.h"

struct Trip {
    std::vector<HotelProvider::BookingId> hotels;
    std::vector<FlightProvider::BookingId> flights;
};

class TripManager {
public:
    using BookingId = std::string;

    struct BookingData {
        std::string person;
        std::string city;
        std::string date_from;
        std::string date_to;
    };

    Trip Book(const BookingData& data) {
        Trip trip;
        using namespace std::literals;
        // предположим, что это простейшая командировка,
        // включающая в себя перелёт туда, проживание в гостинице 
        // и перелёт обратно. Не будем писать обработку входящей информации,
        // пока нам это не нужно.
        // добавим блоки, чтобы имена переменных не конфликтовали
        {
            FlightProvider::BookingData flight_booking_data;
            flight_booking_data.flight_id = "1"s;
            trip.flights.push_back(flight_provider_.Book(flight_booking_data));
        }
        {
            HotelProvider::BookingData hotel_booking_data;
            hotel_booking_data.hotel_id = "2"s;
            trip.hotels.push_back(hotel_provider_.Book(hotel_booking_data));
        }
        {
            FlightProvider::BookingData flight_booking_data;
            flight_booking_data.flight_id = "3"s;
            trip.flights.push_back(flight_provider_.Book(flight_booking_data));
        }
        return trip;
    }

    void Cancel(Trip& trip) {
        // отменяем бронирования у провайдеров
        for (auto& id : trip.hotels) {
            hotel_provider_.Cancel(id);
        }
        // чистим вектора в структуре trip
        trip.hotels.clear();
        for (auto& id : trip.flights) {
            flight_provider_.Cancel(id);
        }
        trip.flights.clear();
    }
private:
    HotelProvider hotel_provider_;
    FlightProvider flight_provider_;
};
```
При бронировании пользователь может передать структуру бронирования, которая будет обработана нужным образом, а дальше будут вызваны соответствующие методы `HotelProvider` и `FlightProvider`. Объекты обоих классов содержатся внутри объекта `TripManager`. При успешном бронировании пользователь получит структуру `Trip`, содержащую два вектора: один с информацией о перелётах, другой — об отелях.

Посмотрите на пример того, как пользователь будет применять класс `TripManager`:

##### main.cpp
```cpp
#include "trip_manager.h"

using namespace std;

int main() {
    TripManager tm;
    // для нашего примера воспользуемся просто пустой структурой
    auto trip = tm.Book({});
    tm.Cancel(trip);
}
```
Что выведет программа при запуске?


Правильный ответ
```
Flight::Book: 1
Hotel::Book: 2
Flight::Book: 3
Cancel hotel booking B1
Cancel flight F1
Cancel flight F1 
```

`flight_id` и `hotel_id` пронумерованы по порядку внутри `TripManager`, а вот BookingId в нашей наивной имплементации не меняется ни у отелей, ни у полётов.

Теперь предположим, что внутри метода `FlightProvider::Book` может быть сгенерировано исключение. Добавим счётчик бронирований. Когда значение счётчика будет больше единицы, сгенерируем исключение. При этом метод Cancel всегда отрабатывает правильно, исключения там генерироваться не будут.

##### flight_provider.h

```cpp
#pragma once
#include <exception>
#include <iostream>
#include <string>

class FlightProvider {
public:
    using BookingId = std::string;

    struct BookingData {
        std::string flight_id;
        std::string person;
        std::string date;
    };

    BookingId Book(const BookingData& data) {
        using namespace std;
        counter_++;
        if (1 < counter_) {
            throw runtime_error("Overbooking"s);
        }
        cerr << "Flight::Book: "s << data.flight_id << endl;
        return "F1"s;
    }
    void Cancel(const BookingId& id) {
        using namespace std;
        counter_--;
        cerr << "Cancel flight "s << id << endl;
    }
private:
    int counter_ = 0;
}; 
```

Что будете выведено на экран теперь?
```cpp
Flight::Book: 1
Hotel::Book: 2
terminate called after throwing an instance of 'std::runtime_error'
  what():  Overbooking 
```

Провайдеры успеют забронировать один перелёт и гостиницу, но при попытке бронирования обратного перелёта вылетит исключение.

Вот мы и подобрались к проблеме: как отменить успешные бронирования из командировочного пакета, если одно из бронирований обработать не получилось? Ведь если их не отменить, это приведёт к финансовым потерям организации.

Какие есть варианты, чтобы справится с ситуацией?

— Обернуть вызов `auto trip = tm.Book({});` в `try`-`catch` блок.
Неплохой вариант, он будет работать. Но это значит, что пользователю TripManager придётся собственноручно вызывать Cancel. Кроме этого, если нужно совершить много бронирований в разных местах кода, программа начнёт покрываться лапшой из `try`-`catch` блоков.

— Обернуть в `try`-`catch` вызовы функций провайдеров внутри `TripManager::Book`:
```cpp
Trip Book(const BookingData& data) {
    Trip trip;
    try {
            {
                FlightProvider::BookingData flight_booking_data;
                flight_booking_data.flight_id = "1"s;
                trip.flights.push_back(flight_provider_.Book(flight_booking_data));
            }
            {
                HotelProvider::BookingData hotel_booking_data;
                hotel_booking_data.hotel_id = "2"s;
                trip.hotels.push_back(hotel_provider_.Book(hotel_booking_data));
            }
            {
                FlightProvider::BookingData flight_booking_data;
                flight_booking_data.flight_id = "3"s;
                trip.flights.push_back(flight_provider_.Book(flight_booking_data));
            }
    } catch (...) {
        Cancel(trip);
        throw;
    }
    return trip;
} 
```
Это рабочий вариант. Но это значит, что работоспособность программы зависит от внимательности программиста. Если где-нибудь в другом месте кода будет вызван метод `FlightProvider::Book`, нужно не забыть обернуть его в `try`-`catch` блок.

— Хочется применить RAII, но пока непонятно где.
Да, мы здесь именно из-за RAII. Сейчас разберёмся, как правильно применить эту идиому.