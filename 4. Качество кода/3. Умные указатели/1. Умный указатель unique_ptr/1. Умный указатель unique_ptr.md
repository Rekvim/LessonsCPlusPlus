## Умный указатель unique_ptr


Работа с сырыми указателями и динамической памятью в C++ требует внимательности. Иначе можно столкнуться с целым рядом ошибок:

- утечки памяти,
- использование неинициализированного указателя,
- повторный вызов `delete` с указателем на ранее удалённый объект,
- использование непарной версии оператора `delete`.

Управляться с динамической памятью становится ещё труднее, когда дело доходит до написания кода, устойчивого к исключениям.

```cpp
template <typename T>
struct TreeNode {
    T value;
    TreeNode* left = nullptr;
    TreeNode* right = nullptr;
};

template <typename T>
void DeleteTree(TreeNode<T>* node) {
    if (!node) {
        return;
    }
    DeleteTree(node->left);
    DeleteTree(node->right);
    delete node;
}

int main() {
    using T = TreeNode<int>;
    // Здесь гарантируется порядок вычислений: new T{4}, new T{7}, new T{6, ...}
    T* root1 = new T{6, new T{4}, new T{7}}; // Здесь спрятались возможные утечки памяти
    DeleteTree(root1);
}
```

В каких операторах new выбрасывание исключения приведёт к утечкам памяти? — new T{6, ...}. До создания узла 6 в динамической памяти будут выделены узлы 4 и 7. Исключение, выброшенное при создании узла 6, приведёт к тому, что память, занимаемая этими узлами, освобождена не будет.

К счастью, стандартная библиотека предоставляет классы умных указателей. Умный указатель — это класс, синтаксически похожий на обычный указатель: у него есть операторы `*` и `->` для доступа к объекту или ресурсу. При этом умный указатель управляет временем жизни объекта, своевременно удаляя его, что сильно упрощает работу с объектами в динамической памяти.

Этот урок посвящён указателю `std::unique_ptr` — одному из наиболее часто используемых умных указателей.

`unique_ptr` — умный указатель, который единолично владеет объектом в динамической памяти. Это значит, что в программе в один момент времени может быть только один экземпляр `unique_ptr`, ссылающийся на конкретный объект в динамической памяти. Поэтому этот указатель и называют уникальным. Внутри `unique_ptr` содержится обычный указатель на объект в динамической памяти.

Создать `unique_ptr` очень просто. Для этого нужно подключить заголовочный файл `<memory>` и передать конструктору `unique_ptr` указатель на объект в куче:
```cpp
#include <iostream>
#include <memory>
#include <string>

using namespace std;

struct Cat {
    Cat(const string& name, int age)
        : name_(name)
        , age_(age)  //
    {
        cout << name_ << " cat was created"s << endl;
    }
    const string& GetName() const noexcept {
        return name_;
    }
    int GetAge() const noexcept {
        return age_;
    }
    ~Cat() {
        cout << name_ << " cat was destroyed"s << endl;
    }
    void Speak() const {
        cout << "Meow!"s << endl;
    }

private:
    string name_;
    int age_;
};

int main() {
    Cat* cat = new Cat("Tom"s, 2);
    unique_ptr<Cat> p{cat};
    p->Speak();
    // Деструктор p удалит кота
} 
```
Сразу после создания `unique_ptr` начнёт владеть переданным ему объектом и при выходе из области видимости автоматически удалит его, вызвав оператор `delete`:

```
Tom cat was created
Meow!
Tom cat was destroyed 
```

В отличие от сырых указателей, `unique_ptr` всегда проинициализирован — он либо ссылается на существующий объект, либо равен `nullptr`:

```cpp
int main() {
    unique_ptr<Cat> p;
    assert(!p);
} 
```

Удобнее и безопаснее сразу после создания объекта в куче не иметь дела с «сырыми» указателями вообще и сразу получить  `unique_ptr`, ссылающийся на созданный объект. Для этого служит шаблонная функция `std::make_unique`, которая создаёт объект в куче, передавая конструктору объекта свои аргументы, и возвращает `unique_ptr`. Ключевое слово auto помогает более кратко объявить переменную-указатель:

```cpp
int main() {
    // Создаёт экземпляр класса Cat в куче и возвращает владеющий unique_ptr
    auto cat = make_unique<Cat>("Tom"s, 2);
    cat->Speak();
}
```

Таким образом, `unique_ptr` позволяет создать объект в куче и управлять временем его жизни, вообще не используя операторы `new` и `delete`.

Чтобы получить значение сырого указателя на объект, есть метод `get`:
```cpp
Cat* raw_cat_ptr = new Cat("Tom"s, 2);
unique_ptr<Cat> cat_ptr{raw_cat_ptr};

// get() возвращает сырой указатель на объект
assert(cat_ptr.get() == raw_cat_ptr); 
```

В отличие от обычного указателя, `unique_ptr` — move-only тип. Нельзя создать копию `unique_ptr`, ведь тогда объектом владели бы несколько `unique_ptr`, что недопустимо. Вместо копирования разрешается перемещать указатель на объект от одного `unique_ptr` к другому. После перемещения старый указатель теряет право владения объектом и начинает указывать на `nullptr`. Право владения переходит к новому указателю:

```cpp
int main() {
    // Создаёт экземпляр Cat в куче и возвращает unique_ptr
    auto cat1 = make_unique<Cat>("Tom"s, 2);
    // Следующая строчка не скомпилируется - экземпляры unique_ptr копировать нельзя
    unique_ptr<Cat> cat2 = cat1;

    // Зато можно перемещать.
    auto cat2 = std::move(cat1);

    assert(!cat1);
    assert(cat2);
}
```

Часто значение `unique_ptr` перемещается из одной области видимости в другую. Следующая функция создаёт кота в динамической памяти и возвращает `unique_ptr`, владеющий этим котом:

```cpp
// Функция создаёт двухлетних котов с заданным именем
unique_ptr<Cat> CreateCat(const string& name) {
    return make_unique<Cat>(name, 2);
}
```
`unique_ptr` можно принимать в качестве параметров функций и методов. Обычно `unique_ptr` передаётся по rvalue-ссылке:
```cpp
class Witch {
public:
    explicit Witch(const string& name)
        : name_(name) {
    }

    void SetCat(unique_ptr<Cat>&& cat) noexcept {
        cat_ = std::move(cat);
    }
    unique_ptr<Cat> ReleaseCat() noexcept {
        return std::move(cat_);
    }

private:
    string name_;
    unique_ptr<Cat> cat_;
};
```
Так, можно создать кота, передать его волшебнице, а потом забрать у неё обратно. При этом перемещении участвует только указатель. Сам объект, сколь бы «тяжёлым» он ни был, никуда не перемещается и не копируется:
```cpp
int main() {
    Witch witch("Hermione"s);
    witch.SetCat(CreateCat("Crookshaks"s));
    auto cat = witch.ReleaseCat();
    cat->Speak();

    Witch witch2("Ginny Weasley"s);
    witch2.SetCat(std::move(cat));
    assert(!cat);
}
```
Класс, который содержит поле типа `unique_ptr`, также по умолчанию становится move-only — компилятор не может сгенерировать для него конструктор копирования и копирующий оператор присваивания:
```cpp
int main() {
    Witch witch("Hermione"s);
    // Ошибка компиляции - в классе Witch удалены конструктор копирования и оператор копирующего присваивания
    // Witch witch2(witch);

    // Зато можно переместить
    Witch witch2(std::move(witch));
}
```
Если компилятор не смог сгенерировать конструктор копирования и оператор присваивания для класса `Witch` — не беда. Нужно лишь немного помочь ему в этом. Итак, пора браться за написание кода.