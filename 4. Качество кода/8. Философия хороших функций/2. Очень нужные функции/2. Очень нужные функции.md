## Очень нужные функции
После того как код проходит через все этапы компиляции, он превращается в набор команд на языке ассемблера. В ассемблере нет функций. Там есть только переходы с адреса на адрес. Такие прыжки по элементам кода — это по сути вызовы функций. Компьютер отлично справляется без такой абстракции, как функция. Но нам, людям — программисты ведь тоже люди, — функции очень нужны. Без них код выглядел бы так:

##### Очень длинный, но работающий код

```cpp
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

enum class Gender { FEMALE, MALE };

struct Person {
    int age;           // возраст
    Gender gender;     // пол
    bool is_employed;  // имеет ли работу
};

int main() {
    vector<Person> persons = {
        {31, Gender::MALE, false},   {40, Gender::FEMALE, true},  {24, Gender::MALE, true},
        {20, Gender::FEMALE, true},  {80, Gender::FEMALE, false}, {78, Gender::MALE, false},
        {10, Gender::FEMALE, false}, {55, Gender::MALE, true},
    };
    auto females_end = partition(persons.begin(), persons.end(), [](const Person& p) {
        return p.gender == Gender::FEMALE;
    });
    auto employed_females_end = partition(persons.begin(), females_end, [](const Person& p) {
        return p.is_employed;
    });
    auto employed_males_end = partition(females_end, persons.end(), [](const Person& p) {
        return p.is_employed;
    });

    int median_age = 0;
    int median_age_females = 0;
    int median_age_male = 0;
    int median_age_employed_females = 0;
    int median_age_unemployed_females = 0;
    int median_age_employed_males = 0;
    int median_age_unemployed_males = 0;

    if (persons.begin() != persons.end()) {
        auto range_begin = persons.begin();
        auto range_end = persons.end();
        vector<Person> range_copy(range_begin, range_end);
        auto middle = range_copy.begin() + range_copy.size() / 2;
        nth_element(range_copy.begin(), middle, range_copy.end(), [](const Person& lhs, const Person& rhs) {
            return lhs.age < rhs.age;
        });
        median_age = middle->age;
    }
    if (persons.begin() != females_end) {
        auto range_begin = persons.begin();
        auto range_end = females_end;
        vector<Person> range_copy(range_begin, range_end);
        auto middle = range_copy.begin() + range_copy.size() / 2;
        nth_element(range_copy.begin(), middle, range_copy.end(), [](const Person& lhs, const Person& rhs) {
            return lhs.age < rhs.age;
        });
        median_age_females = middle->age;
    }
    if (females_end != persons.end()) {
        auto range_begin = females_end;
        auto range_end = persons.end();
        vector<Person> range_copy(range_begin, range_end);
        auto middle = range_copy.begin() + range_copy.size() / 2;
        nth_element(range_copy.begin(), middle, range_copy.end(), [](const Person& lhs, const Person& rhs) {
            return lhs.age < rhs.age;
        });
        median_age_male = middle->age;
    }
    if (persons.begin() != employed_females_end) {
        auto range_begin = persons.begin();
        auto range_end = employed_females_end;
        vector<Person> range_copy(range_begin, range_end);
        auto middle = range_copy.begin() + range_copy.size() / 2;
        nth_element(range_copy.begin(), middle, range_copy.end(), [](const Person& lhs, const Person& rhs) {
            return lhs.age < rhs.age;
        });
        median_age_employed_females = middle->age;
    }
    if (employed_females_end != females_end) {
        auto range_begin = employed_females_end;
        auto range_end = females_end;
        vector<Person> range_copy(range_begin, range_end);
        auto middle = range_copy.begin() + range_copy.size() / 2;
        nth_element(range_copy.begin(), middle, range_copy.end(), [](const Person& lhs, const Person& rhs) {
            return lhs.age < rhs.age;
        });
        median_age_unemployed_females = middle->age;
    }
    if (females_end != employed_males_end) {
        auto range_begin = females_end;
        auto range_end = employed_males_end;
        vector<Person> range_copy(range_begin, range_end);
        auto middle = range_copy.begin() + range_copy.size() / 2;
        nth_element(range_copy.begin(), middle, range_copy.end(), [](const Person& lhs, const Person& rhs) {
            return lhs.age < rhs.age;
        });
        median_age_employed_males = middle->age;
    }
    if (employed_males_end != persons.end()) {
        auto range_begin = employed_males_end;
        auto range_end = persons.end();
        vector<Person> range_copy(range_begin, range_end);
        auto middle = range_copy.begin() + range_copy.size() / 2;
        nth_element(range_copy.begin(), middle, range_copy.end(), [](const Person& lhs, const Person& rhs) {
            return lhs.age < rhs.age;
        });
        median_age_unemployed_males = middle->age;
    }

    cout << "Median age = "s << median_age << endl;
    cout << "Median age for females = "s << median_age_females << endl;
    cout << "Median age for males = "s << median_age_male << endl;
    cout << "Median age for employed females = "s << median_age_employed_females << endl;
    cout << "Median age for unemployed females = "s << median_age_unemployed_females << endl;
    cout << "Median age for employed males = " << median_age_employed_males << endl;
    cout << "Median age for unemployed males = "s << median_age_unemployed_males << endl;
}
```
Этот код выполняет ту же работу, что и решение в задании прошлого урока. Но писать его пришлось ужасно долго. Очевидно, у кода есть и другие недостатки. При этом в нём не стало всего двух функций. Функции стандартных библиотек остались. А теперь представьте код без функций из библиотек.

Вот что изменилось, когда из программы убрали функции:

- Стало невозможно переиспользовать код.
  Мы повторили один и тот же блок кода семь раз, чтобы вычислить семь показателей. Если потребуется вычислить восьмой показатель в другой части кода, придётся опять копировать код и вносить в него изменения. Так он будет соответствовать контексту, в котором находится. Если в тиражируемый кусок кода закралась ошибка, править её придётся везде, куда этот код скопировали.
- Невозможно протестировать часть программы.
  Чтобы проверить, работает ли программа, нужно запустить её целиком и руками или с использованием другой программы подать на вход данные. В результате получится семь чисел. Сложно представить, что делать, если два числа из семи окажутся неправильными. Невозможно гарантировать работу отдельной функции — только всей программы целиком. Будь у нас отдельная функция вычисления медианного возраста, мы могли бы сами написать для неё юнит-тесты и верифицировать, что она работает верно. Избавившись от функций, мы лишили себя возможности тестировать программу по частям.
- Читать код без комментариев трудно.
  Когда код находился внутри функции, мы могли явно дать ему понятное имя. Сейчас же это просто блок кода, повторённый несколько раз. Прочитать его без комментариев очень сложно. А у комментариев есть недостатки: они не пишутся автоматически и не обновляются автоматически. Написание комментариев требует дополнительных усилий от разработчика, который уже и так устал копировать код. Кроме прочего, функция помогает документировать функционал.
- Нет чёткого понимания ввода и вывода для функции.
  Раньше мы могли рассматривать функцию как чёрный ящик с фиксированным типом ввода и вывода. Теперь практически невозможно понять, какими данными оперирует блок кода и что считается результатом его работы.

Разумное разделение кода на функции даёт огромное преимущество перед кодом, написанным единым блоком. Берегите себя и своих коллег, делите код на функции.