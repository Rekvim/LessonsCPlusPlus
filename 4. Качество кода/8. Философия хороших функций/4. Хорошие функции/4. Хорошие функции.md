## Хорошие функции
В прошлом уроке вы увидели, когда стоит оформлять функцию как метод класса, а когда — как отдельную боевую единицу. Узнали, какими принципами руководствоваться при выборе. В этом уроке разберём, что такое хорошая понятная функция и какими важными свойствами она обладает.
1. Понятная сигнатура
По одному взгляду на сигнатуру должно быть ясно, что функция делает. Чтобы достичь этого, обратите внимание на несколько деталей.
    - Понятность названия. Обычно названия функций отвечают на вопрос «что делать?». Например, ReadDocument или MakeCoffee.
    - Список входных аргументов. Он не должен вызывать негативных чувств у читателя. Ужас, фрустрация, желание развидеть обратно, неприятное удивление, непонимание — совсем не то, что хочет испытать человек, читающий ваш код. В идеале список аргументов и возвращаемое значение не должны вызывать никаких чувств кроме уверенности. Программист должен просто подумать «мне всё ясно» и продолжить чтение.
    Посмотрите на пример:
        ```cpp
        template <typename InputIt>
        int ComputeMedianAge(InputIt range_begin, InputIt range_end);
        ```
        Эту функцию вы использовали в задании о демографических показателях. По её сигнатуре видно, что функция считает медианный возраст для чисел из диапазона, представленного началом и концом диапазона. После вычислений она возвращает результат типа int. Это говорит о том, что результат вычислений должен умещаться в диапазон, поддерживаемый этим типом.
        А теперь предположим, что функция выглядела бы так:
        ```cpp
        template <typename T>
        int Compute(T& container);
        ```
        По её названию сложно понять, что же именно функция считает. Видно, что она принимает некий контейнер по ссылке. Но ссылка не константная. Это настораживает, ведь теперь контейнер может измениться внутри этой функции. Пользователю нужно вникнуть в происходящее внутри функции, потому что по сигнатуре не понятно почти ничего. Нужно стараться написать сигнатуру функции такой, чтобы заглядывать в реализацию пришлось только в крайнем случае.

2. Предсказуемое поведение
    То самое чувство уверенности, которое возникло у читателя, не должно разбиться о разочарование тем, что функция ведёт себя не так, как ожидалось. Функция перестаёт быть хорошей, когда первоначальное «мне всё ясно» превращается в «что, чёрт возьми, тут происходит».
    В том же примере с функцией `Compute` у программиста, принимающего контейнер по неконстантной ссылке, всегда будет соблазн этот контейнер изменить. Как говорилось в теме о константности, константность важна в том числе и для сохранения инварианта объекта. Например, если до вызова функции контейнер был отсортирован, а внутри функции элементы внезапно перемешались, пользователь узнает об этом, только если проверит. И тогда он точно подумает что-нибудь вроде «кажется, я этого не просил».

3. Удобство тестирования
    Программист, написавший функцию, должен быть уверен в корректности её работы. Проще всего гарантировать это, написав тесты и прогнав функцию через них. Конечно, так происходит не всегда. Многие функции настолько простые и лаконичные, что писать для них тесты было бы расточительством времени. Но если функция реализует важный алгоритм, у которого есть специальные случаи и граничные условия, то время, потраченное на тестирование, будет значительно меньше, чем время, потраченное на поиск ошибки.
    Вернёмся ненадолго к решению задачи о демографических показателях:
        
### Полное решение
```cpp
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

enum class Gender { FEMALE, MALE };

struct Person {
    int age;
    Gender gender;
    bool is_employed;
};

struct AgeStats {
    int total;
    int females;
    int males;
    int employed_females;
    int unemployed_females;
    int employed_males;
    int unemployed_males;
};

template <typename InputIt>
int ComputeMedianAge(InputIt range_begin, InputIt range_end) {
    if (range_begin == range_end) {
        return 0;
    }
    vector<typename InputIt::value_type> range_copy(range_begin, range_end);
    auto middle = range_copy.begin() + range_copy.size() / 2;
    nth_element(range_copy.begin(), middle, range_copy.end(), [](const Person& lhs, const Person& rhs) {
        return lhs.age < rhs.age;
    });
    return middle->age;
}

namespace stats_manager {
    vector<Person> ReadPersons(istream& in_stream = cin);
    AgeStats ComputeStats(vector<Person> persons);
    void PrintStats(const AgeStats& stats, ostream& out_stream = cout);
}

vector<Person> stats_manager::ReadPersons(istream& in_stream) {
    int person_count;
    in_stream >> person_count;
    vector<Person> persons;
    persons.reserve(person_count);
    for (int i = 0; i < person_count; ++i) {
        int age, gender, is_employed;
        in_stream >> age >> gender >> is_employed;
        Person person{age, static_cast<Gender>(gender), is_employed == 1};
        persons.push_back(person);
    }
    return persons;
}

AgeStats stats_manager::ComputeStats(vector<Person> persons) {
    auto females_end = partition(persons.begin(), persons.end(), [](const Person& p) {
        return p.gender == Gender::FEMALE;
    });
    auto employed_females_end = partition(persons.begin(), females_end, [](const Person& p) {
        return p.is_employed;
    });
    auto employed_males_end = partition(females_end, persons.end(), [](const Person& p) {
        return p.is_employed;
    });

    return {ComputeMedianAge(begin(persons), end(persons)), ComputeMedianAge(begin(persons), females_end),
            ComputeMedianAge(females_end, end(persons)), ComputeMedianAge(begin(persons), employed_females_end),
            ComputeMedianAge(employed_females_end, females_end), ComputeMedianAge(females_end, employed_males_end),
            ComputeMedianAge(employed_males_end, end(persons))};
}

void stats_manager::PrintStats(const AgeStats& stats, ostream& out_stream) {
    out_stream << "Median age = " << stats.total << endl
               << "Median age for females = " << stats.females << endl
               << "Median age for males = " << stats.males << endl
               << "Median age for employed females = " << stats.employed_females << endl
               << "Median age for unemployed females = " << stats.unemployed_females << endl
               << "Median age for employed males = " << stats.employed_males << endl
               << "Median age for unemployed males = " << stats.unemployed_males << endl;
}

int main() {
    stats_manager::PrintStats(stats_manager::ComputeStats(stats_manager::ReadPersons()));
} 
    }
```

Обратите внимание на вызов следующей функции:
```cpp
int main() {
    stats_manager::PrintStats(stats_manager::ComputeStats(stats_manager::ReadPersons()));
}
```  
Здесь ввод, вычисление и вывод результатов на экран разделены. Но ничего не мешает читать ввод и выводить результат внутри некой общей функции `ProcessStats`:
```cpp
int main() {
    ProcessStats();
```
Внутри мы бы читали данные из `cin`, вычисляли бы результат и выводили его в `cout`. Тогда эту функцию было бы невозможно протестировать. Она ничего не принимает и ничего не возвращает. Самое «дешёвое» исправление ситуации — передать в эту функцию ссылки на потоки ввода и вывода: подать на вход некие тестовые данные и поймать данные на выходе.

Но лучше всё же разбить на чтение, ввод и вывод, чтобы отделить разную логику и получить понятную сигнатуру для основной функции.

4. Поддерживаемость
    Редкие функции проживают всю жизнь без изменений. Добавляются новые требования, выявляются баги. В хорошие функции добавляют функционал и переиспользуют их. Чем более гибкими будут ваши функции, тем выше качество вашего кода. Но здесь важен баланс, так как нужно учитывать следующее свойство. А пока остановимся на примере.

    В задаче о бронировании отелей в одиннадцатом спринте была использована отдельная структура `Booking`. Публичная функция `Book` принимала набор параметров, по которым конструировала объект типа `Booking` и передавала этот объект дальше на обработку внутреннему классу `HotelInfo`:
    ```cpp
    class HotelManager {
    public:
        void Book(int64_t time, const string& hotel_name, int client_id, int room_count) {
            current_time_ = time;
            hotels_[hotel_name].Book({time, client_id, room_count});
        }
        ....

    private:
        struct Booking {
            int64_t time;
            int client_id;
            int room_count;
        };

        class HotelInfo {
        public:
            void Book(const Booking& booking) {
                last_bookings_.push(booking);
                room_count_ += booking.room_count;
                ++client_booking_counts_[booking.client_id];
            }
            ...

        private:
            queue<Booking> last_bookings_;
            ...
        };
        ...
    };
    ```
    Если бы структуры `Booking` не существовало, внутри `HotelInfo` пришлось бы держать не одну очередь, а три — под каждый из параметров. Соответственно, методы push и pop тоже пришлось бы вызывать трижды:

    ```cpp
    class HotelManager {
    public:
        void Book(int64_t time, const string& hotel_name, int client_id, int room_count) {
            current_time_ = time;
            hotels_[hotel_name].Book(time, client_id, room_count);
        }
        ....

    private:
        class HotelInfo {
        public:
            void Book(int64_t time, int client_id, int room_count) {
                last_client_id_.push(client_id);
                last_time_.push(time);
                last_room_count_.push(room_count);
                room_count_ += booking.room_count;
                ++client_booking_counts_[booking.client_id];
            }
            ...

        private:
            queue<int64_t> last_time_;
            queue<int> last_client_id_;
            queue<int> last_room_count_;
            ...
        };
        ...
    };
    ```
    Когда код пишется с нуля, нет ничего страшного в том, чтобы держать три очереди для трёх параметров. Но когда число параметров начинает расти, легко забыть вызвать pus~h или pop для одного из них. Кроме того, сигнатура функции начинает превращаться в нечто очень длинное и неудобное. Использование структуры в качестве входного аргумента увеличило гибкость решения, и функция стала удобнее для внесения в неё потенциальных изменений.

5. Сфокусированность
    Функция должна иметь чёткий функционал. Функция пришла в этот мир ради решения одной определённой задачи. Она не должна уметь и блины печь, и гвозди забивать. Не пытайтесь предусмотреть все возможные будущие потребности к расширению. Пусть функция будет гибкой, но заточенной чётко на одно действие.
    Примером плохо сфокусированной функции может служить та же функция `ProcessStats`. Она читает данные, обрабатывает их и выводит результат. И швец, и жнец, и на дуде игрец:
    ```cpp
    int main() {
        ProcessStats();
    }
    ```
    Проблемы с такими функциями начинаются, когда их требуется изменить или когда программисту нужна только часть функционала. Допустим, ваш коллега написал функцию `ProcessStats`. Она читает данные из консоли и результат тоже выводит в консоль. Теперь над кодом работаете вы, и вычисление статистики становится частью большого сервиса. Данные этот сервис получает по сети, они неким образом обрабатываются в удобную структуру данных. Дальше по этим данным должны быть посчитаны демографические показатели, которые позже вместе с другими данными будут зашифрованы и отправлены в базу данных на удалённом сервере. Вы обнаруживаете функцию `ProcessStats`, но не можете её переиспользовать.Нужно отделить часть функционала. Вы пишете новую сигнатуру, копируете куски кода из начальной функции, пытаетесь разобраться в связях между переменными и при этом ничего не сломать. А ещё в идеале сделать так, чтобы `ProcessStats` теперь вызывала вашу функцию, ведь иначе код дублируется. Весь процесс превращается в головную боль, сила которой прямо пропорциональна несфокусированности функции.
    Такую функцию тяжело понимать и дорабатывать. Функция-лапша на несколько экранов — страшный сон программиста, работающего с чужим кодом.

Отметьте, какими свойствами хороших функций обладает функция, определяющая, является ли строка числом с плавающей точкой:
```cpp
void PrintFloatInfo(const std::string& text) {
    static regex num_reg("\\s*([+-]?[0-9]+)\\.([0-9]*)(e[+-]?[0-9]+)?\\s*");
    smatch m;

    if (!regex_match(text, m, num_reg)) {
        cout << text << " - не число с плавающей точкой"sv << endl;
    } else {
        cout << text << " - число с целой частью "sv << m[1]
                     << ", дробной частью "sv << m[2] << endl;
    }
} 
```
Правильный ответ
Понятная сигнатура

Правильный ответ
Предсказуемое поведение

Неправильный ответ
Удобство тестирования

Правильный ответ
Поддерживаемость

Неправильный ответ
Сфокусированность
Как вам задача?

Сигнатура достаточно понятна и отражает то, что функция делает. Поведение предсказуемо, так как заявлено, что функция будет печатать информацию. Что она и делает. Аргумент принимается по константной ссылке. Значит, внутри функции он не поменяется. Нет const_cast или других подозрительных действий. Тестировать функцию сложно, так как свой результат она не возвращает пользователю, а выводит напрямую в стандартный поток вывода. На данный момент с поддерживаемостью проблем нет. Можно сказать, что функция не очень сфокусирована, так как она не только проверяет, является ли строка числом с плавающей точкой, но и разбивает число на целую и дробную часть, а также выводит результаты в поток. Возможно, стоит разделить эти действия, чтобы добавить функции сфокусированности.

Примерами хороших функций могут служить библиотечные. Каждая из них прошла множество код-ревью, испытания временем и постоянное переиспользование. Каждая протестирована. Сигнатуры таких функций тщательно продуманы. Кроме того, язык C++ постоянно развивается, и функции должны быть, с одной стороны, достаточно устойчивыми, чтобы поддерживать старые стандарты, а с другой стороны — быть готовыми к расширению и улучшению.