## Динамическое приведение типа

Оператор `static_cast` можно использовать для приведения типов в пределах иерархии классов. Однако это может привести к проблемам. 

Рассмотрим иерархию классов животных — мышей и ежей:
```cpp
class Animal {
public:
    virtual ~Animal() = default;

protected:
    int health_ = 10;
};

class Mouse : public Animal {
public:
    void EatCheese() {
        health_ += 10;
    }
};

class Hedgehog : public Animal {
public:
    void Sing(string song) {
        sing_history_.push_back(move(song));
    }

private:
    vector<string> sing_history_;
}; 
```

Дальнейшие действия будут развиваться как в следующем анекдоте:

Пришли мыши к Сове: «Сова, ты старая и мудрая. Скажи, что нам сделать, чтобы коты перестали нас ловить и есть». Сова говорит им: «Мышки, станьте ёжиками. Если вы будете колючими, вас никто не съест!»

Обалдевшие от восторга мыши побежали домой, там опомнились и вернулись к сове. «Сова, расскажи, — а как нам стать ёжиками?». А Сова им в ответ: «Я решаю важные стратегические вопросы! С тактикой разбирайтесь сами!»
```cpp
void PlayWithAnimal(Animal& animal) {
    Mouse& mouse = static_cast<Mouse&>(animal);
    cout << "Mouse eats cheese"sv << endl;
    mouse.EatCheese();

    Hedgehog& hedgehog = static_cast<Hedgehog&>(animal);
    cout << "Hedgehog sings songs"sv << endl;
    hedgehog.Sing("Jingle Bells"s);
    hedgehog.Sing("Yesterday"s);
}

int main() {
    Mouse mouse;
    PlayWithAnimal(mouse);
    cout << "---"sv << endl;
    Hedgehog hedgehog;
    PlayWithAnimal(hedgehog);
}
```
Программа скомпилируется без ошибок, однако при запуске упадёт:
```
Mouse eats cheese
Hedgehog sings songs
Segmentation fault 
```
Оператор `static_cast` можно безопасно использовать только чтобы привести тип вверх по иерархии классов. Безопасно привести тип вниз по иерархии этим оператором можно, только если известно, что объект перед вами — это экземпляр нужного класса или его наследника. В противном случае попытка обратиться к объекту по ссылке или указателю несовместимого типа приведёт к неопределённому поведению.

Внутри функции `PlayWithAnimal` неизвестно, какого типа объект был передан в функцию, ведь она способна принять любого наследника Animal.
Для безопасного приведения типа в пределах иерархии классов служит оператор `dynamic_cast`. В отличие от `static_cast`, он во время выполнения программы проверяет возможность преобразования, используя информацию о типе объекта. Такое преобразование выполняется медленнее, чем `static_cast`, зато безопаснее.

`dynamic_cast` использует служебную информацию, хранящуюся в объекте, чтобы установить его тип и выполнить нужное преобразование. Исходный класс или структура должны иметь хотя бы одну виртуальную функцию. Достаточно будет даже виртуального деструктора.

При приведении одного типа указателя к указателю другого типа возвращается ненулевой указатель, если преобразование типа возможно. В противном случае — нулевой:
```cpp
void PlayWithAnimal(Animal& animal) {
    if (Mouse* mouse = dynamic_cast<Mouse*>(&animal)) {
        cout << "Mouse eats cheese"sv << endl;
        mouse->EatCheese();
    }

    if (Hedgehog* hedgehog = dynamic_cast<Hedgehog*>(&animal)) {
        cout << "Hedgehog sings songs"sv << endl;
        hedgehog->Sing("Jingle Bells"s);
        hedgehog->Sing("Yesterday"s);
    }
}

int main() {
    Mouse mouse;
    PlayWithAnimal(mouse);
    cout << "---"sv << endl;
    Hedgehog hedgehog;
    PlayWithAnimal(hedgehog);
} 
```
Теперь функция `PlayWithAnimal` сможет во время выполнения программы определить, с каким объектом имеет дело, и выполнить над ним допустимые действия:
```
Mouse eats cheese
---
Hedgehog sings songs 
```
`dynamic_cast` позволяет преобразовывать не только указатели, но и ссылки. Так как в C++ нет понятия нулевой ссылки, при невозможности преобразования выбрасывается исключение `std::bad_cast`:
```cpp
void PlayWithAnimal2(Animal& animal) {
    try {
        // При невозможности приведения ссылки к нужному типу 
        // оператор dynamic_cast выбросит исключение std::bad_cast
        Mouse& mouse = dynamic_cast<Mouse&>(animal);
        cout << "Mouse eats cheese"sv << endl;
        mouse.EatCheese();
    } catch (const std::bad_cast&) {
    }

    try {
        Hedgehog& hedgehog = dynamic_cast<Hedgehog&>(animal);
        cout << "Hedgehog sings songs"sv << endl;
        hedgehog.Sing("Jingle Bells"s);
        hedgehog.Sing("Yesterday"s);
    } catch (const std::bad_cast&) {
    }
}
```
Приведение типа ссылок с использованием `dynamic_cast` менее предпочтительно, чем  приведение типа указателей. Исключения должны сигнализировать о внештатной ситуации, а не управлять выполнением программы.

`dynamic_cast` позволяет выполнить над объектом действия, зависящие от его типа. Но везде, где возможно, отдавайте предпочтение полиморфизму и виртуальным методам. Это делает код более гибким и не нарушает инкапсуляцию.

Для рисования фигур можно использовать `dynamic_cast`, не вводя чисто виртуальный метод `Draw` в базовом классе:

```cpp
class Shape { ... };
class Rectangle : public Shape { ... };
class Circle : public Shape { ... };

void DrawShape(const Shape& shape, Canvas& canvas) {
    if (const Rectangle* r = dynamic_cast<const Rectangle*>(&shape)) {
        // рисуем прямоугольник r на холсте canvas
    } else if (const Circle* c = dynamic_cast<const Circle*>(&shape)) {
        // рисуем окружность c на холсте canvas
    }
} 
```
Это неудачное решение с точки зрения архитектуры. Публичное наследование подразумевает поддержку полиморфизма, и от функции `DrawShape` ожидается, что она способна принимать любых `наследников` класса `Shape`. Создав новый класс-наследник `Shape`, легко забыть внести изменения в функцию `DrawShape` и множество других мест, использующих `dynamic_cast`. Из-за этого `DrawShape` будет работать неправильно, и в целом поддержка программы станет сложнее. Поэтому `dynamic_cast` нежелательно использовать в библиотеках — пользователи библиотеки лишаются возможности наследоваться от библиотечных классов, ведь о них код библиотеки ничего не знает.

Тем не менее бывают ситуации, когда `dynamic_cast` полезен:
- Если нет возможности добавить виртуальный метод в базовый класс. Например, из-за того, что это класс сторонней библиотеки. В таком случае вы можете использовать `dynamic_cast`, выполнить приведение типа к нужным классам-наследникам и вызвать специфичные для них операции.

- `dynamic_cast` позволяет запросить у объекта нужный интерфейс и в случае успеха использовать его.