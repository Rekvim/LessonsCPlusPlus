## Когда наследование — не лучший выбор

Наследование и виртуальные методы — основные способы поддержать полиморфизм времени выполнения в C++. Вы объявляете виртуальную функцию в базовом классе и переопределяете её в наследниках. После этого можно работать с классами-наследниками через интерфейс их общего предка.

Реализуется такой функционал за счёт хранения дополнительной информации с каждым объектом, который имеет виртуальные методы. В примере ниже класс `B` отличается от класса `A` только наличием виртуальных методов.
```cpp
class A {
    int32_t i;
};

class B {
    virtual ~B() = default;
    int32_t i;
};

int main() {
    using namespace std;
    cout << "sizeof(int32_t): "sv << sizeof(int32_t) << endl;
    cout << "sizeof(A): "sv << sizeof(A) << endl;
    cout << "sizeof(B): "sv << sizeof(B) << endl;
} 
```
Один из возможных вариантов вывода:
```
sizeof(int32_t): 4
sizeof(A): 4
sizeof(B): 16 
```
Конкретные цифры могут быть другими, но размер класса `B` всегда будет больше размера класса `A`.

Небольшие накладные расходы (размером примерно с указатель) на хранение каждого объекта — малая цена за функциональные возможности, которые мы получаем. Тем не менее у полиморфизма, основанного на использовании виртуальных функций, есть недостатки.

Проиллюстрируем их на гиперболизированном примере программы, решающей квадратное уравнение. Квадратное уравнение может иметь одно из следующих решений:

- Два действительных корня. Программа должна вывести оба корня.
- Один действительный корень. Программа должна вывести этот корень.
- Действительных корней нет. Программа должна сообщить об этом.

```cpp
struct Solution {
    virtual ~Solution() = default;
    virtual void Print() const = 0;
};

struct OneRoot : Solution {
    OneRoot(double v)
        : value(v) {
    }
    void Print() const override {
        cout << "One root: "sv << value << endl;
    }
    double value;
};

struct TwoRoots : Solution {
    TwoRoots(double v1, double v2)
        : value1(v1)
        , value2(v2) {
    }
    void Print() const override {
        cout << "Two roots: "sv << value1 << " and "sv << value2 << endl;
    }
    double value1, value2;
};

struct NoRoots : Solution {
    void Print() const override {
        cout << "No roots"sv << endl;
    }
};

// Возвращает корни квадратного уравнения вида ax^2+bx+c=0
unique_ptr<Solution> SolveQuadraticEquation(double a, double b, double c) {
    if (a == 0) {
        throw invalid_argument("Not a quadratic equation"s);
    }

    const double d = b * b - 4 * a * c;
    if (d > 0) {
        const double sqrt_d = sqrt(d);
        const double dbl_a = 2.0 * a;
        return make_unique<TwoRoots>((-b - sqrt_d) / dbl_a, (-b + sqrt_d) / dbl_a);
    } else if (d == 0) {
        return make_unique<OneRoot>(-b / (2 * a));
    } else {
        return make_unique<NoRoots>();
    }
}

int main() {
    const auto solution = SolveQuadraticEquation(1, 0, -4);
    solution->Print();
} 
```

Проанализируйте код программы, решающей квадратное уравнение, и выберите верные утверждения.


Неправильный ответ
Программа находит не все действительные корни уравнения.
Программа находит их все.

Правильный ответ
Иерархия классов с виртуальными методами выглядит несколько громоздкой в задаче, где достаточно более простых типов данных.
Верно. Использование наследования выглядит здесь как стрельба из пушки по воробьям.

Неправильный ответ
Программа не обрабатывает ситуацию с отсутствием корней.
Она обрабатывает и отсутствие корней, и проверяет, что уравнение — квадратное.

Неправильный ответ
В программе возможны утечки памяти.
Создаваемые в динамической памяти объекты обёрнуты в unique_ptr, своевременно удаляющий объекты при выходе из области видимости.

Правильный ответ
В программе используется динамическое выделение памяти, что приводит к снижению производительности.
make_unique создаёт объект в динамической памяти с помощью new, а деструктор unique_ptr вызывает оператор delete. Выделение и освобождение динамической памяти выполняются дольше выделения памяти в области стека.

Правильный ответ
Если потребуется выполнить другие действия над решением уравнения, придётся изменять Solution и его наследников.
В структуру Solution придётся добавить дополнительные виртуальные методы и переопределить их в классах-наследниках.

Неправильный ответ
В программе возможно неопределённое поведение из-за разыменования нулевого указателя.
Функция SolveQuadraticEquation на всех ветках своего выполнения возвращает ненулевой указатель.

Неправильный ответ
Функцию SolveQuadraticEquation можно объявить noexcept.
Функция SolveQuadraticEquation выбрасывает исключение std::invalid_argument, если переданное уравнение не квадратное. Кроме того, функция make_unique может выбросить исключение bad_alloc при нехватке памяти в куче.

Неправильный ответ
Деструктор структуры Solution можно объявить защищённым невиртуальным.
Деструктор Solution должен быть публичным виртуальным, так как функция SolveQuadraticEquation создаёт наследников Solution и возвращает умный указатель, удаляющий объект наследника через указатель на базовый класс.
Как вам задача?


В следующем уроке вы познакомитесь с простой альтернативой наследованию для поддержки полиморфизма времени выполнения в C++.