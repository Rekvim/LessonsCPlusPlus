## Конструкторы для продвинутых

Идея с комментариями, рассмотренная в прошлом уроке, глобально плоха одним моментом — программист всё ещё мог ошибиться в порядке передачи аргументов. В этом уроке вы научитесь рефакторить конструкторы так, чтобы перестать зависеть от этого порядка.

Когда вызов конструктора выглядит так, появляется проблема — параметры могут быть переданы в неправильном порядке:
```cpp
ReadingManager manager(1000, 20000, 2); 
```
Проблему можно решить созданием методов, которые определят значение конкретного параметра. Проще говоря, методов-сеттеров. Уберём параметры у конструктора и создадим такие методы:

```cpp
class ReadingManager {
public:
    ReadingManager();

    void SetMaxUserCount(int max_user_count) {
        max_user_count_ = max_user_count;
    }
    
    void SetMaxPageCount(int max_page_count) {
        max_page_count_ = max_page_count;
    }
    
    void SetCheerFactor(double cheer_factor) {
        cheer_factor_ = cheer_factor;
    }
    ...
private:
   int max_user_count_ = 0;
   int max_page_count_ = 0;
   double cheer_factor_ = 0;
};
```
Теперь подготовка объекта класса `ReadingManager` будет выглядеть так:
```cpp
ReadingManager manager;
manager.SetMaxUserCount(20000);
manager.SetMaxPageCount(1000);
manager.SetCheerFactor(2); 
```
Пока всё в порядке, но вдруг кто-нибудь из пользователей решил вызвать другие методы класса `ReadingManager` до вызова сеттеров:
```cpp
ReadingManager manager;
manager.Read(0, 1);
```
Пользователь прав. Ничего не мешает ему сделать именно так. Но это добавляет нам проблем. Каких?

> — Теперь после вызова конструктора объект на самом деле не сконструирован до конца, использование его методов вызывает неопределённое поведение. Верно, после вызова конструктора объект не готов к работе, а это противоречит самой идее конструктора.

> — Нужно переписывать другие методы класса. Ведь если вызвать другие методы с нулевыми значениями для max_user_count_ и других полей, алгоритм не будет работать.

Такой способ рефакторинга может работать, но, как видите, он тоже не идеален. Продолжим улучшать код в следующем уроке.

Сформулируем точнее проблему, которая возникла в конце прошлого урока. У объекта ReadingManager есть две фазы жизненного цикла: инициализация и использование. Использование невозможно до окончания инициализации. Нужно разделить эти две фазы, чтобы гарантировать их непересечение.

Проблема сформулирована, решим её. Выделим отдельный класс для инициализации и назовём его `ReadingManagerBuilder`:
```cpp
class ReadingManagerBuilder {
public:
    void SetMaxUserCount(int max_user_count) {
        max_user_count_ = max_user_count;
    }

    void SetMaxPageCount(int max_page_count) {
        max_page_count_ = max_page_count;
    }

    void SetCheerFactor(double cheer_factor) {
        cheer_factor_ = cheer_factor;
    }

    ReadingManager Build() const {
        if (max_user_count_ <= 0) {
            // ...
        }
        return {max_user_count_, max_page_count_, cheer_factor_};
    }

private:
    int max_user_count_;
    int max_page_count_;
    double cheer_factor_;
};
```
Теперь можно вернуть на место конструктор `ReadingManager` с тремя параметрами. Однако сделать это нужно хитро. Программист бы не хотел, чтобы обычный пользователь вызывал этот конструктор. Но у `ReadingManagerBuilder` должно получиться.

Какое ключевое слова можно применить в этом случае? — `friend`.


Ключевое слово `friend` разрешит методам класса `ReadingManagerBuilder` доступ к секции `private` класса `ReadingManager`.

Выглядеть это будет так:
```cpp
class ReadingManager {
public:
    friend class ReadingManagerBuilder;
    ...

private:
    vector<int> user_page_counts_;
    vector<int> page_achieved_by_count_;
    double cheer_factor_= 0;


    ReadingManager(int max_user_count, int max_page_count, double cheer_factor)
        : user_page_counts_(max_user_count + 1, -1),
          page_achieved_by_count_(max_page_count + 1, 0),
          cheer_factor_(cheer_factor)
    {
    }

    ...
};
```
Теперь пользователь надёжно защищён от недоразумений:
```cpp
ReadingManagerBuilder builder;
builder.SetMaxUserCount(20000);
builder.SetMaxPageCount(1000);
builder.SetCheerFactor(2);
ReadingManager manager = builder.Build(); 
```

И какой тип должны возвращать сеттеры, чтобы пользователь мог сконструировать объект `ReadingManager` так?
```cpp
ReadingManager manager = 
    ReadingManagerBuilder().SetMaxUserCount(20000).SetMaxPageCount(1000).SetCheerFactor(2).Build(); 
```
> — ReadingManagerBuilder&

Возвращение ссылки на текущий объект `ReadingManagerBuilder&` позволит реализовать приём, называемый Fluent interface.

Вернёмся к изначальной проблеме. Ради её решения возникла идея сеттеров.

Пользователь мог перепутать параметры конструктора местами, и понимание вызова конструктора вызывало трудности. После рефакторинга, проведённого в рамках этого урока, программисту больше не надо контролировать порядок аргументов конструктора.