## Собираем CMake'ом

Итак, CMake установлен. Но сам собирать он не может, потребуется компилятор. CMake — универсальная система, которая может работать с любым современным компилятором. Команды сборки могут немного различаться в зависимости от того, какая у вас операционная система и чем вы собираете программы. Если это Windows, то в качестве консоли используйте консоль MinGW с компилятором GCC.

### Создаём первый CMake-проект

Проект CMake задаётся текстовым файлом CMakeLists.txt. Начать его нужно с описания минимальной версии CMake. Также в начале зададим название проекта и его язык программирования:
```
cmake_minimum_required(VERSION 3.11)

project(HelloCMake CXX)
set(CMAKE_CXX_STANDARD 17) 
```
В этом коде задан только один параметр языка, `CXX`, что соответствует C++. Команда `set`, идущая после `project`, предназначена для присвоения значения переменной. Здесь она задаёт переменную `CMAKE_CXX_STANDARD`, показывая, что мы хотим использовать стандарт C++17.

CMakeLists.txt определяет цели. В терминологии CMake — target. Например, сборка исполняемого файла — это цель. Если проект предназначен для сборки одной программы, вероятно, он состоит из одной цели. Чтобы добавить цель CMake для создания исполняемого файла, воспользуемся командой `add_executable`. Ей нужно сообщить название цели и список файлов исходного кода:
```
cmake_minimum_required(VERSION 3.11)

project(HelloCMake CXX)
set(CMAKE_CXX_STANDARD 17)

# добавляем цель hello для сборки исполняемого файла
# hello.exe под Windows, hello под Linux и macOS
add_executable("hello" "src/main.cpp" "src/hello_printer.h" "src/hello_printer.cpp") 
```

Мы вызвали команду `add_executable`, сообщив ей четыре параметра. В отличие от C++ параметры разделяются не запятой, а просто пробелом.

Если параметр команды не содержит пробелов, кавычки можно не писать:

```
add_executable(hello src/main.cpp src/hello_printer.h src/hello_printer.cpp) 
```
Помимо cpp-файлов мы указали ещё и заголовки *.h, которые компилировать не нужно. CMake сам определит, какие файлы подлежат сборке. Перечисляйте все исходные файлы.

Программа состоит из трёх файлов, пути к которым указаны относительно расположения файла CMakeLists.txt:
```
// main.cpp
#include "hello_printer.h"

int main() {
    PrintHelloCMake();
}

// hello_printer.h
#pragma once

void PrintHelloCMake();

// hello_printer.cpp
#include <iostream>
#include <string_view>

using namespace std;

void PrintHelloCMake() {
    cout << "Hello, CMake!"sv << endl;
} 
```
Для сборки проекта понадобится отдельная папка, в которой будут размещаться вспомогательные файлы CMake, промежуточные файлы компиляции и итоговая программа. Важно, чтобы эта папка не совпадала с папкой, где размещён исходный код, чтобы не засорять её лишними файлами. Создадим папку hello_cmake_build. Структура каталогов может получиться такой:
```
cmake_project/
├── hello_cmake/ # папка с исходным кодом
│   ├── src/ # вспомогательная папка для структурирования исходного кода
│   │   ├── hello_printer.cpp
│   │   ├── hello_printer.h
│   │   └── main.cpp
│   └── CMakeLists.txt # файл проекта CMake
└── hello_cmake_build/ # папка для сборки
    └── # тут будут файлы сборки 
```
В консоли перейдите в папку hello_cmake_build и выполните команды:

```
cmake ../hello_cmake
cmake --build . 
```
Первая нужна для создания файлов сборки, а вторая — для самой сборки. CMake не может собирать проекты напрямую. Для начала он создаёт сценарий сборки или проект для IDE одним из генераторов. Это делает команда `cmake ../hello_cmake`. В качестве параметра мы указали путь к папке, в которой находится CMakeLists.txt. Мы воспользовались генератором по умолчанию. Под Windows используйте генератор "MinGW Makefiles". Команда запуска будет выглядеть так:
```
cmake ../hello_cmake -G "MinGW Makefiles"
cmake --build .
```
Вторая команда — универсальный механизм, позволяющий выполнить сборку. Тут можно было бы обойтись без CMake: он сгенерировал сценарий, который выполнится соответствующим инструментом. Но конкретные команды будут зависеть от генератора, а так мы запрашиваем сборку универсальным способом. В качестве параметра CMake, помимо ключа `--build`, указана директория, содержащая сборочные файлы — в данном случае указана `.`, то есть текущая директория.

Если всё прошло успешно, CMake отчитается о создании исполняемого файла `hello`, или `hello.exe` под Windows. Если вы собираете под `MinGW`, то нужно явно попросить компоновать стандартную библиотеку. Для этого в CMakeLists.txt добавим волшебную команду:

```
target_link_libraries(hello -lstdc++) 
```

<div class="callout info">
Eсли проблемы под MinGW не решились, попробуйте обновить GCC. Для этого запустите команду `pacman -Syu` и на все вопросы отвечайте клавишей Enter. Иногда нужно проделать эту операцию несколько раз.
</div>

Запустим полученную программу и увидим долгожданное сообщение:
```
Hello, CMake!
```
Простейшая программа с использованием CMake готова.

### Генераторы и конфигурации

Как говорилось выше, CMake поддерживает разные генераторы — он может создать проекты для различных IDE и Makefile для компиляции без IDE. Можно посмотреть список всех генераторов, доступных на вашей системе, введя команду `cmake -G`.

Меняя команду генерации, можно создавать проект под определенную IDE. Например, для проекта Eclipse CDT надо вызывать генератор "Eclipse CDT4 - MinGW Makefiles". Прежде чем использовать новый генератор, нужно перейти в папку hello_cmake_build и очистить её содержимое.

Для поддержки CMake-проектов в VS Code установите дополнения CMake и Cmake Tools.

CMake позволяет собирать программы с нужной конфигурацией. Чтобы задать конфигурацию, нужно добавить дополнительный параметр `-DCMAKE_BUILD_TYPE=...` при генерации файлов сборки и выбрать одну из четырёх поддерживаемых конфигураций:

- Release — сборка с полной оптимизацией и без отладочной информации, предназначена для конечного пользователя.

- Debug — сборка без оптимизации и с отладочной информацией.

- RelWithDebInfo — сборка с оптимизацией и с отладочной информацией. Нужна, если в Release версии есть баги, которые не получается выявить в Debug версии.

- MinSizeRel — аналог Release, но оптимизируется в первую очередь размер итогового файла, а не скорость. Имеет смысл для сборки программ под устройства, у которых жёстко ограничено дисковое пространство.

Запустите команду генерации проекта заново, выбрав отладочную конфигурацию:
```
cmake ../hello_cmake -DCMAKE_BUILD_TYPE=Debug 
```
Поскольку в этой папке уже были сгенерированы файлы, второй раз указывать генератор параметром `-G` не нужно. Для конфигураций Release и Debug создайте отдельные директории. Если выполняете эту команду в новой папке, где ещё не запускался CMake, придётся помимо конфигурации указать и генератор.

Параметр `-DCMAKE_BUILD_TYPE=...` имеет смысл для различных генераторов, но некоторые IDE интегрированы с CMake лучше и поддерживают смену конфигурации из интерфейса, без перегенерации:
 
- Visual Studio — генератор для этой IDE создаёт универсальный проект, позволяющий выполнить сборку в любой конфигурации.

- QT Creator — позволяет открыть файл CMakeLists.txt напрямую, не требует запуска команд из консоли.

- CLion — как и QT Creator, поддерживает непосредственное открытие проекта CMake.

Вы узнали, как создавать проект CMake, как генерировать сценарии сборки и проекты, и как, в конце концов, собирать программу. Теперь используйте эти знания при решении задачи.