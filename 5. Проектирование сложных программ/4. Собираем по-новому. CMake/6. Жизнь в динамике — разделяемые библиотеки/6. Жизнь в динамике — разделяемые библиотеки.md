## Жизнь в динамике — разделяемые библиотеки

Статическая библиотека встраивается прямо в вашу программу. Динамическая, или разделяемая библиотека остаётся отдельно. Как кошка, которая гуляет сама по себе. Это даёт некоторые преимущества, но минусов также хватает.

Какие плюсы есть у динамической библиотеки? Отметьте один или несколько вариантов.


> Возможна экономия места на диске компьютера. Если много программ используют одну и ту же библиотеку, нет необходимости встраивать её код в каждую программу. Это может экономить место. В операционных системах с поддержкой пакетов можно не распространять с программой библиотеку. Достаточно информации о том, какой пакет нужно установить, чтобы она появилась.

> Можно подгружать библиотеки во время выполнения. Можно загружать библиотеку, которой не было при компиляции. Это позволяет писать плагины и расширения библиотеки.
Как вам задача?


Ещё один плюс динамической библиотеки — она самодостаточна. В ней явно указывается, какие функции должны быть экспортированы, и компоновщик убеждается, что все необходимые зависимости в наличии. Функции, не определённые для экспорта, могут быть скрыты. Всё, что определено внутри библиотеки, остаётся внутри библиотеки. За исключением явно экспортированных функций. Это обеспечивает лучшее сокрытие для несвободного кода, а также более наглядный интерфейс.

Под Linux и MinGW динамическая библиотека задаётся файлом с расширением so, под Windows — DLL, под macOS — dylib.
Какие минусы есть у динамической библиотеки?

> Могут быть конфликты, если две программы используют две разных версии одной библиотеки. Одна из библиотек запишется поверх другой, и, возможно, одна из программ будет работать неправильно. В операционных системах предусмотрена версионность, позволяющая иметь разные версии библиотеки одновременно, либо возможность хранить библиотеку в директории программы.

> Без библиотеки запустить программу не удастся. Это распространённая проблема — например, библиотеку забыли cкопировать.

> Операционная система может не найти библиотеку, даже если она есть. Не факт, что библиотека лежит в правильном месте, правильно прописаны переменные окружения и конфигурационные файлы.


Есть ещё один минус — экспорт не прописан в стандарте, и его использование различается в зависимости от операционной системы. Экспорт классов вообще поддерживается не всеми компиляторами, поэтому типичная библиотека экспортирует только структуры без методов и функции. Более того, лучше, чтобы эти функции не принимали объекты STL, например `string` или контейнеры, ведь ваш so или dll-файл может быть передан туда, где стандартная библиотека другая. Но всё это обеспечивает лучшее сокрытие кода и даже в некотором смысле большую прозрачность за счёт более плоской и простой структуры.

Компоновка тоже различается в зависимости от компилятора и операционной системы. Для компоновщика GCC нужно указать сам so-файл, а при сборке в Visual Studio или Clang под Windows — специальный lib-файл, который идёт в паре с DLL. Этот lib-файл — обёртка для использования DLL и фактически не содержит реализаций никаких функций.

Как уже говорилось, другой вариант использования DLL — загрузка во время выполнения. В этом случае при сборке программы библиотека вообще не указывается. Этот способ нестандартный, и мы не будем его касаться.

### Создаём динамическую библиотеку

Пришло время создать библиотеку только из функций по всем канонам. Далеко ходить не будем: модифицируем ImgLib. Весь её код мы оставим — он будет скомпилирован и спрятан внутри библиотеки. Напишем интерфейс в файле imglib_dll_interface.h:

```cpp
#pragma once
#include <cstddef>

// в этом файле определён макрос IMGLIB_EXPORT
#include "imglib_dll_defines.h"

// Даже в динамической библиотеке можно определять простые структуры.
// Так как имя функции должно быть простым идентификатором,
// namespace использовать нельзя. Поэтому все имена снабдим 
// префиксом ImgLib
struct ImgLibSize {
    int width;
    int height;
};

struct ImgLibColor {
    // inline-метод также допустим, но вынести определение в cpp-файл
    // не получится
    static ImgLibColor Black() {
        return {std::byte{0}, std::byte{0}, std::byte{0}, std::byte{255}};
    }
    std::byte r, g, b, a;
};

// Определения этого класса в интерфейсе не будет.
// Но указатель на него тем не менее использовать можно.
class ImgLibImage;

// Так теперь выглядит "конструктор" изображения.
// Любое сконструированное изображение необходимо 
// будет удалить функцией ImgLibImgFree
IMGLIB_EXPORT ImgLibImage* ImgLibImgCreate(int width, int height, ImgLibColor fill);
IMGLIB_EXPORT void ImgLibImgFree(ImgLibImage* img);

// Перед всеми экспортируемыми функциями явно пишем IMGLIB_EXPORT.
// Когда будем включать этот файл при использованиии библиотеки, макрос 
// будет определён по-другому
IMGLIB_EXPORT int ImgLibImgGetWidth(const ImgLibImage* img);
IMGLIB_EXPORT int ImgLibImgGetHeight(const ImgLibImage* img);
IMGLIB_EXPORT int ImgLibImgGetStep(const ImgLibImage* img);
IMGLIB_EXPORT bool ImgLibImgIsInited(const ImgLibImage* img);
IMGLIB_EXPORT ImgLibColor ImgLibImgGetPixelConst(const ImgLibImage* img, int x, int y);
IMGLIB_EXPORT ImgLibColor& ImgLibImgGetPixel(ImgLibImage* img, int x, int y);
IMGLIB_EXPORT const ImgLibColor* ImgLibImgGetLineConst(const ImgLibImage* img, int line);
IMGLIB_EXPORT ImgLibColor* ImgLibImgGetLine(ImgLibImage* img, int line);

IMGLIB_EXPORT ImgLibImage* ImgLibLoadPPM(const char* path);

// inline-функция может быть определена явно,
// она не будет экспортирована.
inline void ImgLibUnloadPPM(ImgLibImage* image) {
    ImgLibImgFree(image);
}

// Здесь мы использовали const char* вместо std::filesystem::path,
// поскольку классы стандартной библиотеки в интерфейсе библиотеки нежелательны -
// они могут различаться при компиляции библиотеки и программы, её
// использующей.
IMGLIB_EXPORT bool ImgLibSavePPM(const char* path, const ImgLibImage* image); 
```

В файле imglib_dll_defines.h определим всю магию, обеспечивающую экспорт функций из библиотеки:

```cpp
#pragma once

#if defined _WIN32 || defined __CYGWIN__ || defined __MINGW32__
    #ifdef IMGLIB_DLL
        #ifdef __GNUC__
            #define IMGLIB_EXPORT_DECL __attribute__ ((dllexport))
        #else
            #define IMGLIB_EXPORT_DECL __declspec(dllexport)
        #endif
    #else
        #ifdef __GNUC__
            #define IMGLIB_EXPORT_DECL __attribute__ ((dllimport))
        #else
            #define IMGLIB_EXPORT_DECL __declspec(dllimport)
        #endif
    #endif
#else
    #define IMGLIB_EXPORT_DECL __attribute__ ((visibility ("default")))
#endif

#define IMGLIB_EXPORT extern "C" IMGLIB_EXPORT_DECL 
```
Как видно, код сильно зависит от операционной системы и компилятора. Подробно разбирать его не будем. Макрос IMGLIB_DLL определим через CMake-файл только во время сборки библиотеки и не будем определять во время сборки программы, использующей её. Благодаря этому при экспорте и импорте получим разные атрибуты функций.

Вот и весь интерфейс, который будет предоставлен пользователю библиотеки. Теперь перейдём к подкапотной части — связке между существующим кодом и интерфейсом. Нужно реализовать все функции в imglib_dll_interface.cpp:
```cpp
#include "img_lib.h"
#include "ppm_image.h"
#include "imglib_dll_interface.h"

#include <cassert>

struct ImgLibImage {
    img_lib::Image img;
};

ImgLibImage* ImgLibImgCreate(int width, int height, ImgLibColor fill) {
    img_lib::Image image(width, height, reinterpret_cast<img_lib::Color&>(fill));
    return new ImgLibImage{std::move(image)};
}

void ImgLibImgFree(ImgLibImage* img) {
    delete img;
}

int ImgLibImgGetWidth(const ImgLibImage* img) {
    assert(img);
    return img->img.GetWidth();
}

int ImgLibImgGetHeight(const ImgLibImage* img) {
    assert(img);
    return img->img.GetHeight();
}

int ImgLibImgGetStep(const ImgLibImage* img) {
    assert(img);
    return img->img.GetStep();
}

bool ImgLibImgIsInited(const ImgLibImage* img) {
    return img && img->img;
}

ImgLibColor ImgLibImgGetPixelConst(const ImgLibImage* img, int x, int y) {
    assert(img);
    img_lib::Color val = img->img.GetPixel(x, y);
    ImgLibColor& dll_val = reinterpret_cast<ImgLibColor&>(val);
    return dll_val;
}

ImgLibColor& ImgLibImgGetPixel(ImgLibImage* img, int x, int y) {
    assert(img);
    return reinterpret_cast<ImgLibColor&>(img->img.GetPixel(x, y));
}

const ImgLibColor* ImgLibImgGetLineConst(const ImgLibImage* img, int line) {
    assert(img);
    return reinterpret_cast<const ImgLibColor*>(img->img.GetLine(line));
}

ImgLibColor* ImgLibImgGetLine(ImgLibImage* img, int line) {
    assert(img);
    return reinterpret_cast<ImgLibColor*>(img->img.GetLine(line));
}

ImgLibImage* ImgLibLoadPPM(const char* path) {
    img_lib::Image loaded = img_lib::LoadPPM(path);
    if (!loaded) {
        return nullptr;
    }

    return new ImgLibImage{std::move(loaded)};
}

bool ImgLibSavePPM(const char* path, const ImgLibImage* image) {
    assert(image);
    return img_lib::SavePPM(path, image->img);
}
```
Тут используется преобразование `reinterpret_cast`. Это строгая и безальтернативная команда компилятору посмотреть на данные одного типа по-новому. В частности, она может преобразовать любые указатели к любым, при этом не меняя сам адрес. У начинающих разработчиков, вполне возможно, будет соблазн часто использовать `reinterpret_cast`, чтобы заставить программу компилироваться. Но применять его стоит лишь в крайних случаях, поскольку главное в программировании — надёжность. Здесь мы уверены, что `ImgLibColor` и `img_lib::Color` имеют одинаковую структуру, поэтому можем преобразовать указатели на эти типы друг к другу.

Все функции очень короткие. Они — всего лишь обёртки над другими функциями, написанными ранее. `ImgLibImage` можно реализовать и так:
```cpp
class ImgLibImage : public img_lib::Image {
public:
    using Image;
};
```

Наследование — страшная сила. Его лучше не использовать не по назначению и в случаях, когда его можно заменить инкапсуляцией. Поэтому в примере `ImgLibImage` реализован по-другому.
Что в этом коде делает конструкция using Image;?

> Добавляет в класс `ImgLibImage` конструкторы базового класса.

Код библиотеки написан. Осталось две вещи:

- собрать;
  
- использовать.
  
Собирать будем, конечно же, через CMake. Создание динамической библиотеки похоже на создание статической, только при добавлении цели командой `add_library` напишем слово `SHARED` вместо `STATIC`. Модифицируем файл CMakeLists.txt, уже существующий для сборки статической библиотеки, и добавим в него цель для сборки динамической:
```cmake
cmake_minimum_required(VERSION 3.11)

project(ImgLib CXX)
set(CMAKE_CXX_STANDARD 17)

set(IMGLIB_MAIN_FILES img_lib.h img_lib.cpp)
set(IMGLIB_FORMAT_FILES ppm_image.h ppm_image.cpp)

add_library(ImgLib STATIC ${IMGLIB_MAIN_FILES} 
            ${IMGLIB_FORMAT_FILES})

if (CMAKE_SYSTEM_NAME MATCHES "^MINGW")
    set(SYSTEM_LIBS -lstdc++)
else()
    set(SYSTEM_LIBS)
endif()

# создаём динамическую библиотеку из трёх файлов
# цель назовём ImgLibDll
add_library(ImgLibDll SHARED
            imglib_dll_interface.h 
            imglib_dll_interface.cpp
            imglib_dll_defines.h)

# При компоновке динамической библиотеки будем использовать статическую.
# Для этого добавим к ней цель ImgLib
target_link_libraries(ImgLibDll ImgLib ${SYSTEM_LIBS})

# определяем для сборки ImgLibDll макрос IMGLIB_DLL,
# чтобы экспорт функций получился правильным
target_compile_definitions(ImgLibDll PRIVATE IMGLIB_DLL)
```

Так как динамическая библиотека компонуется, в отличие от статической, которая просто архивируется, пришлось применить знакомый трюк с -lstdc++ в MinGW.

Создайте директорию build для сборки библиотеки и выполните в ней следующие команды:
```
cmake ../ImgLib -DCMAKE_BUILD_TYPE=Debug
cmake --build . 
```
Если всё успешно, CMake отчитается о создании файла `libImgLibDll.so` или `libImgLibDll.dll` и припишет к имени цели префикс `lib` и расширение. Формат этого файла — ELF. Расшифровывается как executable and linkable format — «исполняемый и компонуемый формат».

Посмотрим, какие символы определяет собранная динамическая библиотека. Под Linux это можно сделать командой `nm -gD libImgLibDll.so`, а под Windows — программой Dependency Walker или её современным аналогом [Dependencies](https://github.com/lucasg/Dependencies). Откроем в ней указанную библиотеку:

![alt text](image.png)

В окне программы можно увидеть все библиотеки, от которых зависит `libImgLibDll.so`, а также все символы, которые она экспортирует.

### Используем динамическую библиотеку

На основе динамической библиотеки напишем программу для изменения яркости изображения. Разместим код в папке LumaCorr рядом с ImgLib. Программа будет использовать динамическую библиотеку ImgLibDll.

Изменение яркости — это умножение каждой компоненты цвета на некоторое число с плавающей точкой. Число будет задаваться через аргументы командной строки. Код программы с использованием динамической библиотеки ImgLibDll выглядит так:
```
// файл нашей библиотеки включаем через угловые скобки, прямо как файлы stdlib
#include <imglib_dll_interface.h>

#include <algorithm>
#include <iostream>
#include <string_view>

using namespace std;

byte Multiply(byte component, double multiplier) {
    const double res = static_cast<double>(component) * multiplier;
    return static_cast<byte>(clamp(res, 0., 255.));
}

ImgLibColor Multiply(ImgLibColor color, double multiplier) {
    return {Multiply(color.r, multiplier), 
            Multiply(color.g, multiplier), 
            Multiply(color.b, multiplier), color.a};
}

int main(int argc, const char** argv) {
    if (argc != 4) {
        cerr << "Expected 3 arguments: input name, output name, luma multiplier"sv << endl;
        return 1;
    }

    double multiplier = atof(argv[3]);

    ImgLibImage* image = ImgLibLoadPPM(argv[1]);

    // Проверку указателя на равенство nullptr
    // можно выполнять операцией !
    if (!image) {
        cerr << "Incorrect PPM image file"sv << endl;
        return 2;
    }

    for (int y = 0; y < ImgLibImgGetHeight(image); ++y) {
        auto line = ImgLibImgGetLine(image, y);
        for (int x = 0; x < ImgLibImgGetWidth(image); ++x) {
             line[x] = Multiply(line[x], multiplier);
        }
    }

    if (!ImgLibSavePPM(argv[2], image)) {
        cerr << "Saving PPM image failed"sv << endl;
        ImgLibUnloadPPM(image);
        return 3;
    }

    // Из-за примитивного интерфейса библиотеки выгружать изображение приходится
    // вручную, причём при каждом выходе из функции. Можно написать обёртку
    // над обёрткой, но в такой маленькой программе обойдёмся без неё
    ImgLibUnloadPPM(image);
} 
```
Компоновка с динамической библиотекой ничем по сути не отличается от компоновки статической. Более того, если для библиотеки BeautifulLibrary есть оба файла: l`ibBeautifulLibrary.a` и `libBeautifulLibrary.so`, компоновщик сможет выбрать из них. По умолчанию выбирается динамическая библиотека, однако это поведение можно настраивать параметрами компоновщика.

Как и со статической библиотекой, имеются два варианта: 

- когда у вас есть исходный код и файл CMakeLists.txt — через импорт цели;

- когда есть только собранные файлы и заголовок — через явное указание библиотеки.

Будем использовать второй вариант, поэтому нужно заранее подготовить пакет ImgLibDll со следующей структурой:
```
ImgLibDll/
├── include/
│   ├── imglib_dll_defines.h
│   └── imglib_dll_interface.h
└── lib/
    └── libImgLibDll.so (или libImgLibDll.dll.a) 
```
Под Windows в компиляторах Clang и Visual C++ вместо DLL-файла при компоновке указывается парный ему Lib-файл `libImgLibDll.dll`.a,` который генерируют эти компиляторы во время сборки библиотеки DLL. Под Linux, macOS и MinGW можно компоновать программу прямо с so-файлом.

Как и в случае со статической библиотекой, полный путь к папке `ImgLibDll` будем задавать через переменную кэша CMake. Но, в отличие от статической библиотеки, для динамической собирать отдельно Debug и Release версии не нужно — все функции имеют простые интерфейсы, в которых нет возможности для конфликта. Можно собирать библиотеку сразу в конфигурации Release. Конфигурация Debug может быть полезна — GDB или другой отладчик позволит заходить внутрь функций библиотеки, если доступна отладочная информация.

Код файла CMakeLists.txt будет таким:
```cmake
cmake_minimum_required(VERSION 3.11)

project(LumaCorr CXX)
set(CMAKE_CXX_STANDARD 17)

set(IMGLIB_DLL_DIR CACHE STRING "ImgLibDll shared library directory")

if(NOT IMGLIB_DLL_DIR)
    message(FATAL_ERROR "Please, specify ImgLibDll directory via -DIMGLIB_DLL_DIR=<dir>")
endif()
message(STATUS "ImgLibDll dir is ${IMGLIB_DLL_DIR}, change via -DIMGLIB_DLL_DIR=<dir>")

if (CMAKE_SYSTEM_NAME MATCHES "^MINGW")
    set(SYSTEM_LIBS -lstdc++)
else()
    set(SYSTEM_LIBS)
endif()

add_executable(lumacorr main.cpp)

target_include_directories(lumacorr PUBLIC "${IMGLIB_DLL_DIR}/include")

# В команде target_link_libraries нужно указать полный путь к файлу библиотеки
if(EXISTS "${IMGLIB_DLL_DIR}/lib/libImgLibDll.dll.a")
    target_link_libraries(lumacorr "${IMGLIB_DLL_DIR}/lib/libImgLibDll.dll.a" ${SYSTEM_LIBS})
else()
    target_link_libraries(lumacorr "${IMGLIB_DLL_DIR}/lib/libImgLibDll.so" ${SYSTEM_LIBS})
endif() 
```
Создайте папку для сборки — build_luma_corr и запустите в ней команды:
```
cmake ../LumaCorr -DIMGLIB_DLL_DIR=<полный путь к папке с библиотекой ImgLibDll> 
-DCMAKE_BUILD_TYPE=Debug
cmake --build . 
```
Если вы собираете под Windows, обратите внимание на указание пути к папке с библиотекой. Используйте прямые слеши /. При генерации проекта выводится сообщение “ImgLibDll dir is ...”. Убедитесь, что путь до библиотеки указан верный.

После успешного прохождения сборки попробуем запустить программу. Вместо изображения получим сообщение об ошибке:
```
error while loading shared libraries: libImgLibDll.so: cannot open shared object file: No such file or directory 
```
Программа потеряла самостоятельность и теперь не может жить без библиотеки. Есть только один способ это исправить — заставить операционную систему найти требуемый файл. И тут опять различия.

Под Windows файл библиотеки будет искаться:
- в системных папках,
- в папке с программой,
- в текущей папке,
- в папках из переменной окружения PATH.

Под Linux и macOS:

- в системных папках,
- в папках из переменной окружения LD_LIBRARY_PATH.

В консоли Linux или macOS можно добавить к директориям поиска текущую папку такой командой: 
```
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:. 
```
Осталось положить `libImgLibDll.so` или `libImgLibDll.dll` в текущую папку. Под Windows этого достаточно и без изменения `LD_LIBRARY_PATH`.

Запустим программу и скорректируем яркость изображения со множителями 0.5 и 2:

![alt text](image-1.png)

Попробуем скорректировать другое изображение, уменьшив яркость в 50 раз. Получим зияющую черноту:

![alt text](image-2.png)

Соберите динамическую библиотеку ImgLib и программу LumaCorr из прилагаемого архива. Увеличьте яркость этого изображения, чтобы узнать, чем занимается котик на фотографии. После уменьшения и восстановления яркости изображение неизбежно потеряет в качестве. Тёмное изображение в формате PPM вы также найдёте в архиве.

[imglib_dll_lumacorr.zip](imglib_dll_lumacorr_23.zip)

Восстановите яркость изображения и скажите какой язык программирования изучает котик. Ответ запишите маленькими латинскими буквами.

> Этот котик заинтересовался языком Rust.

Вы создали свою динамическую библиотеку и ощутили различия со статической. В следующем уроке нужно будет применить стороннюю библиотеку, написанную с использованием инструментария Autotools.