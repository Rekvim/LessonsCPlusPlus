## Разрабатываем статическую библиотеку
Начнём со статических библиотек. Они более просты, а главное — практически не меняют процесс написания кода. С точки зрения компоновщика, библиотеки как будто и нет.
Создаём статическую библиотеку
Вспомните этапы сборки программы и расположите их в правильном порядке.

1 Препроцессирование


2 Компиляция

3 Компоновка

Вначале препроцессор обрабатывает C++ файлы, подставляет макросы и include-файлы. Затем компилятор независимо компилирует каждую единицу трансляции, получая объектный файл. На последнем этапе компоновщик объединяет все объектные файлы и выдаёт один файл — исполняемый. А может быть, динамическую библиотеку, но об этом в следующем уроке.

Для статических библиотек компоновка не требуется. Компилятор C++ получает на вход cpp-файлы и каждый из них превращает в объектный файл, специфичный для платформы и компилятора. Можно объединить несколько объектных файлов в один архив, и получится статическая библиотека. Вот и всё!

Под Linux статическая библиотека имеет расширение .a. Такой архив создаётся утилитой `ar`. При использовании CMake или IDE вам не придётся иметь с ней дело напрямую. В тулсете Visual Studio статическая библиотека имеет расширение .lib, но архивы также поддерживаются.

Статическая библиотека вероятно собрана не в то время и не в том месте, в котором собирается программа. Поэтому нужно проявлять некоторую осторожность и следить, чтобы библиотека была совместима с вашей программой: собрана тем же или совместимым компилятором, зависела от такой же стандартной библиотеки и имела ту же конфигурацию. Иначе окажется, что библиотека имеет другой `string`, `map` или `vector` — и добро пожаловать, неопределённое поведение.

Что ж, приступим к созданию библиотеки! Сохраним в папку ImgLib файлы, созданные на прошлых уроках:

- img_lib.h
- img_lib.cpp
- ppm_image.h
- ppm_image.cpp

К ним добавим файл CMakeLists.txt с таким содержимым:
```cmake
cmake_minimum_required(VERSION 3.11)

project(ImgLib CXX)
set(CMAKE_CXX_STANDARD 17)

set(IMGLIB_MAIN_FILES img_lib.h img_lib.cpp)
set(IMGLIB_FORMAT_FILES ppm_image.h ppm_image.cpp)

add_library(ImgLib STATIC ${IMGLIB_MAIN_FILES} ${IMGLIB_FORMAT_FILES}) 
```
Обратите внимание, что вместо `add_executable` цель создаётся командой `add_library` с параметром `STATIC`. А в списке исходных файлов отсутствует `main.cpp`.

Создадим рядом с папкой ImgLib папку build и выполним в ней следующие команды:
```cmake
cmake ../ImgLib -DCMAKE_BUILD_TYPE=Debug
cmake --build . --verbose 
```
Под Windows рекомендуется выполнять их из консоли MinGW. 

Параметр `--verbose` указан, чтобы в процессе работы CMake увидеть, как запускается утилита `ar` для создания архива:
```
ar qc libImgLib.a CMakeFiles/ImgLib.dir/img_lib.cpp.obj CMakeFiles/ImgLib.dir/ppm_image.cpp.obj 
```
Полученный файл называется `libImgLib.a`, к названию библиотеки приписан префикс `lib` и расширение `.a` — так именует библиотеки GCC. Файл можно открыть универсальным архиватором. Сделав это, увидим в архиве три файла:

![alt text](image.png)

Два из них — объектные файлы нашей библиотеки. Третий — таблица символов для облегчения работы компоновщика.

Программа собралась корректно, хотя в ней не было функции main. В этом и смысл библиотек. Без точки входа запустить её не получится, можно только встраивать в другие программы.

### Используем статическую библиотеку как зависимую

Создадим программу для шифрования изображений. Она просто поменяет пиксели местами. Благодаря этому шифр будет изображением такого же размера и даже с такой же гистограммой.

Состоит она из одного файла main.cpp, который мы сохраним в папку Cypher, расположенную рядом с ImgLib:
```cpp
// файл библиотеки включаем через угловые скобки, прямо как файлы stdlib
#include <ppm_image.h>

#include <algorithm>
#include <numeric>
#include <iostream>
#include <string_view>
#include <random>

using namespace std;

// Свой велосипед для получения равномерно распределённого числа от 0 до max - 1.
// В отличие от uniform_int_distribution его результат будет одинаковым на всех платформах
template <typename Engine>
uint32_t GetRandomNumber(uint32_t max, Engine& engine) {
    uint32_t engine_max = static_cast<uint32_t>(engine.max());

    if (max == engine_max) {
        return static_cast<uint32_t>(engine());
    }

    while (true) {
        uint32_t val = static_cast<uint32_t>(engine());

        if (val / max < engine_max / max || engine_max % max == max - 1u) {
            return val % max;
        }
    }
}

// У нас будет свой Shuffle. В отличие от std::shuffle он будет работать одинаково везде
template <typename RandomIt, typename Engine>
void Shuffle(RandomIt first, RandomIt last, Engine& engine) {
    using IterDiff = typename std::iterator_traits<RandomIt>::difference_type;
    IterDiff i, n;
    n = last - first;
    for (i = n - 1; i > 0; --i) {
        swap(first[i], first[GetRandomNumber(static_cast<uint32_t>(i + 1), engine)]);
    }
}

void CypherInplace(unsigned int seed, img_lib::Image& image) {
    mt19937 generator(seed);
    const int area = image.GetWidth() * image.GetHeight();

    // координаты пикселя по индексу
    auto px_num_to_coordinates = [&image](int num) {
        return std::pair{num % image.GetWidth(), num / image.GetWidth()};
    };

    // сложим индексы половины пикселей в вектор и перемешаем их
    std::vector<int> positions(area / 2);
    std::iota(positions.begin(), positions.end(), 0);
    Shuffle(positions.begin(), positions.end(), generator);

    // Будем переставлять чётные и нечётные пиксели между собой.
    // Благодаря этому процедура шифрования и дешифрования будет одинаковой.
    for (int px_num = 0; px_num < area/2; ++px_num) {
        auto [src_x, src_y] = px_num_to_coordinates(px_num * 2);
        auto [dst_x, dst_y] = px_num_to_coordinates(positions[px_num] * 2 + 1);

        std::swap(image.GetPixel(src_x, src_y), image.GetPixel(dst_x, dst_y));
    }
}

int main(int argc, const char** argv) {
    //std::mt19937 ggg;
    //uniform_int_distribution<unsigned int>(0, unsigned(- 2))(ggg);

    if (argc != 4) {
        cerr << "Usage: "sv << argv[0] << " <input image> <output image> <key>"sv << endl;
        return 1;
    }

    int key = atoi(argv[3]);

    auto image = img_lib::LoadPPM(argv[1]);
    if (!image) {
        cerr << "Error loading image"sv << endl;
        return 2;
    }

    CypherInplace(key, image);

    if (!img_lib::SavePPM(argv[2], image)) {
        cerr << "Error saving image"sv << endl;
        return 3;
    }

    cout << "Image saved successfully!"sv << endl;
}
```
Теперь напишем CMakeLists.txt для сборки программы Cypher. Поскольку мы владеем исходным кодом библиотеки, то можем сделать импорт CMakeLists.txt библиотеки, чтобы она автоматически собралась при сборке нашей программы:
```cmake
cmake_minimum_required(VERSION 3.11)

project(Cypher CXX)
set(CMAKE_CXX_STANDARD 17)

add_subdirectory(../ImgLib ImgLibBuildDir)

add_executable(cypher main.cpp) 
```
Мы воспользовались командой `add_subdirectory`, в которой указали путь до другой папки, содержащей CMakeLists.txt, а также директорию, где будет происходить сборка — ImgLibBuildDir. Если бы папка ImgLib была поддиректорией, то второй параметр был бы необязательным.

Сколько целей определяет этот CMakeLists.txt, считая цели из ImgLib?

> Две

Этот файл определил цель cypher. CMakeLists.txt библиотеки `ImgLib` определил цель `ImgLib`. Чтобы добавить `ImgLib` при компоновке cypher, допишем строку:

```cmake
target_link_libraries(cypher ImgLib)
```

Эта команда сообщает, что цель `cypher` зависит от цели `ImgLib`. Вы уже видели `target_link_libraries`, когда рассказывалось про особенности компиляции под MinGW. Здесь можно сделать аналогично, но не забыть учесть `ImgLib` как зависимую библиотеку:

```cmake
if(CMAKE_SYSTEM_NAME MATCHES "^MINGW")
    set(SYSTEM_LIBS -lstdc++)
else()
    set(SYSTEM_LIBS)
endif()

target_link_libraries(cypher ImgLib ${SYSTEM_LIBS})
```

Также необходимо, чтобы main.cpp смог найти включаемый файл PPMImage.h. Для этого нужно добавить путь к нему в список путей поиска inсlude-файлов:
```cmake
target_include_directories(cypher PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../ImgLib")
```
Первым аргументом команды `target_include_directories` нужно указать цель, в которую добавляется include-путь. Слово `PUBLIC` означает, что этот путь будет добавляться также к зависимым целям. Подробнее о модификаторах области видимости в CMake можно прочитать в [документации](https://cmake.org/cmake/help/latest/command/target_include_directories.html). Затем перечисляются директории, которые мы хотим добавить. В нашем случае это только одна директория, но она использует встроенную переменную `CMAKE_CURRENT_SOURCE_DIR`, дающую путь до текущего файла CMakeLists.txt.

Команда `target_include_directories` нужна для правильной компиляции, а `target_link_libraries` для правильной компоновки. Теперь все зависимости учтены. Создаём новую папку для сборки — build_cypher и запускаем в ней команды:

```
cmake ../Cypher -DCMAKE_BUILD_TYPE=Debug
cmake --build .
```

Если всё прошло успешно, в папке появится исполняемый файл — cypher, или cypher.exe под Windows.

При компоновке статические библиотеки задаются наряду с объектными файлами вашей программы. Компоновщик распаковывает архив и берёт из него те объектные файлы, от которых она зависит.

### Используем готовую статическую библиотеку

А теперь представим, что не мы написали ImgLib, а какой-нибудь неизвестный разработчик за большие деньги. Просто так код этой библиотеки он нам не отдаст, но готов предоставить собранный бинарный файл `libImgLib.a` и h-файлы.
<div class="callout">
Распространение бинарного кода спасает от дословного восстановления исходного кода, но не спасает от его несанкционированного копирования и изменения. Специалисты в области reverse engeneering могут менять уже собранные программы: в частности, взламывать защиту в них, узнавать детали коммерческих алгоритмов. Для усложнения этого процесса применяются обфускаторы — программы, запутывающие бинарный код исполняемых файлов. Но обфускация отрицательно сказывается на производительности и стабильности программ. Иногда для защиты используют электронные ключи, самостоятельно выполняющие часть кода.
</div>

Важная вещь: если библиотека собрана в конфигурации Debug, то и компоноваться она должна в конфигурации Debug. Поэтому сделаем вторую версию библиотеки для Release сборки. Создадим каталог build-release и выполним в нём команды:
```
cmake ../ImgLib -DCMAKE_BUILD_TYPE=Release
cmake --build . 
```
Соберём все файлы вместе, построив такую структуру каталогов:
```
ImgLib/
├── include/
│   ├── img_lib.h
│   └── ppm_image.h
└── lib/
    ├── Debug/
    │   └── libImgLib.a
    └── Release/
        └── libImgLib.a 
```
Библиотеку можно распространять!

Попробуем использовать её в своей программе, как если бы исходным кодом мы не владели. Для этого нужно серьёзно переработать скрипт сборки программы Cypher, а исходный код менять не нужно. Прежде всего уберём из CMakeLists.txt папки Cypher импортирование директории. Так мы лишимся цели ImgLib, и её сборка больше не будет частью сборки нашей программы.

Договоримся, что путь к папке библиотеки ImgLib будет устанавливаться через параметры CMake. Для этого добавим в скрипт переменную кэша:
```cmake
cmake_minimum_required(VERSION 3.11)

project(Cypher CXX)
set(CMAKE_CXX_STANDARD 17)

set(IMGLIB_DIR CACHE STRING "ImgLib static library directory")

if(NOT IMGLIB_DIR)
    message(FATAL_ERROR "Please, specify ImgLib directory via -DIMGLIB_DIR=<dir>")
endif()

message(STATUS "ImgLib dir is ${IMGLIB_DIR}, change via -DIMGLIB_DIR=<dir>")

add_executable(cypher main.cpp) 
```
Установка переменной кэша вам уже знакома, но мы использовали несколько новых возможностей. В условии `if` — логическое отрицание. Оно означает, что переменная IMGLIB_DIR не задана или равна OFF. Если условие выполнено, выводится сообщение с флагом `FATAL_ERROR`. Оно означает, что генерация прекратится на этом моменте.

Попробуем запустить CMake такой командой:
```
cmake ../Cypher -DCMAKE_BUILD_TYPE=Debug 
```
В выводе увидим ошибку `Please, specify ImgLib directory via -DIMGLIB_DIR=<dir>`. Include-пути будут задаваться практически так же, как в прошлый раз:
```cmake
target_include_directories(cypher PUBLIC "${IMGLIB_DIR}/include")
```
А вот бинарный файл нужен разный для Debug-конфигурации и остальных вариантов. Попробуем снова использовать `if`, чтобы учесть эту особенность:
```cmake
if(CMAKE_BUILD_TYPE EQUAL "Debug")
    # используем файл из папки Debug
else()
    # используем файл из папки Release
endif()
```
В чём основной недостаток такого подхода?

> Не будет совместимо со всеми IDE.

Конфигурация не указывается при генерации проекта для Visual Studio. Она выбирается уже в самой IDE. Поэтому переменная `CMAKE_BUILD_TYPE` не определена. Можно взять своего рода тернарный оператор, обходящий это ограничение. В CMake он использует выражения-генераторы, о которых подробно рассказано в документации.

Добавим отдельно папку с библиотеками и ссылку на саму библиотеку:
```cmake
target_link_directories(cypher PUBLIC
    "${IMGLIB_DIR}/lib/$<IF:$<CONFIG:Debug>,Debug,Release>"
    )
target_link_libraries(cypher ImgLib)
```

Команда `target_link_directories` похожа на `target_include_directories`, но вместо пути для поиска include-файлов задаёт путь для поиска библиотек при компоновке.

Компоновщик добавляет немного магии: мы указали название библиотеки, а префикс `lib` и расширение `.a` он припишет сам. Можно обойтись без `target_link_directories` и указать имя файла полностью, но тогда нужен полный абсолютный путь до файла библиотеки.

Тут есть проблема — наличие файла `libImgLib.a` CMake проверять не будет. Даже если вы ошиблись в `IMGLIB_DIR` или забыли положить нужную библиотеку, CMake сгенерирует сборочные файлы. Ошибка выявится только на этапе компоновки библиотеки.

В итоге CMakeLists.txt получился таким:
```cmake
cmake_minimum_required(VERSION 3.11)

project(Cypher CXX)
set(CMAKE_CXX_STANDARD 17)

set(IMGLIB_DIR CACHE STRING "ImgLib static library directory")

if(NOT IMGLIB_DIR)
    message(FATAL_ERROR "Please, specify ImgLib directory via -DIMGLIB_DIR=<dir>")
endif()
message(STATUS "ImgLib dir is ${IMGLIB_DIR}, change via -DIMGLIB_DIR=<dir>")

add_executable(cypher main.cpp)

if(CMAKE_SYSTEM_NAME MATCHES "^MINGW")
    set(SYSTEM_LIBS -lstdc++)
else()
    set(SYSTEM_LIBS)
endif()

target_include_directories(cypher PUBLIC "${IMGLIB_DIR}/include")
target_link_directories(cypher PUBLIC
    "${IMGLIB_DIR}/lib/$<IF:$<CONFIG:Debug>,Debug,Release>"
    )
target_link_libraries(cypher ImgLib ${SYSTEM_LIBS}) 
```
Перегенерируем файлы компиляции, запустив в папке для сборки команду:
```
cmake ../Cypher -DIMGLIB_DIR=<полный путь к папке с библиотекой ImgLib> -DCMAKE_BUILD_TYPE=Debug
cmake --build . --verbose
```
Если вы собираете под Windows, обратите внимание на указание пути к папке с библиотекой. Используйте прямые слэши /. При генерации проекта выводится сообщение “ImgLib dir is ...“. Убедитесь, что путь до библиотеки указан верный.

Параметр --verbose указан, чтобы посмотреть на команду компоновки и убедиться, что она верная. В выводе CMake можно будет найти подобную строчку:
```
/usr/bin/cc -g CMakeFiles/cypher.dir/main.cpp.obj -o cypher   -L<путь к ImgLib>/lib/Debug  
-lImgLib 
```
CMake добавил параметр `target_link_directories` через ключ `-L`, правильно учтя конфигурацию, а параметр `target_link_libraries` через ключ `-l`. Так в GCC и Clang задаются компонуемые библиотеки.

Если сборка прошла успешно, в папке build_cypher появится файл cypher. Запустим его на изображении какого-нибудь котика и получим нечто подобное:

![alt text](image-1.png)

Теперь вы сможете самостоятельно собрать библиотеку ImgLib и программу. Сделайте это, чтобы расшифровать изображение с котиком. Он очень любит один напиток и даже готов есть его на завтрак вместе с шоколадными хлопьями. Процесс добавления этого напитка в хлопья изображён на пачке.

Исходные коды урока и зашифрованное изображение — в архиве, код шифрования изображения — 123.

[kitty_and_src.zip](<kitty_and_src.zip>)