## Археологические раскопки: подключаем LibJPEG

CMake — хорошая система сборки, поддерживающая самые разные компиляторы, IDE и инструменты, но она была не всегда. Разработчикам на C++ часто приходится сталкиваться с библиотеками без CMakeLists.txt.

### О make и Autotools

Разберёмся, зачем нужна система сборки помимо поддержки различных IDE. Почему бы просто не записать команды компиляции в файл скрипта? Выберите основную причину.

> Скриптом нельзя или сложно собирать только те файлы, которые действительно нужно пересобрать при повторных сборках.

Системы сборки смотрят, какие файлы изменились, и на основе этого принимают решение, что именно перекомпилировать. Если итогового файла нет или дата его изменения предшествует дате изменения исходного файла, нужно выполнить компиляцию. Так поступает утилита make, которая часто используется для сборки C++-программ. Она читает текстовый файл Makefile. В нём задаются:

- цели — итоговые файлы, которые нужно собрать;

- зависимости — от каких файлов и целей зависит каждая цель.

CMake поддерживает `make` как один из генераторов. Мы пользовались этим генератором в предыдущих уроках, когда собирали библиотеки под MinGW.

В каком случае требуется перекомпилировать cpp-файл, чтобы получить объектный файл? Отметьте один или несколько вариантов.

> Если он изменился после того, как был создан объектный файл.

> Если объектный файл отсутствует.

> Если один из h-файлов, от которых он зависит, изменился после того, как был создан объектный файл.

Писать Makefile собственноручно для больших программ довольно сложно. Поэтому издавна существуют утилиты для его генерации. Самая популярная из них — [Autoconf](https://www.gnu.org/software/autoconf/). Это даже не утилита, а целый набор утилит. Узнать об Autoconf больше и найти схему его работы можно в [Википедии](https://ru.wikipedia.org/wiki/Autoconf). Если вы не собираетесь использовать Autoconf для своих проектов, подробности его устройства и даже сами утилиты вам не понадобятся. Библиотеки, использующие Autoconf, распространяются с уже готовым Bash-скриптом `configure`.

### Собираем LibJPEG

В качестве примера возьмём библиотеку LibJPEG. Она позволит читать не только тривиальный формат PPM, но и настоящие изображения — JPEG. Под Linux-системами можно установить уже готовый пакет с библиотекой, а под Windows — скачать готовый бинарный файл DLL или Lib.

Но мы не ищем лёгких путей, поэтому предлагаем собрать библиотеку самостоятельно. Это позволит лучше настроить сборку и познакомиться с пакетом, созданным Autoconf. Кроме того, её можно собрать под все операционные системы, даже те, где нет готовой сборки.

Возьмите исходный код LibJPEG с официального сайта: скачайте jpegsr.zip для сборки под Windows или jpegsr.tar.gz для остальных систем. Распакуйте архив. В архиве должен быть файл `configure` — это скрипт для генерации Makefile.

Перейдите в папку с `configure`:

- под Windows — через Git Bash;
- под Linux — через обычное окно консоли.

<div class="callout info">
Обратите внимание, что Git Bash должен лежать по пути, где нет пробелов. Иначе сборка не пройдёт.
</div>

Первым делом запустите команду `./configure --help`, чтобы увидеть все параметры конфигурации. Среди прочих флагов там есть такие:
```
--enable-shared[=PKGS]  build shared libraries [default=yes]
--enable-static[=PKGS]  build static libraries [default=yes] 
```

Они позволяют включать и выключать сборку динамической и статической библиотеки. По умолчанию собираются обе версии. Понадобится только статическая библиотека, поэтому сборку динамической надо отключить — `--enable-shared=no`. Выполните команды:
```
mkdir debug
cd debug
../configure --enable-shared=no CPPFLAGS="-DDEBUG -g -O0" CFLAGS="-g -O0" 
```
Запускать скрипт конфигурации лучше в другой папке, чтобы не смешивать исходные и сборочные файлы. Поэтому вы создали папку debug (команда `mkdir`) и перешли в неё (команда `cd`). Своего понимания о том, что такое отладочная конфигурация, у Autotools нет, поэтому пришлось явно указать нужные флаги:

- `-DDEBUG` — включение проверок стандартной библиотеки;
- `-g` — включение отладочных символов;
- `-O0` — отключение оптимизации.

Некоторые Autoconf-скрипты configure поддерживают параметр `--enable-debug`, который активирует эти параметры автоматически.

Скрипт выполнит множество проверок системы. Если все пройдут успешно, он отчитается о создании нескольких файлов:
```
checking build system type... x86_64-w64-mingw32
checking host system type... x86_64-w64-mingw32
checking target system type... x86_64-w64-mingw32
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a thread-safe mkdir -p... /usr/bin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking whether make supports nested variables... yes
checking whether make supports nested variables... (cached) yes
checking whether to enable maintainer-specific portions of Makefiles... no
checking for gcc... gcc
checking whether the C compiler works... yes
checking for C compiler default output file name... a.exe
...
checking whether to build shared libraries... no
checking whether to build static libraries... yes
checking libjpeg version number... 9.4.0
checking that generated files are newer than configure... done
configure: creating ./config.status
config.status: creating Makefile
config.status: creating libjpeg.pc
config.status: creating jconfig.h
config.status: executing depfiles commands
config.status: executing libtool commands 
```
<div class="callout">
Если вы работаете под MinGW, скорее всего сборка завершится с ошибкой. Это связано с тем, что утилита make в этом пакете называется mingw32-make. Укажите дополнительный параметр MAKE="mingw32-make".
</div>

Один из созданных файлов — Makefile. Если он есть, значит пора запускать утилиту `make` или `mingw32-make:`

```
make 
```

Эта утилита выполнит сборку библиотеки. По завершении сборки можно будет найти файл libjpeg.a в папке .libs.

<div class="callout">
Обратите внимание, что в UNIX-системах директории, название которых начинается с точки, скрыты по умолчанию. Чтобы их увидеть, выполните команду ls -a Ключ -a указывает, что нужно отобразить всё (all).
</div>

Обычно собранную библиотеку устанавливают командой `make install`, после чего она становится автоматически доступна без указания путей include-файлов и поиска зависимостей компоновки. Но устанавливать отладочную версию — плохая идея. Поэтому пропустим этот шаг и будем компоновать LibJPEG напрямую.

Но для начала выполните release-сборку. При конфигурировании укажите флаг максимальной оптимизации `-O3`. Если вы остались в папке debug, то выполните команды:

```bash
cd ..
mkdir release
cd release
../configure --enable-shared=no CPPFLAGS="-O3" CFLAGS="-O3" 
```

Команда cd .. перенесёт вас на одну директорию выше, то есть в директорию с configure.

Создайте пакет LibJPEG, как делали это с другими библиотеками:
```
libjpeg/
├── include/
│   ├── jconfig.h
│   ├── jerror.h
│   ├── jmorecfg.h
│   └── jpeglib.h
└── lib/
    ├── Debug
    │   └── libjpeg.a
    └── Release
        └── libjpeg.a 
```
Файл jconfig.h должен сгенерироваться автоматически во время работы `configure`. В отличие от остальных файлов папки include, он располагается в папке сборки, а не папке исходников. Если `configure` завершился, а jconfig.h не был сгенерирован, он вам не нужен.

### Используем LibJPEG

Начнём добавлять поддержку изображений в формате JPEG в свою библиотеку ImgLib. Напишем файл jpeg_image.h:
```cpp
#pragma once
#include "img_lib.h"

#include <filesystem>

namespace img_lib {
using Path = std::filesystem::path;

Image LoadJPEG(const Path& file);

} // of namespace img_lib 
```

Как и многие старые библиотеки, LibJPEG написана на чистом C, а не на C++. Попробуем создать декодировщик изображений JPEG, основываясь на примере `example.c` из исходного кода LibJPEG. Кодировщик вам предстоит написать самостоятельно.

Чтение файла JPEG в этом примере выполняет такая функция:

```c
GLOBAL(int)
read_JPEG_file (char * filename)
{
  /* This struct contains the JPEG decompression parameters and pointers to
   * working space (which is allocated as needed by the JPEG library).
   */
  struct jpeg_decompress_struct cinfo;
  /* We use our private extension JPEG error handler.
   * Note that this struct must live as long as the main JPEG parameter
   * struct, to avoid dangling-pointer problems.
   */
  struct my_error_mgr jerr;
  /* More stuff */
  FILE * infile;        /* source file */
  JSAMPARRAY buffer;    /* Output row buffer */
  int row_stride;       /* physical row width in output buffer */

  /* In this example we want to open the input file before doing anything else,
   * so that the setjmp() error recovery below can assume the file is open.
   * VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
   * requires it in order to read binary files.
   */

  if ((infile = fopen(filename, "rb")) == NULL) {
    fprintf(stderr, "can't open %s\n", filename);
    return 0;
  }

  /* Step 1: allocate and initialize JPEG decompression object */

  /* We set up the normal JPEG error routines, then override error_exit. */
  cinfo.err = jpeg_std_error(&jerr.pub);
  jerr.pub.error_exit = my_error_exit;
  /* Establish the setjmp return context for my_error_exit to use. */
  if (setjmp(jerr.setjmp_buffer)) {
    /* If we get here, the JPEG code has signaled an error.
     * We need to clean up the JPEG object, close the input file, and return.
     */
    jpeg_destroy_decompress(&cinfo);
    fclose(infile);
    return 0;
  }
  /* Now we can initialize the JPEG decompression object. */
  jpeg_create_decompress(&cinfo);

  /* Step 2: specify data source (eg, a file) */

  jpeg_stdio_src(&cinfo, infile);

  /* Step 3: read file parameters with jpeg_read_header() */

  (void) jpeg_read_header(&cinfo, TRUE);
  /* We can ignore the return value from jpeg_read_header since
   *   (a) suspension is not possible with the stdio data source, and
   *   (b) we passed TRUE to reject a tables-only JPEG file as an error.
   * See libjpeg.txt for more info.
   */

  /* Step 4: set parameters for decompression */

  /* In this example, we don't need to change any of the defaults set by
   * jpeg_read_header(), so we do nothing here.
   */

  /* Step 5: Start decompressor */

  (void) jpeg_start_decompress(&cinfo);
  /* We can ignore the return value since suspension is not possible
   * with the stdio data source.
   */

  /* We may need to do some setup of our own at this point before reading
   * the data.  After jpeg_start_decompress() we have the correct scaled
   * output image dimensions available, as well as the output colormap
   * if we asked for color quantization.
   * In this example, we need to make an output work buffer of the right size.
   */ 
  /* JSAMPLEs per row in output buffer */
  row_stride = cinfo.output_width * cinfo.output_components;
  /* Make a one-row-high sample array that will go away when done with image */
  buffer = (*cinfo.mem->alloc_sarray)
        ((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);

  /* Step 6: while (scan lines remain to be read) */
  /*           jpeg_read_scanlines(...); */

  /* Here we use the library's state variable cinfo.output_scanline as the
   * loop counter, so that we don't have to keep track ourselves.
   */
  while (cinfo.output_scanline < cinfo.output_height) {
    /* jpeg_read_scanlines expects an array of pointers to scanlines.
     * Here the array is only one element long, but you could ask for
     * more than one scanline at a time if that's more convenient.
     */
    (void) jpeg_read_scanlines(&cinfo, buffer, 1);
    /* Assume put_scanline_someplace wants a pointer and sample count. */
    put_scanline_someplace(buffer[0], row_stride);
  }

  /* Step 7: Finish decompression */

  (void) jpeg_finish_decompress(&cinfo);
  /* We can ignore the return value since suspension is not possible
   * with the stdio data source.
   */

  /* Step 8: Release JPEG decompression object */

  /* This is an important step since it will release a good deal of memory. */
  jpeg_destroy_decompress(&cinfo);

  /* After finish_decompress, we can close the input file.
   * Here we postpone it until after no more JPEG errors are possible,
   * so as to simplify the setjmp error logic above.  (Actually, I don't
   * think that jpeg_destroy can do an error exit, but why assume anything...)
   */
  fclose(infile);

  /* At this point you may want to check to see whether any corrupt-data
   * warnings occurred (test whether jerr.pub.num_warnings is nonzero).
   */

  /* And we're done! */
  return 1;
} 
```
Её назначение — записать строку изображения, полученную от libjpeg, в объект `out_image`.

После адаптирования функция загрузки изображения станет выглядеть так:
```
Image LoadJPEG(const Path& file) {
    jpeg_decompress_struct cinfo;
    my_error_mgr jerr;
    
    FILE* infile;
    JSAMPARRAY buffer;
    int row_stride;

    // Тут не избежать функции открытия файла из языка C,
    // поэтому приходится использовать конвертацию пути к string.
    // Под Visual Studio это может быть опасно, и нужно применить
    // нестандартную функцию _wfopen
#ifdef _MSC_VER
    if ((infile = _wfopen(file.wstring().c_str(), L"rb")) == NULL) {
#else
    if ((infile = fopen(file.string().c_str(), "rb")) == NULL) {
#endif
        return {};
    }

    /* Шаг 1: выделяем память и инициализируем объект декодирования JPEG */

    cinfo.err = jpeg_std_error(&jerr.pub);
    jerr.pub.error_exit = my_error_exit;

    if (setjmp(jerr.setjmp_buffer)) {
        jpeg_destroy_decompress(&cinfo);
        fclose(infile);
        return {};
    }

    jpeg_create_decompress(&cinfo);

    /* Шаг 2: устанавливаем источник данных */

    jpeg_stdio_src(&cinfo, infile);

    /* Шаг 3: читаем параметры изображения через jpeg_read_header() */

    (void) jpeg_read_header(&cinfo, TRUE);

    /* Шаг 4: устанавливаем параметры декодирования */

    // установим желаемый формат изображения
    cinfo.out_color_space = JCS_RGB;
    cinfo.output_components = 3;

    /* Шаг 5: начинаем декодирование */

    (void) jpeg_start_decompress(&cinfo);
    
    row_stride = cinfo.output_width * cinfo.output_components;
    
    buffer = (*cinfo.mem->alloc_sarray)
                ((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);

    /* Шаг 5a: выделим изображение ImgLib */
    Image result(cinfo.output_width, cinfo.output_height, Color::Black());

    /* Шаг 6: while (остаются строки изображения) */
    /*                     jpeg_read_scanlines(...); */

    while (cinfo.output_scanline < cinfo.output_height) {
        int y = cinfo.output_scanline;
        (void) jpeg_read_scanlines(&cinfo, buffer, 1);

        SaveScanlineToImage(buffer[0], y, result);
    }

    /* Шаг 7: Останавливаем декодирование */

    (void) jpeg_finish_decompress(&cinfo);

    /* Шаг 8: Освобождаем объект декодирования */

    jpeg_destroy_decompress(&cinfo);
    fclose(infile);

    return result;
} 
```
Тут мы отошли от принятых в курсе стандартов написания кода, так как используем чужой код с минимальными изменениями, не вдаваясь в его суть.

Теперь ImgLib сама зависит от другой библиотеки. Эту зависимость нужно прописать в CMakeLists.txt:
```cmake
cmake_minimum_required(VERSION 3.11)

project(ImgLib CXX)
set(CMAKE_CXX_STANDARD 17)

# добавляем новую переменную - путь к LibJPEG
set(LIBJPEG_DIR CACHE STRING "LibJPEG static library directory")
if(NOT LIBJPEG_DIR)
    message(FATAL_ERROR "Please, specify LibJPEG directory via -DLIBJPEG_DIR=<dir>")
endif()
message(STATUS "LibJPEG dir is ${LIBJPEG_DIR}, change via -DLIBJPEG_DIR=<dir>")

set(IMGLIB_MAIN_FILES img_lib.h img_lib.cpp)

# к файлам форматов добавим JPEG
set(IMGLIB_FORMAT_FILES 
    ppm_image.h ppm_image.cpp 
    jpeg_image.h jpeg_image.cpp)

add_library(ImgLib STATIC ${IMGLIB_MAIN_FILES} 
            ${IMGLIB_FORMAT_FILES})

# Include-директории теперь включают LibJPEG
target_include_directories(ImgLib PUBLIC "${LIBJPEG_DIR}/include")

# Флаг INTERFACE обозначает видимость параметра - только для зависимых целей.
# Для самой ImgLib не нужно указывать зависимости компоновки, поскольку
# статическая библиотека не компонуется, а просто архивируется
target_link_directories(ImgLib INTERFACE
    "${LIBJPEG_DIR}/lib/$<IF:$<CONFIG:Debug>,Debug,Release>"
    )

# В качестве зависимости указано jpeg. Компоновщик будет искать файл libjpeg.a
target_link_libraries(ImgLib INTERFACE jpeg) 
```

Напишем теперь простую программу для конвертации JPEG в PPM:
```
#include <img_lib.h>
#include <jpeg_image.h>
#include <ppm_image.h>

#include <filesystem>
#include <string_view>
#include <iostream>

using namespace std;

int main(int argc, const char** argv) {
    if (argc != 3) {
        cerr << "Usage: "sv << argv[0] << " <in_file> <out_file>"sv << endl;
        return 1;
    }

    img_lib::Path in_path = argv[1];
    img_lib::Path out_path = argv[2];

    img_lib::Image image = img_lib::LoadJPEG(in_path);
    if (!image) {
        cerr << "Loading failed"sv << endl;
        return 4;
    }

    if (!img_lib::SavePPM(out_path, image)) {
        cerr << "Saving failed"sv << endl;
        return 5;
    }

    cout << "Successfully converted"sv << endl;
} 
```
В задании нужно будет расширить её и сделать более универсальной. Сохраним программу в файл main.cpp папки ImgConverter и напишем там CMakeLists.txt с таким содержанием:
```cmake
cmake_minimum_required(VERSION 3.11)

project(Negate CXX)
set(CMAKE_CXX_STANDARD 17)

add_subdirectory(../ImgLib ImgLibBuildDir)

if (CMAKE_SYSTEM_NAME MATCHES "^MINGW")
    set(SYSTEM_LIBS -lstdc++)
else()
    set(SYSTEM_LIBS)
endif()

add_executable(imgconv main.cpp)
target_include_directories(imgconv PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../ImgLib")
target_link_libraries(imgconv ImgLib ${SYSTEM_LIBS}) 
```
### Конвертируем

Создайте папку debug и запустите в ней следующие команды для генерации и сборки:
```
cmake ../ImgConverter -DCMAKE_BUILD_TYPE=Debug -DLIBJPEG_DIR=<путь к пакету libjpeg>
cmake --build . 
```
Теперь можете запустить и проверить программу:
```
imgconv reading_dog.jpg reading_dog.ppm 
```
Если все шаги проделаны правильно, изображение сконвертируется без потерь.

Исходный код программы ImgConverter и изображение пёсика, только что дочитавшего книгу, — в архиве:

[reading_dog.zip](reading_dog.zip)

А вот и сам пёсик:

![alt text](image.png)

Использование в C++ чужих библиотек, особенно написанных давно, может показаться сложным, но это обязательная часть работы каждого программиста. Прежде чем разрабатывать что-нибудь новое, нужно убедиться, что это не хорошо забытое старое. Люби́те библиотеки. Может быть, вашу задачу решает хорошо написанный и проверенный временем код. Его разработчики уже наступили на все грабли, на которые предстоит наступить вам, если будете разрабатывать то же самое самостоятельно.