## Variadic Templates

В этом уроке вы познакомитесь с Variadic templates. Их также называют шаблонами с переменным числом параметров или вариативными шаблонами. Они позволяют создать шаблон функции или класса, принимающий любое число параметров произвольных типов. С такими шаблонами вы уже знакомы. Среди них классы `std::tuple` и `std::variant`, функции `std::tie`, `std::make_unique`:
```cpp
using namespace std;

struct Student {
    string name;
    string surname;
    int age;
};

bool operator<(const Student& lhs, const Student& rhs) {
    // Шаблонная функция tie имеет произвольное число аргументов
    // Она возвращает tuple из ссылок на параметры
    return tie(lhs.name, lhs.surname, lhs.age) < tie(rhs.name, rhs.surname, rhs.age);
}

int main() {
    vector<Student> students{
        {"Ivan"s, "Ivanov"s, 20},
        {"Vasiliy"s, "Vasiliev"s, 25},
        {"Sergey"s, "Sergeev", 16},
    };
    sort(students.begin(), students.end());
}
```
Вариативный шаблон или шаблон с переменным числом аргументов объявляется так:
```cpp
// Вариативный шаблон класса
template <typename... Types> // Types — пакет параметров шаблона
class Tuple{};

// Вариативный шаблон функции
template <typename... Types> // Types — пакет параметров шаблона
void Fn(Types... values) {   // values — пакет параметров функции
} 
```
Вариативные шаблоны `Tuple` и `Fn` содержат пакет параметров шаблона, который вмещает ноль и более параметров.

В заголовке вариативной функции `Fn` используется пакет параметров функции, способный принять ноль и более аргументов:
```cpp
int main() {
    // Аналогично вызову Fn<int, string, double>(42, "hello"s, 3.5);
    Fn(42, "hello"s, 3.5); 

    // Аналогично вызову Fn<>();
    Fn();
} 
```

### Определение количества параметров в пакете

В качестве простого примера шаблонной функции напишем функцию `PrintArgumentCount`, которая выводит количество своих аргументов. Для этого она использует оператор `sizeof...`, возвращающий число параметров в пакете:
```cpp
#include <iostream>

using namespace std;

template <typename... Types>
void PrintArgumentCount(const Types&... values) {
    cout << sizeof...(values) << endl;
}

int main() {
    PrintArgumentCount();                    // Выведет 0
    PrintArgumentCount(42);                  // Выведет 1
    PrintArgumentCount("hello"s, 42, 1.23);  // Выведет 3
}
```
Шаблон `PrintArgumentCount` принимает пакет `values` по константной ссылке. На основе этого шаблона компилятор сгенерирует три функции:
- без параметров;
- с параметром `const int&`;
- с параметрами `const std::string&`, `const int&` и `const double&`.

Внутри них компилятор вместо `sizeof...(values)` вставит размер пакета `values`. Так как `PrintArgumentCount` принимает только пакет параметров, его размер будет равен количеству аргументов функции.

### Распаковка пакета параметров

Пакет параметров можно распаковать, написав после его имени многоточие. Распакованный пакет превращается в список элементов пакета, разделённых запятыми.

Одно из применений распаковки — передача содержимого пакета в функцию. Прежде чем вызвать `PrintArgumentCount`, функция `Fn` должна распаковать свой пакет параметров:
```cpp
// Функция Fn иллюстрирует распаковку пакета параметров при вызове функции
template <typename T, typename... Types>
void Fn(int arg1, const T& arg2, const Types&... values) {
    // Чтобы вызвать PrintArgumentCount, нужно распаковать пакет values
    PrintArgumentCount(arg1, arg2, values...);
    /* ... */
}

int main() {
    Fn(42, "Hello"sv, 4);         // Выведет 3
    Fn(42, 10.5);                 // Выведет 2
    Fn(3, "Goodbye"s, 42, 1.23);  // Выведет 4
} 
```
Распаковать можно не только пакет параметров функции, но и пакет параметров шаблона. Используем это, чтобы создать химер — существ, обладающих свойствами нескольких организмов:
```cpp
struct Man {
    void SayHello() { cout << "Hi!"sv << endl; }
};
struct Bat {
    void Fly() { cout << "I'm flying!!!"sv << endl; }
};
struct Spider {
    void Weave() { cout << "I'm weaving a web"sv << endl; }
};

// Химера, наследуется от переданных ей базовых классов
template <typename... Bases>
class Chimera : public Bases... {};

int main() { 
    Chimera<Bat, Man> batman;
    batman.SayHello();
    batman.Fly();

    Chimera<Spider, Man> spiderman;
    spiderman.Weave();
    spiderman.SayHello();
}
```
Этот искусственный пример с наследованием иллюстрирует идею, на которой основываются полезные стандартные классы, например `std::tuple`.

### Обработка пакета параметров

Рассмотрим функцию `Log`, которая выводит значения своих аргументов, разделяя их запятыми:
```cpp
template <typename... Ts>
void Log(std::ostream& out, const Ts&... vs);

int main() {
    using namespace std;
    Log(cout, "Hello"s, "World"s, 42); // Выведет Hello, World, 42
    Log(cout);                         // Выведет пустую строку
}
```
Если бы в C++ была возможность пробежаться в цикле по содержимому пакета параметров, функция `Log` могла быть такой: 
```cpp
template <typename... Ts>
void Log(std::ostream& out, const Ts&... vs) {
    using namespace std;

    bool print_comma = false;
    for (const auto& v : vs) {
        // На каждой итерации v ссылается на очередной параметр пакета vs
        if (print_comma) {
            out << ", "sv;
        }
        out << v;
        print_comma = true;
    }
    out << endl;
}
```
Увы, этот код даже не скомпилируется. C++ — язык со статической типизацией, и переменная `v` не может менять тип на каждой итерации цикла. Кроме того, пакет параметров — это не контейнер, по которому можно выполнить итерацию во время выполнения программы. Пакет параметров существует только во время компиляции, и для работы с ним доступны только две операции: «узнать размер» и «распаковать содержимое».

Один из способов решить задачу — использовать рекурсию. На каждом шаге рекурсии программа должна сначала вывести самый первый элемент пакета параметров, а затем рекурсивно обработать оставшиеся элементы.

Псевдокод решения:
```cpp
// Это псевдокод для иллюстрации решения

// LogImpl — вспомогательная функция, которая рекурсивно выводит 
// элементы списка args в out, разделяя их запятыми
void LogImpl(out, args...) {
    head = взять первый элемент списка args...
    out << head;
    tail = взять элементы списка args..., кроме head
    if (tail не пуст) {
        out << ", "sv;
        LogImpl(out, tail...); // вывести остальные элементы
    }
}

void Log(out, args...) {
    if (args не пуст) {
        LogImpl(out, args...);
    }
    out << endl;
}
```
Так, вызов `Log(cout, 1, 3.5, "hello"s)` приведёт к последовательности рекурсивных вызовов:

- `LogImpl(cout, 1, 3.5, "hello"s)`. На этом шаге в cout будет выведено 1, .
- `LogImpl(cout, 3.5, "hello"s)`. В `cout` будет выведено `3.5,`.
- `LogImpl(cout, "hello"s)`. В `cout` будет выведено: `hello`.

Функция `Log` дословно повторяет псевдокод:
```cpp
template <typename... Ts>
void Log(std::ostream& out, const Ts&... vs) {
    // Выводим аргументы функции, если они не пустые
    if constexpr (sizeof...(vs) != 0) {
        detail::LogImpl(out, vs...);
    }
    out << std::endl;
} 
```
Чтобы написать функцию `LogImpl`, нужна операция разделения списка параметров на «голову» и «хвост». Самый простой способ сделать это — добавить обычный шаблонный параметр `T0`, принимающий голову списка:
```cpp
namespace detail {
// Функция для вывода одного и более значений
template <typename T0, typename... Ts>
void LogImpl(std::ostream& out, const T0& v0, const Ts&... vs) {
    using namespace std::literals;
    out << v0;
    // Выводим через запятую остальные параметры, если они остались
    if constexpr (sizeof...(vs) != 0) {
        out << ", "sv;
        LogImpl(out, vs...);  // Рекурсивно выводим остальные параметры
    }
}
}  // namespace detail 
```
Функция `LogImpl` рекурсивно вызывает себя, пока не будут выведены все аргументы функции. Для проверки пакета `vs` на пустоту используется `if constexpr`, а не обычный `if`. Так не будет компилироваться вызов `LogImpl` на последнем шаге рекурсии, когда список `vs` опустеет.

Функцию `Log` можно вызывать с любым количеством произвольных аргументов. Единственное требование к её аргументам — наличие оператора вывода в `ostream`:
```cpp
struct Point {
    int x, y;
};

std::ostream& operator<<(std::ostream& out, Point p) {
    out << '{' << p.x << ',' << p.y << '}';
    return out;
}

int main() {
    using namespace std;
    Log(cout, 42, Point{10, 20}, "Hello"s);  // 42, {10,20}, Hello
    Log(cout);                               // выведет пустую строку
    Log(cout, 5.8);                          // 5.8
}
```

### Паттерн распаковки

При распаковке пакета параметров можно указать паттерн распаковки. Пример:
```cpp
template <typename... Types>
void F(Types... args);

template <typename... Types>
void G(Types... args) {
    // Пусть args — пакет x, y, z
    F(args...);     // F(x, y, z);
    F(&args...);    // F(&x, &y, &z);
    F(H(args)...);  // F(H(x), H(y), H(z));

    F(const_cast<const Types*>(&args)...);
        // F(const_cast<const int*>(&x),
        //   const_cast<const double*>(&y),
        //   const_cast<const string*>(&z));
}

G(1, 3.5, "hello"s); // G(int x, double y, string z);
```
Применим паттерн распаковки, чтобы вывести функцией `Log` элементы внутри фигурных скобок `{}`, не изменяя ни функцию `Log`, ни `LogImpl`:
```cpp
// Возвращает строковое представление v внутри фигурных скобок
template <typename T>
std::string Decorate(const T& v) {
    std::ostringstream os;
    os << '{' << v << '}';
    return os.str();
}

// Выводит через запятую аргументы vs, заключая их в фигурные скобки
template <typename... Ts>
void LogDecorated(std::ostream& out, const Ts&... vs) {
    // Раскроется в Log(out, Decorate(vs1), ..., Decorate(vsN))
    Log(out, Decorate(vs)...);
}

int main() {
    using namespace std;
    // Выведет {42}, {{10,20}}, {Hello}
    LogDecorated(cout, 42, Point{10, 20}, "Hello"s);
}
```
Пусть `args` — это пакет параметров `x, y, z`. Тогда во что распакуется следующее выражение?

> F(x + x, y + y, z + z);


Здесь паттерн распаковки — выражение `args + args`. После распаковки пакета `x, y, z` он будет раскрыт в `x + x, y + y, z + z`.

Пусть `args` — пакет параметров `x, y, z`. Во что распакуется следующее выражение?

> F(H(x, y, z) + H(x), H(x, y, z) + H(y), H(x, y, z) + H(z));

Здесь два паттерна распаковки: `args` и `H(args...) + H(args)`. При этом первый — часть второго. Сначала первый паттерн распакуется в `x, y, z`, превратив второй паттерн в `H(x, y, z) + H(args)`. Затем второй паттерн распакуется в `H(x, y, z) + H(x), H(x, y, z) + H(y), H(x, y, z) + H(z)`.

### Выражения свёртки

Простая шаблонная функция `LogImpl` выглядит сложно из-за рекурсии и во время компиляции может создавать много работы для компилятора. Ведь даже один вызов `Log(cout, 42, Point{10, 20}, "Hello"s)` приведёт к построению четырёх функций.

```cpp
void Log(ostream&, const int&, const Point&, const string&);
void LogImpl(ostream&, const int&, const Point&, const string&);
void LogImpl(ostream&, const Point&, const string&);
void LogImpl(ostream&, const string&);
```

Можно упростить разбор пакета параметров шаблона — применить выражение свёртки, или [fold expression](https://en.cppreference.com/w/cpp/language/fold.html). Оно позволяет обработать пакет параметров шаблона, не прибегая к рекурсии.

Рассмотрим работу свёрточных выражений на примере функции, которая вычисляет сумму своих аргументов:
```cpp
#include <iostream>

template <typename... Tn>
auto Sum(const Tn&... vn) {
    return (... + vn); // (((vn1 + vn2) + ...) + vnN)
}
```
Выражение `(... + vn)` называется выражением свёртки. Оно превращает пакет `a, b, c, d` в `(((a + b) + c) + d)`, что эквивалентно вычислению `a + b + c + d` слева направо. Скобки — обязательная часть выражения свёртки.

Шаблонную функцию `Sum` можно использовать для вычисления суммы чисел или конкатенации строк: 
```cpp
int main() {
    using namespace std;
    std::cout << Sum(10) << std::endl;                         // 10
    std::cout << Sum(10, 15.5) << std::endl;                   // 25.5
    std::cout << Sum("Hello "s, "world"s, "!"s) << std::endl;  // Hello world!
}
```
Встретив вызов функции `Sum("Hello "s, "world"s, "!"s)`, компилятор сгенерирует всего одну функцию Sum, эквивалентную этой:
```cpp
std::string Sum(const string& vn1, const string& vn2, const string& vn3) {
    return ((vn1 + vn2) + vn3);
}
```
Кроме операции `+` в выражениях свёртки можно использовать и другие бинарные операции:
```cpp
template <typename... Ts>
auto Product(const Ts&... vs) {
    return (... * vs);
}

int main() {
    std::cout << Product(2, 3, 4) << std::endl;  // 24
}
```
Применим выражение свёртки, чтобы упростить функцию `LogImpl`. Для этого снова представим, как она могла бы выглядеть, если бы элементы пакета параметров можно было использовать в циклах:
```cpp
template <typename... Ts>
void LogImpl(std::ostream& out, const T0& v0, const Ts&... vs) {
    using namespace std;
    out << v0;
    // Этот код не скомпилируется и служит для иллюстрации идеи
    for (const auto& v : vs) {
        out << ", "sv << v;
    }
}
```
Здесь нужна бинарная операция, которая позволит последовательно выполнить выражение `out << ", "sv << v` для каждого элемента пакета параметров. Провернуть такой фокус поможет оператор `,`. Он вычисляет свои аргументы слева направо и возвращает результат вычисления второго аргумента:
```cpp
int a = F1(), F2(); // вычислит F1(), потом F2() и вернёт результат вызова F2()

(cout << ", "sv << 1), (cout << ", "sv << 2.3), (cout << ", "sv << 4); // Выведет , 1, 2.3, 4
```

Перепишем функцию `LogImpl`:
```cpp
namespace detail {
// Функция для вывода одного и более значений
template <typename T0, typename... Ts>
void LogImpl(std::ostream& out, const T0& v0, const Ts&... vs) {
    using namespace std::literals;
    out << v0;
    (..., (out << ", "sv << vs));
}
}  // namespace detail

// Функция Log остаётся без изменений
template <typename... Ts>
void Log(std::ostream& out, const Ts&... vs) {
    if constexpr (sizeof...(vs) != 0) {
        detail::LogImpl(out, vs...);
    }
    out << std::endl;
}
```
В данном случае вызов `Log(cout, 42, Point{10, 20}, "Hello"s)` сгенерирует две функции c кодом, эквивалентным такому:
```cpp
namespace detail {
void LogImpl(ostream& out, const int& v0, const Point& vs1, const string& vs2) {
    using namespace std::literals;
    out << v0;
    ((out << ", "sv << vs1), (out << ", "sv << vs2));
}
}
void Log(ostream& out, const int& vs1, const Point& vs2, const string& vs3) {
    detail::LogImpl(out, vs1, vs2, vs3);
    out << std::endl;
}
```
Версия `Log` на основе свёртки всё ещё использует вспомогательную функцию `LogImpl`. Почему нельзя обойтись одной лишь функцией `Log`?

Функция `Log` должна уметь принимать ноль и более аргументов и не выводить после последнего запятую.

В отличие от большинства других бинарных операций, свёртка с использованием запятой может применяться к пустому пакету параметров. Чтобы не выводить запятую в конце списка, первый элемент обрабатывается особым образом. Из-за этого функция `LogImpl` требует как минимум один аргумент для вывода. Функция `Log` вызывает `LogImpl`, только когда пакет параметров не пустой. 

Так свёртка упрощает обработку параметров вариативного шаблона. В выражениях свёртки можно использовать один из четырёх видов синтаксиса, которые различаются порядком вычислений и наличием начального значения:
```
( pack op ... )         //(1) унарная правоассоциативная свёртка
( ... op pack )         //(2) унарная левоассоциативная свёртка
( pack op ... op init ) //(3) бинарная правоассоциативная свёртка
( init op ... op pack ) //(4) бинарная левоассоциативная свёртка 
```
Здесь pack обозначает пакет параметров, op — бинарный оператор, init — начальное значение. Скобки — обязательная часть выражения свёртки.
- `(values + ...)` раскрывается в $(values_1​ +(...+(values_{N−1​} +values_N )))$.
  
- `(... - args)` раскрывается в $(((args_1​ −args_2)−...)−args_N)$.
  
- `(nums * ... * 5)` раскрывается в $(nums 1 *(...*(nums_N * 5)))$.

- `("Hello, "s + ... + strings)` раскрывается в $((("Hello,"s+strings_1 )+...)+strings_N)$.