## Реализация метода EmplaceBack

Вы познакомились с вариативными шаблонами. Используя их, вы научились создавать шаблонные функции в произвольном количестве аргументов.

В этом уроке вы примените вариативный шаблон для разработки метода `EmplaceBack`. Это более эффективный метод вставлять элементы в вектор.

Сколько конструкторов класса `Cat` будет вызвано в этой программе?
```cpp
using namespace std;

class Cat {
public:
    Cat(string name, int age);
    /* ... */
};

int main() {
    Vector<Cat> cats;
    cats.PushBack(Cat("Leopold"s, 3));
} 
```
> 2

Сначала будет сконструирован временный объект класса `Cat` с именем Leopold и возрастом три года. Затем он будет передан по rvalue-ссылке в метод `PushBack`, который переместит временный объект в динамическую память вектора, использовав для этого move-конструктор класса `Cat`

Когда объект сразу после создания перемещается в контейнер, желательно избежать операции перемещения. Даже если она не выбрасывает исключений, выполняется за константное время и не требует дополнительной памяти. Самый быстрый код — это код, который не выполняется.

С этой целью стандартные контейнеры имеют методы `emplace_back`, `emplace` и им подобные. `emplace`-методы добавляют элемент в контейнер без создания промежуточного объекта:

```cpp
int main() {
    vector<Cat> cats;
    cats.emplace_back("Leopold"s, 3);
}
```
В этой программе метод `emplace_back` сконструирует кота в динамической памяти, передав строку "Leopold" и число 3 конструктору кота напрямую. И никаких лишних перемещений и копирований!

Разберёмся, как сделать аналогичный функционал в собственном классе `Vector`.

Какими свойствами должен обладать метод `EmplaceBack` класса `Vector`? Выберите несколько вариантов.

Метод должен уметь принимать любое количество аргументов произвольного типа. Вектор — универсальный класс. Его элементами могут быть классы, конструкторы которых различаются количеством и типом аргументов.

Метод должен принимать свои аргументы по Forwarding-ссылке. В этом случае он сможет эффективно передавать конструктору `T` константные и неконстантные ссылки, а также ссылки на временные объекты.

Метод должен выполняться за время $O(1)$. Подобно методу `PushBack` временнáя сложность `EmplaceBack` должна быть амортизированной константой.

Конструкторы разных классов различаются количеством и типом своих аргументов. Метод `EmplaceBack` должен уметь вызывать любые конструкторы типа `T`, передавая им как константные и неконстантные ссылки, так и rvalue-ссылки на временные объекты. Для этого `EmplaceBack` должен быть вариативным шаблоном, который принимает аргументы конструктора `T` по Forwarding-ссылкам:
```cpp
template <typename T>
class Vector {
public:
    template <typename... Args>
    T& EmplaceBack(Args&&... args) {
        /*
           Реализация похожа на PushBack, только вместо копирования или перемещения
           переданного элемента, он конструируется путём передачи параметров метода конструктору T
        */
    }
};
```
Метод `EmplaceBack` возвращает ссылку на добавленный элемент вектора. Это удобно для использования объекта сразу после его конструирования:
```cpp
using namespace std;

int main() {
    Vector<Cats> cats;
    cats.EmplaceBack("Tom"s, 5).SayMeow();
}
```
Есть ли необходимость в обоих методах `PushBack`, если `EmplaceBack` может принимать  аргументы `T&`, `const T&` и `T&&`?

```cpp
Vector<Cats> cats;

Cat cat_1("Tom", 3);
Cat cat_2("Leopold", 4);

cats.EmplaceBack(cat_1);             // Такой же результат даёт вызов cats.PushBack(cat_1);
cats.EmplaceBack(std::move(cat_2));  // Такой же результат даёт вызов cats.PushBack(std::move(cat_2)); 
```

Методы `PushBack` по-прежнему могут быть полезны.

Метод `EmplaceBack` может вызвать любые конструкторы типа `T`, в том числе объявленные `explicit`. В некоторых случаях это может создать проблемы, которые были бы невозможны при использовании `PushBack`. Например, когда внутри вектора хранятся указатели `unique_ptr`:

```cpp
Vector<unique_ptr<Shape>> shapes;
Rectangle r;

// Код скомпилируется без ошибок и предупреждений, но созданный unique_ptr
// будет ссылаться на объект в области стека, что приведёт к неопределённому поведению
// при разрушении
shapes.EmplaceBack(&r);

// не скомпилируется, так как конструктор unique_ptr из указателя объявлен explicit
// shapes.PushBack(&r);
```