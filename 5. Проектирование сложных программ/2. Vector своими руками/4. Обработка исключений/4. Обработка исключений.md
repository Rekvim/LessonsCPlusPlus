## Обработка исключений
В предыдущем уроке вы написали наивную реализацию четырёх методов нового вектора: два конструктора, деструктор и метод `Reserve`.

Вектор должен не только эффективно работать с объектами в памяти, но и быть надёжным при возникновении исключений. Это шаблонный класс, способный хранить объекты произвольного типа, в том числе и объекты, конструкторы которых могут выбрасывать исключения. Например, при нехватке памяти или в других нештатных ситуациях.

В этом уроке вы улучшите вектор так, чтобы его конструкторы и метод `Reserve` надёжно работали при возникновении исключений.

Несовершенство наивной реализации методов `Vector` демонстрирует такая структура:

```cpp
struct C {
    C() {
        Check();
    }
    C(const C& /*other*/) {
        Check();
    }
    C(C&& /*other*/) = delete;
    C& operator=(const C& /*rhs*/) = default;
    C& operator=(C&& /*rhs*/) = delete;
    ~C() {
        --objects;
    }

    static void Check() {
        if (objects >= 5) {
            throw std::runtime_error("Too many objects"s);
        }
        ++objects;
    }
    inline static size_t objects = 0;
};
```

Структура `C` не просто подсчитывает количество созданных экземпляров, но и выбрасывает исключение `runtime_error` при попытке создания больше пяти экземпляров. Это позволяет смоделировать нехватку памяти.

Сравним работу контейнеров `std::vector` и `Vector` при работе со структурой `C`:

```cpp
int main() {
    cout << "std::vector"sv << endl;
    try {
        std::vector<C> v(10);
        cout << "OK"sv << endl;
    } catch (...) {
        cout << "Exception"sv << endl;
        cout << "Objects:"sv << C::objects << endl;
    }
    cout << "Vector"sv << endl;
    try {
        Vector<C> v(10);
        cout << "OK"sv << endl;
    } catch (...) {
        cout << "Exception"sv << endl;
        cout << "Objects:"sv << C::objects << endl;
    }
}
```
И `std::vector` и `Vector` потерпят неудачу при попытке создать контейнер из десяти элементов — конструктор `C` не позволит создать более пяти:
```cpp
std::vector
Exception
Objects:0
Vector
Exception
Objects:5
```
Внутри обработчика исключений, поймавшего исключение во время инициализации `std::vector`, количество экземпляров `C` равно нулю. Все пять объектов, созданных при конструировании контейнера, своевременно разрушаются.

В случае `Vector` это требование не выполняется. При разрушении контейнера в памяти остались пять объектов. Чтобы понять причины, взглянем на код конструктора `Vector`:

```cpp
template <typename T>
class Vector {
    explicit Vector(size_t size)
        : data_(Allocate(size))     // Allocate() может выбросить исключение
        , capacity_(size)
        , size_(size)
    {
        for (size_t i = 0; i != size; ++i) {
            new (data_ + i) T();    // Конструктор T может выбросить исключение
        }
    }
    ~Vector() {
        DestroyN(data_, size_);
        Deallocate(data_);
    }
    ...
};
```
В этом конструкторе исключение может возникнуть во время работы функции `Allocate`, если не будет хватать памяти. Память в этом случае не будет выделена, а деструктор класса `Vector` не будет вызван. Не выделили память — не нужно и возвращать.

Второе место, где может быть выброшено и выбрасывается исключение, — вызов размещающего оператора `new`. Он вызывает конструктор типа `T`. Исключение в этом конструкторе приведёт к следующим последствиям:

- Деструкторы ранее сконструированных элементов вызваны не будут. Именно это мы наблюдали в виде пяти оставшихся экземпляров типа `C`;

- Деструктор вектора вызван не будет, так как конструктор выбросил исключение. В результате будет утечка памяти.

Чтобы исправить эту проблему, нужно обернуть тело конструктора в блок `try`, а в блоке `catch` разрушить сконструированные объекты, освободить память и перевыбросить исключение:

```cpp
template <typename T>
class Vector {
public:
    explicit Vector(size_t size)
        : data_(Allocate(size))
        , capacity_(size)
        , size_(size)  //
    {
        size_t i = 0;
        try {
            for (; i != size; ++i) {
                new (data_ + i) T();
            }
        } catch (...) {
            // В переменной i содержится количество созданных элементов.
            // Теперь их надо разрушить
            DestroyN(data_, i);
            // Освобождаем память, выделенную через Allocate
            Deallocate(data_);
            // Перевыбрасываем пойманное исключение, чтобы сообщить об ошибке создания объекта
            throw;
        }
    }
    ...
};
```
Теперь поведение конструктора `Vector` стало таким же, как и у стандартного вектора:
```cpp
std::vector
Exception
Objects:0
Vector
Exception
Objects:0 
```
Подобные исправления потребуется внести в копирующий конструктор и метод `Reserve`.