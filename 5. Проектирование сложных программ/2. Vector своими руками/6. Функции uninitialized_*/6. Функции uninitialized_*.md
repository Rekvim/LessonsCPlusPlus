## Функции std::uninitialized_*
В прошлом уроке вы начали упрощать обработку исключений в конструкторах вектора и в методе Reserve. Владение сырой памятью вынесли во вспомогательную структуру RawMemory. Но в коде класса Vector всё ещё есть блоки `try`/`catch`.

Рассмотрим код одного из конструкторов `Vector`:
```cpp
template <typename T>
class Vector {
public:
    explicit Vector(size_t size)
        : data_(size)
        , size_(size)  //
    {
        size_t i = 0;
        try {
            for (; i != size; ++i) {
                new (data_ + i) T();
            }
        } catch (...) {
            DestroyN(data_.GetAddress(), i);
            throw;
        }
    }
    ...
};
```
Этот конструктор создаёт заданное количество элементов типа `T` в неинициализированной области памяти, вызывая для них конструктор по умолчанию. В случае неудачи элементы, которые удалось создать, разрушаются. После этого выбрасывается пойманное исключение. Конструктор копирования устроен похоже, только в нём элементы создаются копированием исходных элементов.

В стандартной библиотеке есть целое семейство функций, создающих и удаляющих группы объектов в неинициализированной области памяти точь-в-точь как код вашего класса `Vector`. Объявлены они в файле `<memory>`:

- uninitialized_copy и uninitialized_copy_n
- uninitialized_fill и uninitialized_fill_n
- uninitialized_move и uninitialized_move_n
- uninitialized_default_construct и uninitialized_default_construct_n
- uninitialized_value_construct и uninitialized_value_construct_n
- destroy_at
- destroy и destroy_n
- construct_at
  
Взглянем на примерный код из описания функции [std::uninitialized_value_construct_n](https://en.cppreference.com/w/cpp/memory/uninitialized_value_construct_n) на сайте cppreference:
```cpp
template<class ForwardIt, class Size>
ForwardIt uninitialized_value_construct_n( ForwardIt first, Size n )
{
    using T = typename std::iterator_traits<ForwardIt>::value_type;
    ForwardIt current = first;
    try {
        for (; n > 0 ; (void) ++current, --n) {
            // Конструируем объект по адресу, на который ссылается итератор current,
            // вызывая для него конструктор по умолчанию
            ::new (const_cast<void*>(static_cast<const volatile void*>(
                std::addressof(*current)))) T();
        }
        return current;
    }  catch (...) {
        // Разрушаем объекты в диапазоне [first, current)
        std::destroy(first, current);
        throw;
    }
} 
```
Так как эта функция может работать с произвольными итераторами, а не только с указателями, её код чуть сложнее кода конструктора `Vector`. При её использовании тело конструктора сократится до одной строки:
```cpp
template <typename T>
class Vector {
public:
    explicit Vector(size_t size)
        : data_(size)
        , size_(size)
    {
        std::uninitialized_value_construct_n(data_.GetAddress(), size);
    }
    ...
};
```
Аналогично функция [uninitialized_copy_n](https://en.cppreference.com/w/cpp/memory/uninitialized_copy_n) упрощает конструктор копирования до одной строки, а функция [std::destroy_n](https://en.cppreference.com/w/cpp/memory/destroy_n.html) заменяет метод `DestroyN`.

Один из возможных способов упростить операцию `Reserve` — использовать функции `uninitialized_copy_n` и `destroy_n`:

```cpp
template <typename T>
class Vector {
public:
    ...
    void Reserve(size_t new_capacity) {
        if (new_capacity <= data_.Capacity()) {
            return;
        }
        RawMemory<T> new_data(new_capacity);
        // Конструируем элементы в new_data, копируя их из data_
        std::uninitialized_copy_n(data_.GetAddress(), size_, new_data.GetAddress());
        // Разрушаем элементы в data_
        std::destroy_n(data_.GetAddress(), size_);
        // Избавляемся от старой сырой памяти, обменивая её на новую
        data_.Swap(new_data);
        // При выходе из метода старая память будет возвращена в кучу
    }
    ...
}; 
```
Такой способ будет прекрасно работать, однако задачу можно решить ещё эффективнее. Этот код копирует элементы из старой области памяти в новую, после чего уничтожает элементы старой области памяти.

Для многих типов операция перемещения может быть эффективнее копирования. Этим можно воспользоваться. «Украсть» данные у объекта, который вот-вот будет разрушен, часто гораздо дешевле с точки зрения памяти и времени, чем выполнять полноценное копирование. Более того, некоторые классы могут поддерживать только перемещение: например, `std::unique_ptr`. В таком случае уместнее будет заменить копирование элементов на перемещение, вызвав [std::uninitialized_move_n](https://en.cppreference.com/w/cpp/memory/uninitialized_move_n.html). Эта функция использует конструктор копирования, если у объектов нет конструктора перемещения:
```cpp
template <typename T>
class Vector {
public:
    ...
    void Reserve(size_t new_capacity) {
        if (new_capacity <= data_.Capacity()) {
            return;
        }
        RawMemory<T> new_data(new_capacity);
        std::uninitialized_move_n(data_.GetAddress(), size_, new_data.GetAddress());
        std::destroy_n(data_.GetAddress(), size_);
        data_.Swap(new_data);
    }
    ...
};
```
Однако это решение надёжно сработает, только если перемещающий конструктор не выбрасывает исключений. Если исключение будет выброшено во время перемещения элементов в новую область памяти, часть элементов вектора окажется в опустошённом состоянии, и пользоваться ими будет небезопасно.

Перемещайте элементы, только если соблюдается хотя бы одно из условий:

- конструктор перемещения типа `T` не выбрасывает исключений;
- тип `T` не имеет копирующего конструктора.

В противном случае элементы надо копировать. 

Шаблоны [std::is_copy_constructible_v](https://en.cppreference.com/w/cpp/types/is_copy_constructible) и [std::is_nothrow_move_constructible_v](https://en.cppreference.com/w/cpp/types/is_move_constructible.html) помогают узнать, есть ли у типа копирующий конструктор и `noexcept`-конструктор перемещения. Выполняются эти шаблоны во время компиляции, что нам вскоре пригодится:
```cpp
#include <iostream>
#include <memory>
#include <type_traits>

int main() {
    std::cout << std::boolalpha;
    // Выведет true
    std::cout << std::is_nothrow_move_constructible_v<std::string> << std::endl;
    // Выведет false
    std::cout << std::is_copy_constructible_v<std::unique_ptr<int>> << std::endl;
}
```
Наивное и неработающее решение выглядит так:
```cpp
...
#include <type_traits>

template <typename T>
class Vector {
public:
    ...
    void Reserve(size_t new_capacity) {
        ...
        if (std::is_nothrow_move_constructible_v<T> || !std::is_copy_constructible_v<T>) {
            std::uninitialized_move_n(data_.GetAddress(), size_, new_data.GetAddress());
        } else {
            std::uninitialized_copy_n(data_.GetAddress(), size_, new_data.GetAddress());
        }
        ...
    }
    ...
};
```
Проблема в том, что компилятор будет генерировать код как для ветки `if`, так и для ветки `else`, потому что проверка условия будет выполняться во время работы программы. Если тип `T` не имеет конструктора копирования, компиляция ветки `else` завершится неудачей.

Чтобы решить проблему, нужно использовать [if constexpr](https://en.cppreference.com/w/cpp/language/if.html). Это версия оператора `if`, которая выполняется во время компиляции. Выражение в условии должно быть константой времени компиляции. В итоге скомпилируется только одна из двух веток, что и требуется:
```cpp
template <typename T>
class Vector {
public:
    ...
    void Reserve(size_t new_capacity) {
        ...
        // constexpr оператор if будет вычислен во время компиляции
        if constexpr (std::is_nothrow_move_constructible_v<T> || !std::is_copy_constructible_v<T>) {
            std::uninitialized_move_n(data_.GetAddress(), size_, new_data.GetAddress());
        } else {
            std::uninitialized_copy_n(data_.GetAddress(), size_, new_data.GetAddress());
        }
        ...
    }
    ...
}; 
```
Функции стандартной библиотеки, создающие объекты в неинициализированной памяти, позволили упростить реализацию класса `Vector` и оптимизировать метод `Reserve`. Пришло время применить их на практике.