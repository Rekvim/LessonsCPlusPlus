## Упрощаем работу с сырой памятью

В предыдущем уроке вы реализовали обработку исключений в конструкторах и в методе `Reserve` класса `Vector`. Теперь код надёжно обрабатывает исключения, но из-за обработчиков `try`/`catch` его стало труднее воспринимать:
```cpp
template <typename T>
class Vector {
public:
    explicit Vector(size_t size)
        : data_(Allocate(size))
        , capacity_(size)
        , size_(size)  //
    {
        size_t i = 0;
        try {
            for (; i != size; ++i) {
                new (data_ + i) T();
            }
        } catch (...) {
            // В переменной i содержится количество созданных элементов.
            // Теперь их надо разрушить
            DestroyN(data_, i);
            // Освобождаем память, выделенную через Allocate
            Deallocate(data_);
            // Перевыбрасываем пойманное исключение, чтобы сообщить об ошибке создания объекта
            throw;
        }
    }
    ...
};
```
Согласно идиоме RAII, жизненный цикл ресурса, который программа получает во временное пользование, должен привязываться ко времени жизни объекта. Создав объект, который владеет некоторым ресурсом, программа может использовать этот ресурс на протяжении жизни объекта.

Класс `Vector` владеет несколькими типами ресурсов:

- сырая память, которую класс запрашивает, используя `Allocate`, и освобождает, используя `Deallocate`;

- элементы вектора, которые создаются размещающим оператором `new` и удаляются вызовом деструктора.

Выделив код, управляющий сырой памятью, в отдельный класс-обёртку, вы упростите класс `Vector`.

Шаблонный класс `RawMemory` будет отвечать за хранение буфера, который вмещает заданное количество элементов, и предоставлять доступ к элементам по индексу:
```cpp
template <typename T>
class RawMemory {
public:
    RawMemory() = default;

    explicit RawMemory(size_t capacity)
        : buffer_(Allocate(capacity))
        , capacity_(capacity) {
    }

    ~RawMemory() {
        Deallocate(buffer_);
    }

    T* operator+(size_t offset) noexcept {
        // Разрешается получать адрес ячейки памяти, следующей за последним элементом массива
        assert(offset <= capacity_);
        return buffer_ + offset;
    }

    const T* operator+(size_t offset) const noexcept {
        return const_cast<RawMemory&>(*this) + offset;
    }

    const T& operator[](size_t index) const noexcept {
        return const_cast<RawMemory&>(*this)[index];
    }

    T& operator[](size_t index) noexcept {
        assert(index < capacity_);
        return buffer_[index];
    }

    void Swap(RawMemory& other) noexcept {
        std::swap(buffer_, other.buffer_);
        std::swap(capacity_, other.capacity_);
    }

    const T* GetAddress() const noexcept {
        return buffer_;
    }

    T* GetAddress() noexcept {
        return buffer_;
    }

    size_t Capacity() const {
        return capacity_;
    }

private:
    // Выделяет сырую память под n элементов и возвращает указатель на неё
    static T* Allocate(size_t n) {
        return n != 0 ? static_cast<T*>(operator new(n * sizeof(T))) : nullptr;
    }

    // Освобождает сырую память, выделенную ранее по адресу buf при помощи Allocate
    static void Deallocate(T* buf) noexcept {
        operator delete(buf);
    }

    T* buffer_ = nullptr;
    size_t capacity_ = 0;
}; 
```
Методы `Allocate` и `Deallocate` в классе `Vector` после этого станут не нужны — выделение и освобождение памяти берёт на себя `RawMemory`.

Тогда класс `Vector` вместо указателя `data_` и вместимости capacity_ сможет использовать одно поле `data_`:
```cpp
template <typename T>
class Vector {
public:
    explicit Vector(size_t size)
        : data_(size)
        , size_(size)  //
    {
        size_t i = 0;
        try {
            for (; i != size; ++i) {
                new (data_ + i) T();
            }
        } catch (...) {
            DestroyN(data_.GetAddress(), i);
            // Деструктор поля data_ освободит сырую память
            // автоматически при перевыбрасывании исключения
            throw;
        }
    }

    ~Vector() {
        DestroyN(data_.GetAddress(), size_);
    }
    ...
private:
    ...
    RawMemory<T> data_;
    size_t size_ = 0;
};
```
Теперь в деструкторе `Vector` и блоке `catch` конструктора более не нужно вызывать `Deallocate` — деструктор `RawMemory` сделает это автоматически. Похожие упрощения нужно сделать в копирующем конструкторе и методе `Reserve`.