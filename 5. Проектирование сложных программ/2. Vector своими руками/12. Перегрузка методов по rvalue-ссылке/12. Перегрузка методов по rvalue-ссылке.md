## Перегрузка методов по rvalue-ссылке

В этом уроке вы узнаете, как избежать избыточного копирования содержимого объектов, используя перегрузку методов и операций по `rvalue`-ссылке.

Рассмотрим мотивирующий пример — класс `Gold`, который моделирует золотой слиток заданного объёма:
```cpp
class Gold {
public:
    int GetAmount() const noexcept {
        return amount_;
    }
private:
    int amount_ = 0;
};
```

Золото нельзя создать из ничего. Его можно только добыть. Для этого объявим конструктор класса приватным, чтобы он не был доступен коду вне класса. Для добычи золота создадим статический метод `Mine`. Так как запасы золота на планете ограниченны, при его нехватке метод `Mine` выбросит исключение:
```cpp
class Gold {
public:
    static Gold Mine(int amount) {
        if (amount <= 0) {
            throw std::out_of_range("Invalid amount of gold."s);
        }
        cout << "Mine "sv << amount << " units of gold. "sv;
        if (amount > available_) {
            // Недостаточно золота в недрах планеты
            ostringstream msg;
            msg << "Out of gold. Only "sv << available_ << " units are available."sv;
            throw runtime_error(msg.str());
        }
        available_ -= amount;
        cout << available_ << " units left."sv << endl;
        return Gold(amount);
    }

    static int GetAvailableAmount() {
        return available_;
    }
    ...
private:
    // Конструктор объявлен приватным, чтобы создание золота было возможным только путём его добычи
    explicit Gold(int amount) noexcept
        : amount_(amount) {
    }

    // Количество золота в недрах Земли
    static inline int available_ = 100;
};
```
При разрушении объектов Gold золото возвращается в недра Земли:
```cpp
class Gold {
public:
    ...
    ~Gold() {
        Dispose();
    }
private:
    void Dispose() noexcept {
        if (amount_ != 0) {
            available_ += amount_;
            cout << "Dispose "sv << amount_ << " units of gold. "sv << available_
                 << " units available."sv << endl;
            amount_ = 0;
        }
    }
    ...
};
```
Чтобы создать копию слитка золота, нужно добыть его из недр Земли. Зато перемещение содержимого одного объекта `Gold` к другому — дешёвая операция. Когда золото присваивают, прежнее количество золота возвращается в недра, а затем происходит добыча или перемещение:
```cpp
class Gold {
public:
    // Чтобы скопировать золото, нужно его добыть
    Gold(const Gold& other) {
        *this = Mine(other.amount_);
    }
    // Просто перемещаем золото из одного места в другое
    Gold(Gold&& other) noexcept
        : amount_(other.amount_)  //
    {
        other.amount_ = 0;
    }

    Gold& operator=(const Gold& rhs) {
        if (this != &rhs) {
            Dispose();  // Возвращаем прежнее количество золота
            *this = Mine(rhs.amount_); // И добываем новое
        }
        return *this;
    }
    Gold& operator=(Gold&& rhs) noexcept {
        Dispose(); // Возвращаем прежнее количества золота
        // ... и забираем содержимое rhs
        amount_ = rhs.amount_;
        rhs.amount_ = 0;
        return *this;
    }
    ...
};
```

Из объекта `Gold` можно извлекать куски методом `Take`, пока золото не закончится:
```cpp
class Gold {
public:
    [[nodiscard]] Gold Take(int amount) {
        if (amount > amount_ || amount < 0) {
            throw std::invalid_argument("Invalid gold amount"s);
        }
        amount_ -= amount;
        return Gold(amount);
    }
    ...
};
```
Получился класс `Gold` с дорогими операциями копирования и дешёвыми операциями перемещения. На его основе создадим класс `Person`, владеющий золотом. Метод `GetGold` возвращает константную ссылку, чтобы никто не мог посягнуть на золотой запас владельца:
```cpp
class Person {
public:
    Person(string name, Gold gold)
        : name_(move(name))
        , gold_(move(gold))  //
    {
        cout << "Person "sv << name_ << " was created with "sv << gold_.GetAmount()
             << " units of gold."sv << endl;
    }

    // Запрещаем клонирование людей
    Person(const Person& other) = delete;
    Person& operator=(const Person&) = delete;

    ~Person() {
        cout << "Person "sv << name_ << " died."sv << endl;
    }

    const Gold& GetGold() const {
        return gold_;
    }
private:
    string name_;
    Gold gold_;
};
```
Смоделируем ситуацию, в которой Скрудж МакДак перед смертью завещал 50 единиц золота Чипу, Дейлу и Дональду Даку в размере 20, 20 и 10 единиц соответственно:
```cpp
Person MakePersonWithGold() {
    return Person("Scrooge McDuck"s, Gold::Mine(50));
}

int main() {
    try {
        Gold gold = MakePersonWithGold().GetGold();
        Person chip("Chip"s, gold.Take(20));
        Person dale("Dale"s, gold.Take(20));
        Person donald("Donald Duck"s, gold.Take(10));
    } catch (const exception& e) {
        cout << e.what() << endl;
    }

    cout << Gold::GetAvailableAmount() << " units of gold left."s << endl;
}
```
Запустим программу и увидим круговорот золота в природе:
```
Mine 50 units of gold. 50 units left.
Person Scrooge McDuck was created with 50 units of gold.

// При копировании состояния Скруджа из недр Земли происходит добыча 50 единиц золота.
Mine 50 units of gold. 0 units left.
Person Scrooge McDuck died.
Dispose 50 units of gold. 50 units available.

// Делёжка наследства.
Person Chip was created with 20 units of gold.
Person Dale was created with 20 units of gold.
Person Donald Duck was created with 10 units of gold.

// После смерти наследников золото вернулось обратно в недра планеты.
Person Donald Duck died.
Dispose 10 units of gold. 60 units available.
Person Dale died.
Dispose 20 units of gold. 80 units available.
Person Chip died.
Dispose 20 units of gold. 100 units available.
```
Немного изменим начальные данные, чтобы Скрудж владел 60 единицами золота, которые нужно поровну разделить между наследниками:
```cpp
Person MakePersonWithGold() {
    return Person("Scrooge McDuck"s, Gold::Mine(60)); // Было раньше 50
}

int main() {
    try {
        Gold gold = MakePersonWithGold().GetGold();
        Person chip("Chip"s, gold.Take(20));
        Person dale("Dale"s, gold.Take(20));
        Person donald("Donald Duck"s, gold.Take(20)); // Было раньше 10
    } catch (const exception& e) {
        cout << e.what() << endl;
    }
}
```
При запуске программы выбросится исключение из-за нехватки золота:
```
Mine 60 units of gold. 40 units left.
Person Scrooge McDuck was created with 60 units of gold.
Mine 60 units of gold. Person Scrooge McDuck died.
Dispose 60 units of gold. 100 units available.
Out of gold. Only 40 units are available. 
```
Чтобы разобраться в причинах проблемы, взглянем на строку:
```cpp
Gold gold = MakePersonWithGold().GetGold();
```
Сначала у Person вызывается метод GetGold, возвращающий константную ссылку на объект Gold. Затем вызывается конструктор копирования, добывающий 60 единиц золота. Так как в недрах планеты осталось только 40 единиц золота, выбрасывается исключение, и происходит раскрутка стека. В процессе раскрутки стека Скрудж МакДак умирает, его золото возвращается в недра планеты, но ситуация уже произошла — делёжка денег завершилась неудачей.

Когда объект, владеющий ресурсом, вот-вот будет разрушен, оптимальнее будет не копировать этот ресурс, а переместить к новому владельцу. Разберёмся, почему здесь не сработала семантика перемещения.

Метод `Person::GetGold` возвращает `const Gold&`, а не `Gold&&`, поэтому у переменной `gold` вызывается конструктор копирования. Наивным решением будет добавить неконстантную версию метода `GetGold` и использовать `move` для перемещения:
```cpp
class Person {
public:
    const Gold& GetGold() const {
        return gold_; // Создаётся копия золота
    }
    Gold& GetGold() {
        return gold_;
    }
    ...
};
int main() {
    // move превратит Gold& в Gold&&, и результат переместится в переменную gold
    Gold gold = move(MakePersonWithGold().GetGold());
}
```
Запустим и убедимся, что вместо копирования золота используется перемещение и нехватка золота не возникает:
```
// Жизнь и смерть Скруджа МакДака
Mine 60 units of gold. 40 units left.
Person Scrooge McDuck was created with 60 units of gold.
Person Scrooge McDuck died.

// Делим золото между наследниками
Person Chip was created with 20 units of gold.
Person Dale was created with 20 units of gold.
Person Donald Duck was created with 20 units of gold.

// Все умирают
Person Donald Duck died.
Dispose 20 units of gold. 60 units available.
Person Dale died.
Dispose 20 units of gold. 80 units available.
Person Chip died.
Dispose 20 units of gold. 100 units available.
```
Какие недостатки есть у этого решения? Можно выбрать несколько вариантов.

> Неидиоматичное использование функции `move`. Применение `move` к результату вызова метода выглядит непривычно. Если забыть вызвать `move`, вместо перемещения золота произойдёт копирование.

> Неконстантный метод `GetGold` нарушает инкапсуляцию. Используя ссылку на внутреннее поле `Person::gold_`, можно изменить состояние объекта в обход его методов.

> Вызывать метод `GetGold` у временного объекта опасно. Метод возвращает ссылку на поле `gold_`, которое будет разрушено вместе с объектом `Person`. Если сохранить ссылку на часть временного объекта, она станет невалидной уже к моменту выполнения следующей инструкции.
Как вам задача?


Чтобы безопасно получить ресурс у временного объекта в C++, применяйте перегрузку методов по `rvalue`-ссылке. Для этого метод объектов, доступных по `rvalue`-ссылке, дополнительно помечается символами `&&`. Метод, который должен вызываться у именованных объектов, помечается символом `&`:
```cpp
class Person {
public:
    // Метод вызывается у объектов, доступных по обычной lvalue-ссылке
    [[nodiscard]] const Gold& GetGold() const& {
        return gold_;
    }
    // Метод вызывается у объектов, доступных по rvalue-ссылке
    [[nodiscard]] Gold GetGold() && {
        return std::move(gold_);
    }
    ...
};
```
Метод `GetGold`, возвращающий константную ссылку, может быть вызван у обычных экземпляров, а метод `GetGold`, возвращающий золото по значению, — у объектов, которые доступны по `rvalue`-ссылке.
```cpp
int main() {
    Person person("Grigory Rasputin"s, Gold::Mine(10));
    // Объект g1 будет инициализирован конструктором копирования
    Gold g1 = person.GetGold();

    // g2 будет проинициализирован конструктором перемещения
    Gold g2 = Person("Ivan Susanin"s, Gold::Mine(10)).GetGold();

    // g3 будет проинициализирован конструктором перемещения
    Gold g3 = move(person).GetGold();
    assert(person.GetGold().GetAmount() == 0); // Золото перемещено от объекта person в g3

    // Ссылка g4 продлит жизнь золотому слитку, полученному у лепрекона до конца блока
    const Gold& g4 = Person("Leprechaun"s, Gold::Mine(15)).GetGold();
    assert(g4.GetAmount() == 15);
}
```
Вернём код функции main в исходное состояние и проверим его работу:
```cpp
int main() {
    try {
        Gold gold = MakePersonWithGold().GetGold();
        Person chip("Chip"s, gold.Take(20));
        Person dale("Dale"s, gold.Take(20));
        Person donald("Donald Duck"s, gold.Take(20));
    } catch (const exception& e) {
        cout << e.what() << endl;
    }
} 
```
```
// Жизнь и карьера Скруджа МакДака
Mine 60 units of gold. 40 units left.
Person Scrooge McDuck was created with 60 units of gold.
Person Scrooge McDuck died.

// Делёжка наследства
Person Chip was created with 20 units of gold.
Person Dale was created with 20 units of gold.
Person Donald Duck was created with 20 units of gold.

// И никого не стало...
Person Donald Duck died.
Dispose 20 units of gold. 60 units available.
Person Dale died.
Dispose 20 units of gold. 80 units available.
Person Chip died.
Dispose 20 units of gold. 100 units available.
```
Методы, перегруженные для `lvalue` и `rvalue`-ссылок, можно делать недоступными для вызова. Для этого используют `= delete`:
```cpp
class Person {
public:
    // Метод вызывается у объектов, доступных по обычной lvalue-ссылке
    [[nodiscard]] const Gold& GetGold() const& {
        return gold_;
    }
    // Запрещаем вызов метод GetGold у временных объектов
    [[nodiscard]] Gold GetGold() && = delete;
    ...
};

int main() {
    // Ошибка: error: use of deleted function 'Gold Person::GetGold() &&'
    Gold gold = Person("Scrooge McDuck"s, Gold::Mine(10)).GetGold();
}
```
Этот приём помогает защититься от случайного получения ссылок и указателей на ресурсы, которые удалятся вместе с объектом.

В задании вам предстоит применить перегрузку методов и операторов по `rvalue` и `lvalue`-ссылкам в классе `Optional`, чтобы избежать избыточных копирований.