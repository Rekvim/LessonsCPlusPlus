## Конструкторы и деструкторы

В прошлом уроке мы раскрыли секрет волшебной шляпы. Указатель `vtable`, таблица виртуальных методов и позднее связывание — три элемента, на которых строится механизм фокуса. Мы обнаружили, что в каждом объекте содержится 8 дополнительных байт. Это потайное дно, где хранится указатель на виртуальную таблицу. 

Но кроме этих 8 байт для указателя программе нужно где-то хранить сами таблицы. Вы уже легко оперируете понятием алгоритмической сложности программы. Однако кроме оценки количества операций важно уметь оценивать количество затраченной памяти.

Принцип оценки тот же: насколько быстро растёт объём затрачиваемой памяти в зависимости от входных параметров. Это называется оценка пространственной сложности.

В терминах пространственной сложности, как вы считаете, сколько памяти будет затрачено на хранение виртуальных таблиц для объектов класса? Здесь N — количество объектов одного класса с виртуальными методами в программе.

> $O(1)$

Адреса виртуальных методов одинаковы для всех объектов класса. Нет смысла хранить таблицу для каждого объекта, так как она будет для всех одинакова. Это значит, что затраченная память не зависит от числа объектов и будет константной.
Убедимся на практике. Сначала разберёмся, где внутри объекта расположен указатель на виртуальную таблицу. Пока мы видели только объекты без полей данных. Добавим в классы из примера поля данных и рассмотрим строение объекта внимательнее:
```cpp
class HatWithApples : public MagicHat {
public:
    void WhatInside() const {
        cout << "Apple"s << endl;
    }
    bool HasSomethingInside() const {
        cout << "Yes. Something red and tasty"s << endl;
        return true;
    }

private:
    /* 10 яблок лежало в шляпе */
    int apples_count = 10;
};

class HatWithRabbits : public MagicHat {
public:
    void WhatInside() const {
        cout << "Rabbit"s << endl;
    }
    bool HasSomethingInside() const {
        cout << "Yes. Several furry carrot lovers"s << endl;
        return true;
    }

private:
    /* 3 кролика сидело в шляпе */
    int rabbits_count = 3;
    /* каждому кролику полагается две морковки, чтобы пережить фокус без стресса */
    int carrot_count = 6;
};
```
Взгляните на расположение полей в памяти:
```
*** Dumping AST Record Layout
         0 | class HatWithApples
         0 |   class MagicHat (primary base)
         0 |     (MagicHat vftable pointer)
         8 |   int apples_count
           | [sizeof=16, align=8,
           |  nvsize=16, nvalign=8]

*** Dumping AST Record Layout
         0 | class HatWithRabbits
         0 |   class MagicHat (primary base)
         0 |     (MagicHat vftable pointer)
         8 |   int rabbits_count
        12 |   int carrot_count
           | [sizeof=16, align=8,
           |  nvsize=16, nvalign=8] 
```
Указатель на виртуальную таблицу остался в начале объекта, вне зависимости от количества полей. Исходя из этого, функция для печати адреса виртуальной таблицы будет выглядеть так:
```cpp
void PrintVptr(void* obj) {
    auto ptr = reinterpret_cast<size_t*>(obj);
    cout << "Vptr : "s << *ptr << endl;
}
```
Здесь использование `reinterpret_cast` не приведёт к страданию кроликов. Нам действительно нужно именно так интерпретировать адрес объекта.

Передадим в эту функцию объекты следующим образом:
```cpp
HatWithApples apple_hat1;
HatWithApples apple_hat2;
HatWithRabbits rabbit_hat1;
HatWithRabbits rabbit_hat2;
HatWithDoves dove_hat1;
HatWithDoves dove_hat2;

vector<MagicHat*> hats = {&apple_hat1, &apple_hat2, 
                          &rabbit_hat1, &rabbit_hat2, 
                          &dove_hat1, &dove_hat2};
for (auto hat : hats) {
    PrintVptr(hat);
} 
```
В результате работы программы на экран будет выведено:
```
Vptr : 4220656
Vptr : 4220656
Vptr : 4220688
Vptr : 4220688
Vptr : 4220624
Vptr : 4220624 
```
Адреса попарно равны для объектов одинаковых типов. Адреса одинаковые, значит, они ссылаются на одну и ту же таблицу. Это то, чего мы ожидали. Таблица для всех объектов класса одна и внутри каждого объекта класса содержится указатель на неё.

Воспользуемся этой же функцией, печатающей адреса виртуальной таблицы, чтобы выяснить, что происходит с `vptr` в конструкторах и деструкторах. Создадим на стеке три переменных. Их деструкторы будут вызваны при выходе из функции `main` автоматически.
```cpp
void PrintVptr(void* obj) {
    auto ptr = reinterpret_cast<size_t*>(obj);
    cout << "Vptr : "s << *ptr << endl;
}

class MagicHat {
public:
    MagicHat() {
        cout << "MagicHat::Ctor : "s;
        PrintVptr(this);
    }
    ~MagicHat() {
        cout << "MagicHat::Dtor : "s;
        PrintVptr(this);
    ...
};

class HatWithApples : public MagicHat {
public:
    HatWithApples() {
        cout << "HatWithApples::Ctor : "s;
        PrintVptr(this);
    }
    ~HatWithApples() {
        cout << "HatWithApples::Dtor : "s;
        PrintVptr(this);
    }
    ...
};

class HatWithRabbits : public MagicHat {
public:
    HatWithRabbits() {
        cout << "HatWithRabbits::Ctor : "s;
        PrintVptr(this);
    }
    ~HatWithRabbits() {
        cout << "HatWithRabbits::Dtor : "s;
        PrintVptr(this);
    ...
};

class HatWithDoves : public MagicHat {
public:
    HatWithDoves() {
        cout << "HatWithDoves::Ctor : "s;
        PrintVptr(this);
    }
    ~HatWithDoves() {
        cout << "HatWithDoves::Dtor : "s;
        PrintVptr(this);
    }
    ...
};

int main() {
    HatWithApples hat1;
    HatWithRabbits hat2;
    HatWithDoves hat3;
} 
```
Результат работы программы:
```
MagicHat::Ctor : Vptr : 4220880
HatWithApples::Ctor : Vptr : 4220816
MagicHat::Ctor : Vptr : 4220880
HatWithRabbits::Ctor : Vptr : 4220848
MagicHat::Ctor : Vptr : 4220880
HatWithDoves::Ctor : Vptr : 4220784
HatWithDoves::Dtor : Vptr : 4220784
MagicHat::Dtor : Vptr : 4220880
HatWithRabbits::Dtor : Vptr : 4220848
MagicHat::Dtor : Vptr : 4220880
HatWithApples::Dtor : Vptr : 4220816
MagicHat::Dtor : Vptr : 4220880 
```
Вы уже знаете, почему на экран вывелось так много информации. Внутри каждого объекта прячется объект базового класса. Поэтому каждому объекту вызывается два конструктора, а потом два деструктора соответственно.

Выделим то, что касается одного вида шляпы. Например, шляпы с яблоками:
```
MagicHat::Ctor : Vptr : 4220880
HatWithApples::Ctor : Vptr : 4220816
HatWithApples::Dtor : Vptr : 4220816
MagicHat::Dtor : Vptr : 4220880
```
В конструкторе базового объекта `MagicHat` указатель `vtpr` указывает на одну таблицу, а в конструкторе `HatWithApples` — уже на другую. Иными словами, указатель `vptr` перед вызовом конструктора устанавливается на таблицу виртуальных функций того класса, конструктор которого вызывается. Это нужно, чтобы внутри конструктора гарантированно вызывать только методы именно данного класса. Такой механизм гарантирует, что конструктор базового объекта не попытается обратиться к методам класса-наследника, который на данный момент ещё не сконструирован.

С деструкторами, казалось бы, всё так же. Но здесь кроется небольшой подвох. Какой?

> При компиляции не всегда известно, какой динамический тип у удаляемого объекта.

Комментарий: При вызове `delete` должно случиться следующее:
1. Вызов деструктора соответствующего класса;
   
2. Освобождение динамически выделенной памяти.
   
Но во время компиляции может быть неизвестен динамический тип объекта, поэтому использовать раннее связывание в первом пункте будет невозможно.

Посмотрите на пример:
```cpp
MagicHat* hat;
if (...) {
    hat = new HatWithApples();
} else {
    hat = new HatWithRabbits();
}
delete hat; 
```
В примере выше компилятор не может определить тип удаляемого объекта. Если в этот момент использовать раннее связывание и вызвать деструктор только для `MagicHat`, не все ресурсы могут быть освобождены корректно. Ведь на самом деле объект имеет другой тип. Более того, компилятор может сообщить вам об опасности через предупреждение:
```
warning: deleting object of polymorphic class type 'MagicHat' which has non-virtual 
destructor might cause undefined behavior [-Wdelete-non-virtual-dtor]
      delete hat;
             ^~~ 
```
В предупреждении есть подсказка, как решить проблему: просто деструктор класса, содержащего виртуальные методы, тоже должен быть виртуальным. Тогда позднее связывание решит задачу, будет вызван деструктор из виртуальной таблицы соответствующего класса. Все ресурсы освободятся.