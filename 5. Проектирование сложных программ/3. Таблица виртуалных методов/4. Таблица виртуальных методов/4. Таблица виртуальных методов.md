## Таблица виртуальных методов

Разберёмся во vtable глубже. Для этого воспользуемся другим флагом компиляции:
```
clang -Xclang -fdump-vtable-layouts magic.cpp 
```
Мы увидим информацию о всех виртуальных таблицах, использующихся в программе. Нас интересуют только волшебная шляпа и классы, наследованные от неё:
```
VFTable for 'MagicHat' in 'HatWithApples' (3 entries).
   0 | HatWithApples RTTI
   1 | void HatWithApples::WhatInside() const
   2 | bool HatWithApples::HasSomethingInside() const

VFTable for 'MagicHat' in 'HatWithRabbits' (3 entries).
   0 | HatWithRabbits RTTI
   1 | void HatWithRabbits::WhatInside() const
   2 | bool HatWithRabbits::HasSomethingInside() const

VFTable for 'MagicHat' in 'HatWithDoves' (3 entries).
   0 | HatWithDoves RTTI
   1 | void HatWithDoves::WhatInside() const
   2 | bool HatWithDoves::HasSomethingInside() const 
```
У каждого класса, содержащего виртуальные методы, есть своя виртуальная таблица. Можно даже в общих чертах понять, что в ней содержится. Главное: в ней перечислены именно те методы, которые должны быть вызваны для объекта данного класса.

У шляпы с яблоками своя виртуальная таблица. При создании объекта `HatWithApples` указатель `vftable` будет инициализирован адресом именно на таблицу шляпы с яблоками. При этом пользователю будет возвращён указатель на волшебную шляпу. Но волшебная шляпа внутри шляпы с яблоками имеет нулевое смещение. Иначе говоря, адрес шляпы с яблоками и адрес внутренней волшебной шляпы — один и тот же. Внутри объекта в это время находится указатель на таблицу виртуальных методов именно шляпы с яблоками.

Вспомним теперь, что происходит с программой на этапе компоновки. Кроме того, что компоновщик проверяет импорт и экспорт каждого из модулей, он ещё и определяет адреса тех функций, которые должны быть вызваны. Когда программа затем будет запущена, на месте вызова функции будет просто стоять переход по конкретному адресу. Эти адреса становятся известны при компиляции, и такой механизм называется ранним связыванием.
Посмотрите ещё раз на информацию о виртуальной таблице:
```
VFTable for 'MagicHat' in 'HatWithApples' (3 entries).
   0 | HatWithApples RTTI
   1 | void HatWithApples::WhatInside() const
   2 | bool HatWithApples::HasSomethingInside() const 
```
Здесь упоминается некий RTTI. RTTI — это аббревиатура для “run-time type identification”, или, по-русски, динамическая идентификация типа данных. Видя указание на этот механизм, можно предположить, что тип данных на момент компиляции ещё неизвестен. Раз тип данных неизвестен, компоновщик не может определить, какая именно функция какого класса будет вызвана. Адрес функции не определён.

Но чтобы вызов функции всё-таки случился, когда тип объекта становится известен, происходит следующее:

- Программа видит, что пользователь просит вызвать метод `WhatInside`.
- Программа не находит адреса вызова функции, но видит, что этот метод — виртуальный.
- Программа обращается по адресу указателя `vftable` и находит указатель на метод `WhatInside` внутри таблицы виртуальных методов.
- Вызывает функцию из виртуальной таблицы.

Такой процесс называется позднее связывание. Позднее, потому что у компилятора нет достаточно информации, чтобы разобраться с адресами функций во время подготовки к запуску. Эта информация становится известна только в процессе работы программы.

Позднее связывание — часть фокуса с полиморфизмом. Но, используя такой вид связывания, нужно помнить, что то, что не было проверено компилятором до запуска, может сломаться во время работы. Например, в виртуальной таблице может не оказаться нужного метода. Или этот метод будет не тем, который вы ожидали. Всего этого не нужно бояться. Если позаботитесь о тестировании, всё будет в порядке и фокус пройдёт без сучка, без задоринки.

<div class="callout">
В C++ везде, где возможно, используется раннее связывание, потому что оно дешевле в плане затрат времени во время работы программы. C++ всеми силами старается не снижать быстродействие программы. В Java же, например, стандартный тип связывания — поздний. Это совсем другой подход, у которого есть свои плюсы и свои минусы.
</div>

А что будет, если у шляпы с яблоками нет метода `WhatInside` ?

> Наследование решит проблему.

Не найдя этого метода ни в обычных методах класса `HatWithApples`, ни в виртуальной таблице для `HatWithApples`, программа поищет его в виртуальной таблице базового класса. Там этот метод есть. Будет вызван именно он.