## Pure virtual

В прошлом уроке вы узнали, как С++ справляется с вызовом виртуальных методов внутри конструкторов и деструкторов. Теперь посмотрим, что происходит с вызовом абстрактных методов.

Абстрактным называют метод, который нельзя осмысленно определить для данного класса, но который будет иметь смысл для потомков. В уроке о виртуальных классах был пример метода GetArea — у него нет смысла для базового класса Shape.

Допустим, вы не стали ничего менять в классах и переписали конструктор волшебной шляпы так:
```cpp
class MagicHat {
public:
    MagicHat() {
        cout << "MagicHat::Ctor"s;
        if (HasSomethingInside()) {
            WhatInside();
        }
    }
    ~MagicHat() {
        cout << "MagicHat::Dtor"s;
        PrintVptr(this);
    }
    virtual void IsMagicHat() const {
        cout << "MagicHat:: I'm a magic hat"s << endl;
    }
    virtual void WhatInside() const {
        cout << "Nothing"s << endl;
    }
    virtual bool HasSomethingInside() const {
        cout << "Nope"s << endl;
        return false;
    }
}; 
```
Что произойдёт?

> Раннее связывание: всегда будут вызываться методы `HasSomethingInside` и `WhatInside` класса `MagicHat`.

Внутри конструктора в данном случае могут быть вызваны только методы класса `MagicHat`. Объект класса-наследника ещё не сконструирован. Так как гарантируется вызов методов текущего класса, связывание будет раннее. Оно не добавляет накладных расходов на вызов метода во время работы программы, а значит, дешевле с точки зрения эффективности.

Пусть теперь методы `WhatInside` и `HaveSomethingInside` станут абстрактными. Оставим их реализацию во всех классах-наследниках, но объявим их `= 0` в классе `MagicHat`:
```cpp
class MagicHat {
public:
    MagicHat() {
        cout << "MagicHat::Ctor"s;
        if (HasSomethingInside()) {
            WhatInside();
        }
    }
    ~MagicHat() {
        cout << "MagicHat::Dtor"s;
        PrintVptr(this);
    }
    virtual void IsMagicHat() const {
        cout << "MagicHat:: I'm a magic hat"s << endl;
    }
    virtual void WhatInside() const = 0;
    virtual bool HasSomethingInside() const = 0;
};
```
Теперь при всём желании пользователь не сможет создать объект класса `MagicHat` в своей программе. Такой код не скомпилируется, несмотря на то что пользователь вызывает метод, определённый в `MagicHat`:
```cpp
int main() {
    MagicHat hat;
    hat.IsMagicHat();
}
```
Компилятор сообщает о проблеме:
```
In function 'int main()':
error: cannot declare variable 'hat' to be of abstract type 'MagicHat'
     MagicHat hat;
              ^~~
note:   because the following virtual functions are pure within 'MagicHat':
 class MagicHat {
       ^~~~~~~~
note:      'virtual void MagicHat::WhatInside() const'
     virtual void WhatInside() const = 0;
                  ^~~~~~~~~~
note:      'virtual bool MagicHat::HasSomethingInside() const'
     virtual bool HasSomethingInside() const = 0; 
```

Но на самом деле объекты типа `MagicHat` существуют — внутри объектов классов-наследников. То есть конструктор этого метода точно будет вызван, если, например, создать объект класса `HatWithApples`. 

Здесь должен был быть вопрос «Что случится, если создать объект `HatWithApples`?»
```cpp
class MagicHat {
public:
    MagicHat() {
        cout << "MagicHat::Ctor"s;
        if (HasSomethingInside()) {
              WhatInside();
        }
    }
    ~MagicHat() {
        cout << "MagicHat::Dtor"s;
        PrintVptr(this);
    }
    virtual void IsMagicHat() const {
          cout << "MagicHat:: I'm a magic hat"s << endl;
    }
    virtual void WhatInside() const = 0;
    virtual bool HasSomethingInside() const = 0;
};

class HatWithApples : public MagicHat {
public:
    HatWithApples() {
        cout << "HatWithApples::Ctor"s;
    }
    ~HatWithApples() {
        cout << "HatWithApples::Dtor"s;
    }
    void IsMagicHat() const {
            cout << "HatWithApples:: I'm a simple hat"s << endl;
    }
    void WhatInside() const {
        cout << "Apple"s << endl;
    }
    bool HasSomethingInside() const {
        cout << "Yes. Something red and tasty"s << endl;
        return true;
    }

private:
    int apples_count_ = 10;
};

int main() {
    HatWithApples hat;
    hat.IsMagicHat();
}
```
Но вопроса не будет, потому что поведение кода выше зависит от компилятора. Некоторые компиляторы отказываются собирать такую программу — сообщают, что тела функций `WhatInside` и `HasSomethingInside` не найдены. Другие компиляторы собирают программу с предупреждениями. Но при запуске такая программа падает.

Обычно решение о компиляторе принимается не программистом. Когда вы придёте работать над реальным проектом, компилятор уже будет выбран. В идеале это будет тот самый Компилятор, который спасёт от подобной ошибки. Но так получается не всегда. Берегите себя и свои программы, читайте предупреждения компилятора, даже когда программа собрана. И не вызывайте абстрактные методы в конструкторах.