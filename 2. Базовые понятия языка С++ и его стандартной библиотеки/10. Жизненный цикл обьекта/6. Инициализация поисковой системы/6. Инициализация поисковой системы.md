## Деструкторы и время жизни объекта
В прошлых уроках вы научились работать с конструктором — особым методом класса. Его основная задача — инициализация объекта, после которой все поля объекта находятся в согласованном состоянии. Конструктор объекта вызывается один раз — в тот момент, когда объявляется переменная класса:
```cpp
// В момент объявления переменной вызывается конструктор класса string
string name = "Hello"s; 
```
На протяжении всей жизни объекта мы можем с ним взаимодействовать через публичные методы класса. Каждый вызов публичного метода может переводить объект в новое состояние, изменяя значения его полей, либо оставлять объект в прежнем состоянии. Методы, которые не влияют на состояние объекта, мы объявляем константными. Константные методы гарантируют, что состояние объекта при их вызове не изменится. Это позволяет вызывать их у константных объектов.

Но объекты программы не живут вечно. Рано или поздно их жизнь подходит к концу. Поэтому у класса есть ещё один специальный метод — деструктор.
#### Знакомство с деструктором
Деструктор автоматически вызывается в конце жизни объекта. Имя деструктора совпадает с именем класса. Разница в том, что перед именем деструктора ставится символ `~` (тильда), а параметры не указываются:
```cpp
class SomeClass {
public:
    // Это деструктор
    ~SomeClass() {
    }
}; 
```
У класса бывает несколько конструкторов, задающих различные способы инициализации объекта. Но деструктор у класса может быть только один.

Основная задача деструктора — освободить ресурсы, которые объект использовал на протяжении цикла жизни. Например:
- освободить память, динамически выделяемую с использованием низкоуровневых функций языка или операционной системы;
- закрыть открытые файлы и сетевые соединения.
  
Знакомые вам классы стандартных контейнеров `string`, `vector`, `map` и set динамически запрашивают память у системы, когда вы добавляете в них элементы, и освобождают ее, когда вы элементы удаляете. Деструкторы этих коллекций освобождают память от оставшихся элементов, которые вы не удалили явно:
```cpp
int main() {
    vector<int> strings;
    for (int i = 0; i < 100; ++i) {
        strings.push_back(i);
    }
} 
```
Здесь в `vector` добавили сотню элементов. Но беспокоиться о том, чтобы освободить занимаемую ими память, не стóит. Деструктор класса `vector` будет вызван автоматически и сделает это за нас.

Писать собственный деструктор при повседневном программировании на C++ нужно довольно редко, особенно если пользуетесь классами стандартной библиотеки C++ и других популярных библиотек вроде *boost*. Эти библиотеки созданы опытными программистами и предоставляют удобные классы, которые автоматизируют управление памятью и другими ресурсами.

Свой деструктор понадобится при разработке классов, использующих низкоуровневые функции операционной системы и компоненты, написанные на других языках. В следующих спринтах вы встретитесь с подобными задачами.
#### Время жизни объекта
Чтобы узнать, в какой момент вызывается деструктор, рассмотрим класс `Greeter`, выводящий сообщения в своём конструкторе и деструкторе:
```
class Greeter {
public:
    Greeter(const string& name)
        : name_(name) 
    {
        cout << "Hello, "s << name_ << "!"s << endl;
    }

    ~Greeter() {
        // Поля класса внутри деструктора еще не уничтожены, и к ним можно обращаться
        cout << "Goodbye, "s << name_ << "!"s << endl;
    }
private:
    string name_;
}; 
```
Создадим этот объект внутри цикла по массиву имён:
```
int main() {
    vector<string> names = {
        "Ivan"s,
        "Vladimir"s,
    };
    for (const string& name : names) {
        cout << "Begin"s << endl;
        Greeter greeter(name);
        cout << "End"s << endl;
    }
} 
```
Запустим программу и увидим следующее:
```
Begin
Hello, Ivan!
End
Goodbye, Ivan!
Begin
Hello, Vladimir!
End
Goodbye, Vladimir! 
```
В начале каждой итерации цикла `for` выведется текст `Begin`. Затем будет вызван конструктор по умолчанию, выводящий приветствие. Потом выведется текст `End`, и только после последней инструкции будет вызван деструктор, выводящий прощание. На следующей итерации цикла процесс повторится снова.

Итак, в C++ для деинициализации используется деструктор — метод класса, вызываемый в конце жизненного цикла объекта. Время жизни переменной в C++ ограничено блоком, внутри которого она объявлена. При выходе из блока происходит вызов деструкторов объявленных в нём переменных. Деструкторы объектов вызываются в порядке, обратном конструированию объектов.

В других ситуациях — например, для полей класса или глобальных переменных — порядок и время вызова конструкторов и деструкторов можно выяснить самостоятельно. Просто напишите класс с выводом в конструкторе и деструкторе.

Теперь изменим код функции `main`, добавив в него ветвление:
```cpp
#include <cmath>
#include <iostream>

using namespace std;

/* код класса Greeter */

int main() {
    double n;
    cin >> n;
    
    Greeter greeter1("1"s);
    if (n < 0) {
        cout << n << " is negative"s << endl;
        return 0;
    } else {
        Greeter greeter2("2"s);
        cout << "sqrt("s << n << ") = "s << sqrt(n) << endl;
    }
    Greeter greeter3("3"s);
} 
```
Запустим программу и попробуем ввести число -10:
```
**-10**
Hello, 1!
-10 is negative
Goodbye, 1! 
```
После ввода отрицательного числа был вызван конструктор класса `Greeter`, выводящий строчку `"Hello, 1!"`. Затем поток выполнения попадёт внутрь положительного условия `if`, где будет выведено сообщение о невозможности извлечения корня. Следом оператор `return 0` выполнит выход из функции. На этом время жизни переменной `greeter1` закончится, будет вызван её деструктор. Он выведет строку `Goodbye, 1!`.

Если же запустить программу и ввести неотрицательное число, вывод программы изменится:
```
9
Hello, 1!
Hello, 2!
sqrt(9) = 3
Goodbye, 2!
Hello, 3!
Goodbye, 3!
Goodbye, 1! 
```

Деструктор переменной `greeter2` вызван сразу после вывода квадратного корня, то есть при выходе из блока `else`, ограничивающего область видимости этой переменной. Деструктор переменной `greeter3` вызван раньше деструктора `greeter1`.

В C++ время жизни переменной ограничивается блоком, где она объявлена. При этом переменные, которые в этом блоке объявлены раньше, будут разрушены в последнюю очередь. То есть порядок разрушения объектов обратен порядку их конструирования.

Теперь попробуем передать `Greeter` в качестве параметра функции:
```cpp
void Fn(Greeter g) {
    Greeter g1("function body"s);
}

int main() {
    Fn({"function parameter"s});
}
```
Вывод программы:
```
Hello, function parameter!
Hello, function body!
Goodbye, function body!
Goodbye, function parameter! 
```
При вызове функции `Fn` будет сконструирован объект `Greeter` и передан в качестве аргумента функции. Его время жизни будет дольше времени жизни объекта, объявленного внутри тела функции. Опять-таки, объект, созданный раньше, будет разрушен позже.

Похожая картина будет наблюдаться и при возврате из функции. Рассмотрим вызов функции, возвращающей объект `Greeter`.
```cpp
Greeter ReturnGreeter() {
    return {"result"s};
}

int main() {
    Greeter result = ReturnGreeter();
    Greeter body("body"s);
} 
```
Вывод программы:
```
Hello, result!
Hello, body!
Goodbye, body!
Goodbye, result! 
```
Сначала будет создан объект `Greeter` и возвращён из функции, затем он будет сохранен переменной `result`, до того как будет создана переменная `body`. И снова разрушение этих объектов произойдёт в противоположном порядке.

Теперь попробуем просто вызвать `ReturnGreeter`, но не будем сохранять результат ни в какой переменной:
```cpp
Greeter ReturnGreeter() {
    return {"result"s};
}

int main() {
    ReturnGreeter();
    Greeter body("body"s);
} 
```
В этот раз вывод программы изменится:
```
Hello, result!
Goodbye, result!
Hello, body!
Goodbye, body! 
```
В отличие от предыдущего примера мы не сохранили результат вызова функции в переменной. Теперь у возвращённого временного объекта нет имени, по которому к нему можно обратиться, поэтому он будет разрушен сразу после окончания инструкции вызова `ReturnGreeter();`.