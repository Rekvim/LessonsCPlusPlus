## Параметризованный конструктор
Вы научились задавать для полей объекта значение по умолчанию. Так все данные объекта после его создания будут согласованными.
Но используя класс `Rational`, сталкиваемся с проблемами.

- Код, который выполняет инициализацию, слишком громоздкий. В нём целых три строки:
  
```
Rational x;
// Задаём для дроби значение 1/3
x.SetNumerator(1);
x.SetDenominator(3); 
```
- Другую проблему рассмотрим на примере. Объявим константную переменную типа `Rational`, равную `1/3`:

```cpp
const Rational scale;
// Ошибка компиляции: 'this' argument to member function 'SetNumerator' 
// has type 'const Rational', but function is not marked const
scale.SetNumerator(1);
// Здесь будет аналогичная ошибка
scale.SetDenominator(3); 
```
Компилятор напоминает, что у константного объекта можно вызывать только константные методы. Методы `SetNumerator` и `SetDenominator` предназначены для изменения дроби, поэтому мы и не можем их вызвать — константные объекты изменять нельзя.

Эти проблемы решит параметризованный конструктор. Он принимает один или более параметров:
```cpp
class Rational {
public:
    // Явно сообщаем компилятору, что в этом классе нужно создать конструктор по умолчанию
    Rational() = default;

    // Параметризованный конструктор
    Rational(int numerator, int denominator) {
        numerator_ = numerator;
        denominator_ = denominator;
    }

    int Numerator() const {
        return numerator_;
    }

    int Denominator() const {
        return denominator_;
    }

private:
    // Задаём значения по умолчанию для числителя и знаменателя
    int numerator_ = 0;
    int denominator_ = 1;
}; 
```
Если в классе объявлен параметризованный конструктор, конструктор по умолчанию для этого класса сгенерирован не будет. Наличие конструктора с параметрами как бы сообщает компилятору: «Этот класс требует особой инициализации». Если конструктор по умолчанию всё-таки нужен, вы можете написать его сами либо попросить компилятор. Для этого вместо тела конструктора укажите `= default` и задайте полям значения по умолчанию.

Чтобы использовать параметризованный конструктор, передадим ему параметры в скобках после имени переменной:
```
int main() {
    const Rational scale(1, 3);

    cout << scale.Numerator() << "/"s << scale.Denominator() << endl;
}
```
Применив параметризованный конструктор, мы не только избавились от многословности при объявлении объекта, но и смогли задать начальное состояние константных объектов. Часто в классах делают несколько конструкторов, задающих различные способы инициализации объектов.