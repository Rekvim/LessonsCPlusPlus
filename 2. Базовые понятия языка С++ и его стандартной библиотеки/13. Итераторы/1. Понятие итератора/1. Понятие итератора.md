## Понятие итератора
Программисты любят использовать то, что уже написано. Причин на это много. Среди них наверняка есть и лень. Но гораздо важнее другое: если что-нибудь уже написано, значит это протестировано, ошибки найдены и исправлены. Если не все, то хотя бы часть. Поэтому программисты рады, когда менять в коде надо совсем мало. Чем меньше, тем лучше. Меньше изменений, меньше ошибок, меньше времени на разработку.

Чтобы избежать будущих изменений и сделать код более гибким, программисты прибегают к приёму, который можно назвать «добавление уровня абстракции».

Рассмотрим пример:
```cpp
#include <iostream>
using namespace std;
int main() {
    cout << "Платочки белые"s << endl;
    cout << "Платочки белые"s << endl;
    cout << "Платочки белые"s << endl;
    cout << "Платочки белые, глаза печальные"s << endl;
    cout << "Вагончик тронется"s << endl;
    cout << "Вагончик тронется"s << endl;
    cout << "Вагончик тронется"s << endl;
    cout << "Вагончик тронется, перрон останется"s << endl;
}
```

Если окажется, что платочки не белые, а синие, придётся поправить это в четырёх местах. Шанс ошибиться и забыть внести нужное исправление достаточно большой.

Добавляем новый уровень абстракции — переменные, куда положим строки:
```cpp
#include <iostream>
#include <string>
using namespace std;
int main() {
    string chorus_1 = "Платочки белые"s;
    string chorus_2 = "Вагончик тронется"s;
    cout << chorus_1 << endl;
    cout << chorus_1 << endl;
    cout << chorus_1 << endl;
    cout << chorus_1 <<", глаза печальные"s << endl;
    cout << chorus_2 << endl;
    cout << chorus_2 << endl;
    cout << chorus_2 << endl;
    cout << chorus_2 << ", перрон останется"s << endl;
}
```
Теперь заменить цвет платочков стало гораздо проще. Мы абстрагировались от конкретной строки и работаем с переменной. Переменная — наш новый уровень абстракции.

Если пофантазировать с этим примером дальше, можно найти и такую абстракцию как цикл. За ней будет прятаться повторение строчек нужное количество раз. А мы увидим, что циклов уже два, и добавим ещё один уровень абстракции — функцию. Потом подумаем, что, может быть, не хотим выводить всю песню на консоль, и было бы здорово записать её в файл или отправить в сеть. Будут появляться всё более и более высокие уровни абстракции, которые позволят делать код гибче. Именно так когда-то была придумана концепция итераторов.
Отвлекитесь от платочков, нас ждут более насущные дела — итерация по контейнерам.

Для каждого контейнера переход от одного элемента к другому может осуществляться разными способами. Например, чтобы перейти с одного элемента вектора на другой, нужно просто сдвинуться в памяти компьютера вперёд на размер одного элемента вектора. Во множестве и словаре будет иначе. Возникают вопросы:
- Должен ли запускаемый алгоритм знать эти различия?
  
- Если пишем алгоритмы под каждый контейнер, каков шанс, что ошибка, найденная в одном из алгоритмов, будет исправлена в другом?

Гораздо удобнее придумать новую абстракцию и научить алгоритмы работать с ней, а за каждой абстракцией спрятать конкретную реализацию.

Вспомним уже известный вам алгоритм `count`:
```cpp
const vector<int> xs = {1, 2, 1, 1, 5};
cout << count(xs.begin(), xs.end(), 1) << endl; // 3
```
Методы `xs.begin()` и `xs.end()` возвращают итераторы, и дальше алгоритм `count` работает именно с итераторами. Через них алгоритм получает доступ к элементам контейнера, может итерировать по элементам, но к самому контейнеру у алгоритма доступа нет. Вектор остаётся неизменным. Не меняется порядок элементов, размер не увеличивается и не уменьшается. Сделать это через итераторы нельзя. Получается, что итераторы ещё и защищают контейнер от неожиданных изменений. При этом заменить `vector` на другой контейнер не составит труда.