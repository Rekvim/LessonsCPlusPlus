## Концепция полуинтервалов
В этом уроке вы познакомитесь с концепцией полуинтервалов и узнаете, как она связана с итераторами.
#### Элемент, которого нет
Вернёмся к задаче из предыдущего урока:
```cpp
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct Lang {
    string name;
    int age;
};

int main() {
    vector<Lang> langs = {{"Python"s, 29}, {"Java"s, 24}, {"C#"s, 20}, {"Ruby"s, 25}, {"C++"s, 37}};
    // Выведите первый язык, начинающийся на J, используя алгоритм find_if
    auto result = find_if(langs.begin(), langs.end(), [](const Lang &lang) {
        return lang.name[0] == 'J';
    });
    cout << result->name << ", "s << result->age << endl;
}
```
Попробуем найти то, чего в контейнере нет. Например, поищем хоть что-нибудь, начинающееся с “K”:
```cpp
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct Lang {
    string name;
    int age;
};

int main() {
    vector<Lang> langs = {{"Python"s, 29}, {"Java"s, 24}, {"C#"s, 20}, {"Ruby"s, 25}, {"C++"s, 37}};

    auto result = find_if(langs.begin(), langs.end(), [](const Lang &lang) {
        return lang.name[0] == 'K';
    });
    cout << result->name << ", "s << result->age << endl;
} 
```
Попытайтесь запустить этот код. Скорее всего, программа просто упадёт. Но понять, получилось ли что-то найти, хочется. Это несложно. Если ничего не найдено, функция вернёт в качестве результата тот же итератор, что возвращается при использовании метода `end`. Но называть его «концом контейнера» пока не будем — сначала нужно разобраться. Говоря «конец контейнера», можем иметь в виду два места:
1. Последний элемент контейнера;
2. Место, не содержащее никакого элемента и находящееся за последним из них.

Во втором случае речь об итераторе, который возвращает метод `end`. Этот итератор указывает на некое место за пределами контейнера. Так можно понять, что элемент в контейнере не найден. 

Мы называем что-либо интервалом, если начало и конец НЕ входят в число элементов. В математике это принято обозначать так:

*(1;10)* — здесь и 1, и 10 НЕ входят в интервал. То есть входят в него целые числа 2, 3, 4, 5, 6, 7, 8 и 9.

Мы называем что-либо полуинтервалом, если что-нибудь одно (начало или конец) не включено в число элементов. В математике это выглядит так:

*[1;10)*  — здесь 1 будет элементом, а 10 уже нет. В полуинтервал входят целые числа 1, 2, 3, 4, 5, 6, 7, 8, и 9. Число 10 всё ещё никуда не входит.

Переводя идею интервалов на итераторы, получаем концепцию полуинтервалов.

#### Веди себя как итератор
Идею полуинтервалов разберём подробно. Но перед этим посмотрим, что такое итератор в принципе.

Это не тип данных и не контейнер. Итератор не содержит никаких данных, он может только указывать на них. Похож на ссылку, но его можно двигать. Ещё он умеет показывать на что-нибудь, что элементом не будет, а ссылка обязательно должна указывать на нечто содержательное.

По своей сути итератор — это объект, для которого определены некоторые действия. Например, оператор `*` позволяет получить доступ к элементу контейнера, на который итератор указывает. Так же определён оператор `++`, чтобы передвигаться от элемента к элементу. К итератору можно добавлять число и сдвигаться на некое количество позиций.

Всё это подразумевается, когда итератор передаётся в алгоритм. Если объект, полученный алгоритмом в качестве итератора, будет уметь делать то, что должен делать итератор, он будет признан итератором.

А теперь, зная, что к итератору можно прибавлять числа, посмотрим на полуинтервалы в  примере. В нашем векторе языков программирования пять элементов, а позиций, на которые может условно указывать итератор — шесть. Если `langs.begin()` указывает на нулевой элемент, то `langs.begin() + 5` указывает на `langs.end()`, и между ними ровно пять элементов. Удобно, что разность итераторов равна количеству элементов в соответствующем полуинтервале.