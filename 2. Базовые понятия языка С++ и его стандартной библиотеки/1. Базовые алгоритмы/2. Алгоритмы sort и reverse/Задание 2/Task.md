### Задание

Представьте, что вы разработали веб сервер, который обрабатывает запросы пользователей. Выполнение каждого запроса занимает определённое время, и вы хотите узнать, насколько быстро ваш сервер работает в типичном случае.

Первая идея — смотреть на среднее время ответа. Но это может приводить к неадекватным результатам. Например, если на сервере настроено ограничение времени обработки запроса в две секунды, и 10% запросов через две секунды «отваливаются» по таймауту, а 80% запросов выполняются не более 0.5 секунд. Если поднять таймаут до трёх секунд, среднее время ответа увеличится, хотя по сути ничего не изменилось.

В таком случае подойдёт медиана. Найдите медианное значение времени ответа сервера. 

Для отсортированного массива это значение среднего элемента, либо полусумма двух средних элементов, 
если число элементов чётное:
```cpp
CalcMedian({1, 2, 3, 4}) == 2.5;
CalcMedian({1, 2, 3}) == 2;
CalcMedian({1, 2, 1000}) == 2; // медиана устойчива к небольшому числу сильно отклоняющихся от нормы значений 
```
Напишите функцию `CalcMedian`, которая принимает на вход вектор времени ответа и возвращает медиану этого вектора. 

Вектор может быть неотсортированным, а также пустым. Вычисление медианы различается в зависимости от чётности количества элементов в векторе. 

Если количество элементов нечётное, например, {1, 10, 12, 50, 500}, то из них можно выделить серединное значение (в примере – 12). Оно и будет медианой.

Если количество элементов чётное, например, {1, 10, 12, 50, 500, 501}, то не ясно, какой из двух серединных элементов выбрать – 12 или 50. Поэтому используют полусумму этих чисел (в примере - (12 + 50) / 2, то есть 31).

В своём решении используйте if, чтобы разобрать случаи нечётного и чётного количества элементов. Формат входных и выходных данных 
Программе на вход подаётся целое неотрицательное число N — размер массива. 
Затем подаются N чисел с плавающей запятой, разделённых пробелом — элементы массива. 
Программа должна вывести медианное значение элементов массива, 
либо строку Empty vector, если массив пустой.

Ввод
```
4
1 2 3 4 
```
Вывод
```
2.5 
```
Ввод
```
0 
```
Вывод

```
Empty vector 
```

Исходный массив необязательно будет отсортирован.
Исходный массив может быть пустым. В этом случае верните пару значений {false, 0.0}.
Чтобы проверить число на чётность, используйте операцию остатка от деления:

```cpp
if (x % 2 == 0) {
    // чётное
} else {
    // нечётное
} 
```

#### Код к заданию
```cpp
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;

pair<bool, double> CalcMedian(vector<double> samples) {
    // верните {true, медиана}, если она существует,
    // то есть вектор непустой,
    // иначе - {false, 0}
    // обратите внимание - вектор принимаем по значению,
    // так как его придётся немного "подпортить", чтобы вернуть ответ
}

int main() {
    int size;
    cin >> size;

    vector<double> samples;
    for (int i = 0; i < size; ++i) {
        double sample;
        cin >> sample;
        samples.push_back(sample);
    }

    pair<bool, double> result = CalcMedian(samples);
    if (result.first) {
        cout << result.second << endl;
    } else {
        cout << "Empty vector"s << endl;
    }
}
```

<details><summary><strong>Решение</strong></summary>

```cpp
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;


pair<bool, double> CalcMedian(vector<double> samples) {
    
    if (samples.empty()) {
        return {false, 0.0};
    }
    
    sort(samples.begin(), samples.end());
    
    int mid_index = samples.size() / 2;
    
    if (samples.size() % 2 == 0) {
        return {true, (samples[mid_index - 1] + samples[mid_index]) / 2};
    }
    
    return {true, samples[mid_index]};
}

int main() {
    
    int size;
    cin >> size;

    vector<double> samples;
    
    for (int i = 0; i < size; ++i) {
        double sample;
        cin >> sample;
        samples.push_back(sample);
    }

    const auto [median_exists, median_value] = CalcMedian(samples);
    
    if (median_exists) {
        cout << median_value << endl;
    } else {
        cout << "Empty vector"s << endl;
    }
}
```
</details> 