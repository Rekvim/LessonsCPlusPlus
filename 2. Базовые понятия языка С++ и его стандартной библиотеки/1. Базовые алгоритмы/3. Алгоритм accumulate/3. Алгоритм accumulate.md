## Алгоритм accumulate
Стандартные функции `count`, `count_if`, `sort` и `reverse` входят в библиотеку `<algorithm>`.  Но это не единственная библиотека алгоритмов в C++. Для числовых операций используют алгоритмы из библиотеки `<numeric>`. 

Если нужно сложить все элементы вектора, используют алгоритм `accumulate`. 
Он прибавляет все элементы вектора к начальному значению, которое задаётся последним аргументом. Чтобы получить сумму элементов числового вектора, укажите в качестве начального значения ноль:
```cpp
#include <numeric>

// ...

int main() {
    vector<int> numbers = {2, 3, 5, 4};
    // Алгоритм accumulate просуммирует числа массива, прибавляя их к 
    // начальному значению, передаваемому третьим аргументом:
    cout << accumulate(numbers.begin(), numbers.end(), 100) << endl; 
    // Выведет число 100 + 2 + 3 + 5 + 4, то есть 114
} 
```
`accumulate` выполняет действия слева направо. Это важно, когда ему передаётся некоммутативная операция — та, которая зависит от порядка операндов. Например, сложение чисел коммутативно: 2 + 3 == 3 + 2. А сложение строк — некоммутативно: `"happy"s + "bee"s == "happybee"s`, `"bee"s + "happy"s == "beehappy"s`.

> **Вопрос.**  
> В алгоритм `accumulate` передаётся третий аргумент – начальное значение.  
> Почему он обязателен?

- **Вариант 1.** Без него неясно, чему должна быть равна сумма элементов пустого вектора.  
  В этом случае у `accumulate` вообще нет ни одного элемента, и без начального значения непонятно, что должен вернуть алгоритм.

- **Вариант 2.** Без него не работает сложение строк или элементов других типов.  
  Для непустых векторов можно было бы найти обычную сумму всех элементов.

Алгоритм `accumulate` складывает элементы последовательно, на каждом очередном шаге прибавляя новый элемент. Его сила — в возможности задать свою функцию для свёртки. Так называется функция, которая подсказывает `accumulate`,  как на очередном шаге алгоритма должен обновляться итоговый результат. По умолчанию она просто складывает два элемента, но вы можете задать любую другую операцию. Алгоритм вызывает функцию свёртки столько раз, сколько элементов в векторе, 
каждый раз передавая ей текущий результат и очередной элемент вектора. На первом шаге ей также передаётся начальный элемент, а на каждом последующем — результат предыдущей операции.

Вот как можно использовать accumulate, чтобы найти произведение элементов вектора вместо суммы:
```cpp
#include <numeric>

// ...

int Multiply(int a, int b) {
    return a * b;
}

int main() {
    vector<int> numbers = {2, 3, 5, 4};
    // Произведение чисел A1, A2, ..., An равно 1 * A1 * A2 * ... * An
    // Поэтому в качестве начального значения передаётся единица
    cout << accumulate(numbers.begin(), numbers.end(), 1, Multiply) << endl; 
    // Выведет число 120
} 
```
Обратите внимание, что свёрточная функция принимает ровно два параметра. Это абсолютно обязательное правило для неё. А вот типы параметров и её возвращаемого значения необязательно должны быть одинаковыми. Напишем программу, находящую суммарный путь человека, который двигался с разной скоростью на разных участках пути: 
```cpp
// Функция FoldDistance превращает данные об очередном отрезке в суммарный путь
// Первый параметр - пройденное расстояние на данный момент
// Второй параметр - время и скорость движения на отрезке
// Возвращаемое значение - обновлённое расстояние
double FoldDistance(double current_distance, pair<double, double> section) {
    // Чтобы вычислить итоговый путь, нужно к текущему пути current_distance
    // прибавить длину отрезка section
    return current_distance + section.first * section.second;
}

int main() {
    // Информация о пройденных отрезках пути.
    // Каждая пара чисел содержит время (ч) и скорость движения на отрезке (км/ч)
    vector<pair<double, double>> sections{
        {1.0, 5}, {0.5, 8}, {2, 3.5}
    };

    double total_distance = accumulate(sections.begin(), sections.end(), 0.0, FoldDistance);
    cout << "Total distance: "s << total_distance << " km"s << endl;
} 
```
Первый параметр свёрточной функции `FoldDistance` имеет тип `double` и равен текущему пройденному расстоянию. Второй параметр типа `pair<double, double>` — время и скорость движения на текущем участке. Функция `FoldDistance` возвращает расстояние с учётом длины текущего участка.

Программа выведет полный пройденный путь:

```
Total distance: 16 km 
```
Если немного изменить функцию свёртки, чтобы она накапливала не только расстояние, но и время, можно вычислить полный путь и время движения. Зная их, вы можете найти среднюю скорость на всём пути. Для этого первым параметром функции свёртки будет пара `pair<double, double>` — накопленное время и расстояние:
```cpp
// Функция принимает:
// - информация о пути (общее время и расстояние)
// - информация о текущем отрезке (время и скорость движения)
// Функция возвращает обновлённую информацию о пути (время и расстояние)
pair<double, double> FoldTimeAndDistance(pair<double, double> time_and_distance, 
                                         pair<double, double> section) {
    // Находим расстояние, пройденное на отрезке
    double section_distance = section.first * section.second;
    // Возвращаем время и расстояние
    return {time_and_distance.first + section.first, 
            time_and_distance.second + section_distance};
}

int main() {
    // Информация о пройденных отрезках пути.
    // Каждая пара чисел содержит время (ч) и скорость движения на отрезке (км/ч)
    vector<pair<double, double>> sections{
        {1.0, 5}, {0.5, 8}, {2, 3.5}
    };

    // С использованием accumulate вычисляется суммарное время и расстояние
    pair<double, double> time_and_distance = accumulate(
        sections.begin(), sections.end(), pair{0.0, 0.0}, FoldTimeAndDistance);

    cout << "Total time: "s << time_and_distance.first << " hours"s << endl;
    cout << "Total distance: "s << time_and_distance.second << " km"s << endl;
    // Зная суммарные время и расстояние, вычислим среднюю скорость
    cout << "Average speed: "s << time_and_distance.second / time_and_distance.first << " km/h"s << endl;
} 
```
Программа выведет:

```
Total time: 3.5 hours
Total distance: 16 km
Average speed: 4.57143 km/h 
```
Помимо вектора в `accumulate` можно передавать любой контейнер. Подойдёт, например, set. Если вы хотите использовать алгоритм с `map`, то учтите, что элементы `map` — пары ключ-значение, и для их правильной обработки нужно обязательно задать функцию свёртки:
```cpp
// Эта функция будет применяться для суммирования значений map. Она берёт пару из map,
// но использует из неё только второй компонент.
double SumOnlyValues(double current_sum, pair<string, double> elem) {
    return current_sum + elem.second;
}

int main() {
    set<int> unique_numbers{10, 20, 30, 10, 15};
    //Выведет 0 + 10 + 15 + 20 + 30 = 75
    cout << accumulate(unique_numbers.begin(), unique_numbers.end(), 0) << endl;

    map<string, double> accounts = {{"Ivan", 500.}, {"Boris", 100.}, {"Alexey", 1000.}};
    //Выведет 0 + 500 + 100 + 1000 = 1600
    cout << accumulate(accounts.begin(), accounts.end(), 0., SumOnlyValues) << endl;
} 
```
Потренируйтесь использовать алгоритм `accumulate` в заданиях.