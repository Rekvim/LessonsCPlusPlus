## Объявление vs определение

Рассмотрим простой код:

```cpp
#include <iostream>

using namespace std;

int main() {
    Foo();
}

void Foo() {
    cout << "Функция Foo выполняется"s << endl;
} 
```
Дело в том, что компилятор читает код строчку за строчкой. И до строчки с первым вызовом `Foo` ему всё было понятно. Когда компилятор видит вызов функции `Foo`, он ещё ничего о ней не знает: какие параметры функция принимает, что возвращает, да и вообще, существует ли она на этом свете. Поправить ситуацию просто. Перенесём функцию `Foo` над `main`, и всё заработает:

```cpp
#include <iostream>

using namespace std;

void Foo() {
    cout << "Функция Foo выполняется"s << endl;
}

int main() {
    Foo();
} 
Но бывают случаи посложнее:

#include <iostream>

using namespace std;

void Egg(int x) {
    if (1 == x) {
        cout << "Яйцо вызывает курицу"s << endl;
        Hen();
    } else {
        cout << "А вот и цыплёнок!"s << endl;
    }
}

void Hen() {
    cout << "Курица вызывает яйцо"s << endl;
    Egg(0);
}

int main() {
    Egg(1);
} 
```
Сначала `Egg` вызовет `Hen`, потом Hen вызовет `Egg`, и только после этого из `Egg` сможет вылупиться цыплёнок.

Теперь разберёмся, как сделать так, чтобы программа компилировалась, а компилятор не говорил, что “Hen identifier not found”. Почему он не нашёл функцию `Hen`, если она находится прямо под функцией `Egg`, — непонятно. Но всё просто. Компилятор проверяет код строчку за строчкой и добирается до первого упоминания функции `Hen`. Раньше компилятор её не встречал, поэтому решает, что это ошибка.

Окей, компилятор. Ты прав, курица должна быть раньше яйца. Поднимем `Hen` над `Egg`:

```cpp
#include <iostream>

using namespace std;

void Hen() {
    cout << "Курица вызывает яйцо"s << endl;
    Egg(0);
}

void Egg(int x) {
    if (1 == x) {
        cout << "Яйцо вызывает курицу"s << endl;
        Hen();
    } else {
        cout << "А вот и цыплёнок!"s << endl;
    }
}

int main() {
    Egg(1);
} 
```
Но теперь та же проблема с вызовом `Egg` из функции `Hen`. Неясно, что должно быть раньше. Чтобы решить это задачу, дадим компилятору нужную информацию, не вдаваясь в детали.

Объявление функции или класса — ответ на вопрос «Что это такое?», а определение — ответ на вопрос «Как это работает?». Компилятору нужно объявление до того, как функция или класс будут использованы. Так он разберётся в коде. Объявление функции содержит возвращаемый тип, имя функции и принимаемые параметры. В примере с одной функцией `Foo` это будет выглядеть так:
```cpp
#include <iostream>

using namespace std;

void Foo();

int main(){
    Foo();
}

void Foo() {
    cout << "Функция Foo выполняется"s << endl;
} 
```
До первого вызова `Foo` компилятор уже видел объявление этой функции, поэтому спокойно закончит процесс без ошибок.

Чтобы перейти к заданию, важно отметить ещё два момента:
1. Определение — то же, что объявление, но объявление — не то же самое, что определение. То есть функция с телом — это и объявление, и определение, но функция без тела — это только объявление, и без определения код не заработает.

2. Сказанное в уроке верно не только для функций, но и для классов. Нельзя создавать объекты, использовать методы класса и делать с ним что-либо ещё до того, как компилятор узнает о его существовании и о том, что этот класс умеет.