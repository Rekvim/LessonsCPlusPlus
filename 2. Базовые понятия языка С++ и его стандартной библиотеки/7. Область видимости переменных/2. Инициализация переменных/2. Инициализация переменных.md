## Инициализация переменных
Вы уже сталкивались с опасностью неинициализированных числовых переменных. Разберём на примере. Объявим переменную `x`, прибавим к ней восемь и выведем:
```cpp
#include <iostream>
using namespace std;
int main() {
    // другие операции
    int x;  // не задали начальное значение
    x += 8;
    cout << x << endl;
} 
```
Если это первые команды в программе, она, скорее всего, выведет `8`. Если нет, можем получить произвольное число — например `21889`. При этом компилятор видит проблему и даёт предупреждение:

```
test.cpp: In function ‘int main()’:
test.cpp:14:7: warning: ‘x’ is used uninitialized in this function [-Wuninitialized]
   14 |     x += 8;
      |     ~~^~~~ 
```
Это наглядная демонстрация одного из базовых принципов C++: не плати за то, что не используешь. Переменная не инициализирована. Автор кода написал: хочу переменную. Переменная появилась, а тратить лишнюю операцию на её зануление нет причин. В мультфильме «Вовка в Тридевятом царстве» двое из ларца получили от Вовки размытые инструкции. И сделали совсем не то, чего он ожидал. С++ тоже требует чётких инструкций: хотите нулевой `x` — так и напишите.

Инициализируйте все переменные, которые так или иначе относятся к числовым:
- целочисленные — `int`, `size_t`, `int64_t` и пр.;
- вещественные — `float`, `double` и пр.;
- `char`;
- `bool`;
- `enum`.

Создание таких локальных переменных — просто резервирование области памяти нужного размера. С точки зрения времени выполнения программы это бесплатно. С более сложными объектами — строками, векторами, словарями — дела обстоят иначе. Создавая их без дополнительной информации, вы гарантированно получите пустой объект.

Та же история с вашими собственными структурами и классами: по умолчанию их поля инициализируются подобно локальным переменным. Как правильно задавать начальные значения полей, вы узнаете в теме о конструкторах.

При этом стандартные классы заботятся о пользователе: созданная по умолчанию пара чисел `pair<int, int> x;` или вектор, длина которого равна пяти — `vector<int> v(5)`;, — будут содержать нули.

Редкий пример ситуации, когда явная инициализация переменной избыточна:

```cpp
int document_count;
cin >> document_count; 
```

Переменная заполнилась конкретным значением сразу после объявления. Но в таком случае мы не можем объявить переменную константной. Отчасти поэтому, а отчасти из-за более сложного считывания в коде поисковой системы мы инициализировали количество документов по-другому:

```cpp
const int document_count = ReadLineWithNumber(); 
```
Применим похожий приём, чтобы заполнить переменную разными значениями в зависимости от условия:

```cpp
int result_temperature;
if (mode == Mode::MIN) {
    result_temperature = min(temperature_today, temperature_yesterday);
} else {
    result_temperature = max(temperature_today, temperature_yesterday);
} 
```
Такой код опасен: если добавить команды перед if или заменить последний `else` на `else if` и добавить в `Mode` третье значение, в переменной `result_temperature` может появиться мусор. Исправить получится даже без функции. Применим так называемый тернарный оператор:

```cpp
const int result_temperature =
    mode == Mode::MIN
    ? min(temperature_today, temperature_yesterday)
    : max(temperature_today, temperature_yesterday); 
```
Выражение после символа = состоит из трёх частей:
- до `?` записано условие, как в `if`;
- между `?` и `:` записано значение, которое будет результатом выражения, если условие истинно;
- после `:` записано значение, которое будет результатом выражения, если условие ложно.

Возьмите себе за правило всегда инициализировать переменные и поля числовых типов. И не забывайте включать предупреждения компилятора.