## Целочисленные типы
Все числа, записанные в коде в виде цифр, по умолчанию имеют тип int, если они достаточно маленькие (см. таблицу ниже). Так, если написать auto x = 1, переменная x автоматически получит тип int. Но это не единственный целочисленный тип данных в С++.
Целочисленные типы содержат положительные и отрицательные целые числа без дробной части. Они отличаются размером, занимаемой памятью и диапазоном значений. Есть знаковые (signed) и беззнаковые (unsigned) целочисленные типы. Знаковые хранят положительные и отрицательные числа и ноль, а беззнаковые — только натуральные числа, включая ноль.
Целочисленные типы С++
Тип	|Количество |байтов|	Количество бит|	Диапазон значений|
|:-:|:-:|:-:|:-:|:-:|
int|	4|	32|	от -2 147 483 648 до 2 147 483 647
unsigned int|	4|	32|	от 0 до 4 294 967 295
int8_t	|1	|8	|от -128 до 127
uint8_t	|1	|8|	от 0 до 255
int16_t	|2	|16|	от -32 768 до 32 767
uint16_t|	2|	16|	от 0 до 65 535
int32_t	|4	|32|	от -2 147 483 648 до 2 147 483 647
uint32_t|	4|	32|	от 0 до 4 294 967 295
int64_t	|8	|64|	от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
uint64_t|	8|	64|	от 0 до 18 446 744 073 709 551 615

Все типы с суффиксом `_t` из таблицы доступны при подключении библиотеки cstdint. Гарантируется, что они имеют указанный размер и диапазон значений.

Тип `int` и его беззнаковый товарищ unsigned `int`, — стандартные и, как правило, занимают четыре байта. Но это может быть не так на процессорах старой или нестандартной архитектуры.

В старом коде вы можете встретить и другие типы, размер которых чётко не определён. Но для основных архитектур всё-таки можем привести сравнение:
- `char` — `int8_t` или `uint8_t`. Да-да, символ в C++ — это просто число с кодом этого символа.
- `signed char` — `int8_t`
- `unsigned char` — `uint8_t`
- `short int или short` — `int16_t`
- `unsigned short int или unsigned short` — `uint16_t`
- `long int или long` — `int32_t`
- `unsigned long int или unsigned long` — `uint32_t`
- `long long int или long long` — `int64_t`
- `unsigned long long int или unsigned long long` — `uint64_t`

В новом коде принято использовать `int` или типы с суффиксом `_t` из `cstdint`.

Разберёмся, как выбрать наиболее подходящий для решения задачи целочисленный тип данных.

- Если вам достаточно размера и диапазона значений стандартного типа `int` — используйте его.
- Если хотите хранить числа порядка триллиона, размер типа int не подойдёт — нужен `int64_t`.
- Если возникла необходимость экономить память на числах, применяйте типы меньшей размерности, такие как `int8_t`, `int16_t`.
- Если вы пишете программу, которая будет запускаться на неизвестной архитектуре, и нуждаетесь в 32-битном типе — выберите `int32_t`.

Размеры всех типов данных заучивать необязательно: в С++ есть оператор `sizeof`, который возвращает размер в байтах. Например, мы забыли размер целочисленного типа `int16_t`. Применим `sizeof`:

```cpp
cout << sizeof(int16_t) << endl; 
```

Программа напомнит, что размер `int16_t` составляет два байта.

Можно применить `sizeof` и к выражению. Так мы узнаем, что размер вектора занимает восемь байт:
```cpp
cout << sizeof(vector<string>{}.size()) << endl; 
```
Размер пустого вектора строк нулевой. Но зато каков этот ноль! Целых восемь байт.

`sizeof` удобен, когда вы уже мыслите в битах и на ходу строите логические цепочки: тип занимает восемь байт → это 64 бита → 2^64 больше 10^18 → число из 18 цифр поместится легко. Но можно и явно попросить компилятор вывести минимальное и максимальное значение любого целочисленного типа. Для этого подключим библиотеку `limits`:

```cpp
#include <iostream>
#include <limits>
using namespace std;
int main() {
    cout << "sizeof = "s << sizeof(int) << endl;
    cout << "min = "s << numeric_limits<int>::min() << endl;
    cout << "max = "s << numeric_limits<int>::max() << endl;
} 
```

Запустим код и увидим всё про тип `int` на нашем процессоре:

```cpp
sizeof = 4
min = -2147483648
max = 2147483647 
```

Вы узнали, какие целочисленные типы есть и какой объём памяти они занимают. Научились выяснять по целочисленному типу его размер, минимальное и максимальное значение. В C++ память для целочисленных типов ограничена. Далее разберёмся, что такое переполнение целочисленного типа.

Проверьте себя. Выберите наиболее подходящий и экономный тип данных для целого числа в каждой ситуации. Исходите из того, что мы живём здесь и сейчас и не планируем рост указанных величин.