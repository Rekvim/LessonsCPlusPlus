## Ограниченность памяти и переполнение

Вы уже знаете, что целочисленные типы данных отличаются диапазоном значений. Если значение переменной находится вне диапазона значений указанного типа, происходит переполнение.

Рассмотрим примеры. Возьмём максимальное значение типа `int` и прибавим к нему единицу:
```cpp
#include <iostream>
#include <limits>
using namespace std;
int main() {
    cout << numeric_limits<int>::max() + 1 << endl;
} 
```
Современные компиляторы даже выдадут предупреждение, что мы встали на скользкую дорожку:
```
warning: integer overflow in expression of type ‘int’ results in ‘-2147483648’ [-Woverflow] 
```

И действительно, при запуске вместо ожидаемого 2 147 483 648 получаем отрицательное число — минимальное значение типа `int`:

```
-2147483648
```

Это произошло, потому что значение выражения в `int` не поместилось.

Теперь возьмём значение меньше минимального:
```
cout << numeric_limits<int>::min() - 1 << endl; 
```
Снова предупреждение и снова не то, чего ожидали:
```
2147483647
```
Берём число на единицу больше, чем максимум, — получаем минимум. Берём число на единицу меньше, чем минимум, — получаем максимум. Такое в С++ переполнение.

Более практичный пример. Допустим, у нас есть два числа типа `int`: два миллиарда и один миллиард. Вычислим среднее арифметическое. Оба числа не превышают максимального значения `int`. Предполагаем, что их среднее арифметическое не превысит два миллиарда и тоже поместится в `int`. Спокойно пишем программу:

```cpp
// разряды в больших числах удобно разделять символом '
int x = 2'000'000'000;
int y = 1'000'000'000;
cout << (x + y) / 2 << endl; 
```
Вместо ожидаемых полутора миллиардов получаем:
```
-647483648 
```
С++ сначала выполнил действие в скобках: сложил `x` и `y`. Получилось три миллиарда — число, которое превышает максимальное значение типа `int`. После этого всё и пошло наперекосяк.

Выбирая тип данных, нужно продумать каждый сегмент программы. Если промежуточные вычисления не поместятся в ваш тип, рискуете получить большое отрицательное число — верный признак переполнения. А когда выполняете серию арифметических операций, переполнение можете и вовсе не заметить.

Посмотрим, как это работает с беззнаковыми типами. Сохраним переменную `x` со значением два миллиарда в беззнаковую переменную `y` и выведем обе:

```cpp
int x = 2'000'000'000;
unsigned int y = x;
cout << x << " "s << y << endl; 
```

Запустим код и увидим, что всё в порядке, ведь это значение помещается и в int, и в unsigned int:

```cpp
2000000000 2000000000 
```

Теперь сохраним в переменную `x` отрицательное значение:
```cpp
int x = -2'000'000'000;
unsigned int y = x;
cout << x << " "s << y << endl; 
```
Запустим код. В беззнаковый тип наше значение не поместилось:
```cpp
-2000000000 2294967296 
```
Так происходит переполнение беззнакового целочисленного типа.

С одним беззнаковым типом мы уже сталкивались — это тип `size_t`. Во-первых, именно его возвращает метод `size` контейнеров. Во-вторых, результат вызова оператора `sizeof` тоже имеет тип `size_t`. Это вполне логично: размер чего-либо не может быть отрицательным.

Размер самого типа `size_t` зависит от разрядности вашей операционной системы. Если система 32-битная — размер `size_t` составит 32 бита (четыре байта), если 64-битная — 64 бита (восемь байт).

Вернёмся к задаче о среднем рейтинге. Имея рейтинги −5, 1 и −2, найдём их среднее арифметическое:
```cpp
#include <iostream>
#include <vector>

using namespace std;

int ComputeAverageRating(const vector<int>& ratings) {
    if (ratings.empty()) {
        return 0;
    }
    int rating_sum = 0;
    for (const int rating : ratings) {
        rating_sum += rating;
    }
    return rating_sum / ratings.size();
}

int main() {
    cout << ComputeAverageRating({-5, 1, -2}) << endl;
}
```

Средний рейтинг должен составить (−5 + 1 − 2) / 3 = −2. Но результат намекает на переполнение:

```cpp
1431655763 
```

Дело в финальном выражении функции: `rating_sum / ratings.size()`. Чтобы разделить `int` на `size_t`, компилятор привёл оба операнда к беззнаковому типу. В нём −2 не сохранить.

Поэтому и помогало предварительно привести размер вектора к знаковому типу `int`:
```cpp
return rating_sum / static_cast<int>(ratings.size()); 
```

Избегайте переполнения типов: даже если код работает при ваших текущих настройках, он может дать сбой на другом компиляторе или ОС. Ситуаций, когда переполнение приносит пользу, — мало. Едва ли вы с ними столкнётесь.

Выбирайте подходящие типы и преобразовывайте их оператором `static_cast`. В следующем уроке вы научитесь этому на конкретных примерах и узнаете о нюансах приведения операндов к общему типу.