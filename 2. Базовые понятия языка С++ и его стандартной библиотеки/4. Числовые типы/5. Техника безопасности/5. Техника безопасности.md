## Техника безопасности
Логические и арифметические операции с целочисленными типами могут вызвать внезапное переполнение. Та же проблема подстерегает при итерации по вектору циклом `for`.

Проитерируемся по вектору циклом `for` с индексом `i`. Выведем сам индекс и содержимое по этому индексу:
```cpp
#include <iostream>
#include <vector>
using namespace std;
int main() {
    vector<int> v = {4, 5};
    for (int i = 0; i < v.size(); ++i) {
        cout << i << " "s << v[i] << endl;
    }
} 
```

Убедимся, что компилятор считает предупреждения ошибками. Скомпилируем код в этом придирчивом режиме и увидим:
```
comparison of integer expressions of different signedness: ‘int’ and ‘std::vector<int>::size_type’ {aka ‘long unsigned int’} 
```
Действительно, тип переменной `i` знаковый, а тип выражения `v.size()` — беззнаковый. Сравнивать их опасно, потому что переменная `i` может быть отрицательной.

Есть два способа решить проблему:
- объявить переменную `i` с типом `size_t` — тогда предупреждений от компилятора не будет;
- перед сравнением привести `v.size()` к знаковому типу.

Выбор из этих двух вариантов — дело вкуса. Часто команды разработчиков договариваются не только о том, как называть функции и расставлять пробелы, но и о подходе к использованию беззнаковых типов.

Мы остановимся на втором способе. Применим оператор `static_cast`, чтобы привести `v.size()` к `int`:

```cpp
vector<int> v = {4, 5};
for (int i = 0; i < static_cast<int>(v.size()); ++i) {
    cout << i << " "s << v[i] << endl;
} 
```

Когда явно приводим `v.size()` к типу `int`, нужно быть уверенными, что размер вектора не превысит 2^31 − 1. Иначе случится переполнение. Правда, векторы такого размера встречаются довольно редко: несколько гигабайт оперативной памяти под одну переменную — это не шутки.

В нашем случае переполнения нет. Код компилируется и запускается:
```
0 4
1 5 
```
Рассмотрим другой пример. У нас есть вектор целых чисел. Мы хотим перебрать в нём все элементы, кроме последнего. Напишем цикл по индексам от 0 до `v.size() − 1` и выведем все такие элементы:
```cpp
vector<int> v = {1, 4, 6};
for (size_t i = 0; i < v.size() - 1; ++i) {
    cout << v[i] << endl;
} 
```
Здесь мы решились объявить индекс беззнаковым, ведь он не бывает отрицательным. При запуске видим все элементы, кроме последнего:
```
1
4 
```
При написании кода важно проверять, что он будет работать в крайних случаях. Например, если вектор пустой и в нём нет последнего элемента. Проверим:
```cpp
vector<int> v;
for (size_t i = 0; i < v.size() - 1; ++i) {
    cout << v[i] << endl;
} 
```
Запустим код и увидим, что он упал. Дело в том, что `v.size()` — это ноль беззнакового типа `size_t`. Мы вычли единицу и получили максимальное значение типа `size_t`. Итерируясь от нуля до максимума, попали в чужую память. Программа сломалась.
Чтобы избежать таких сюрпризов, не вычитайте из беззнаковых типов или будьте внимательны при вычитании. Заменим вычитание сложением:
```cpp
for (size_t i = 0; i + 1 < v.size(); ++i) {
    cout << v[i] << endl;
}
```
Такой цикл будет работать корректно и для пустого, и для непустого вектора.

Теперь проитерируемся по вектору в обратную сторону. Что может пойти не так?
```
vector<int> v = {1, 4, 5}; 
for (size_t i = v.size() - 1; i >= 0; --i) {
    cout << v[i] << endl;
} 
```
При запуске код выведет много интересного, а потом упадёт. Проблема снова в переполнении: после итерации с нулевым `i` индекс уменьшится на единицу, переполнится — и станет максимальным значением типа `size_t`. Наивно было писать в цикле условие `i >= 0`: для беззнакового `i` оно верно всегда. А для пустого вектора вдобавок произойдёт переполнение в выражении `v.size() − 1`. Чтобы решить проблему, перепишем заголовок цикла `for`. Сделаем замену переменной (привет матанализу), оставив прежний смысл `i`. Проитерируемся не `i`, а индексом, который на единицу больше:

```cpp
vector<int> v = {1, 4, 5};
for (size_t k = v.size(); k > 0; --k) {
    const size_t i = k - 1;
    cout << v[i] << endl;
} 
```

Успех!

```
5
4
1 
```

Встаёт вопрос, какие типы использовать — знаковые или беззнаковые. Это каждый разработчик на С++ решает самостоятельно. У вас два пути:
1. Следовать семантике значений. Если у переменной по смыслу не бывает отрицательных значений — объявлять её беззнаковой. Минус: придётся помнить все опасности преобразования знаковых и беззнаковых типов.
2. Избегать беззнаковых типов. То есть использовать `static_cast` и приводить все беззнаковые типы к знаковым. Минус: `static_cast` будет встречаться в вашем коде довольно часто.

Вы узнали, чем опасны операции с беззнаковыми типами, и увидели, как предотвратить проблемы. Далее разберём перечисления.