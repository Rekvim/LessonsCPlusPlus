## Создаём класс поисковой системы. Часть 2
Вы только что создали основу `SearchServer`. У вас получилось что-то вроде этого:
```cpp
vector<string> SplitIntoWordsNoStop(const string& text, const set<string>& stop_words) {
    ...
}

class SearchServer {
public:
    void AddDocument(int document_id, const string& document) {
        const vector<string> words = SplitIntoWordsNoStop(document, stop_words_);
        documents_.push_back({document_id, words});
    }
private:
    struct DocumentContent {
        int id = 0;
        vector<string> words;
    };

    vector<DocumentContent> documents_;
    set<string> stop_words_;
}; 
```
`SearchServer` содержит вектор документов и множество стоп-слов. Метод `AddDocument` передаёт текст документа в функцию `SplitIntoWordsNoStop`. Она разбивает текст на слова, исключая из них слова из стоп-списка, и возвращает то, что осталось. Разобранный на слова документ добавляется в вектор `documents_`.

Проанализируем это решение. Метод `AddDocument` вызывает внешнюю (или, как ещё говорят, «свободную») функцию `SplitIntoWordsNoStop`, чтобы обработать текст документа. Методы, как и свободные функции, могут вызывать другие функции.

В этом примере метод `GetLength` структуры `LineSegment` вызывает функцию `hypot`, чтобы вычислить длину гипотенузы по двум катетам:
```cpp
#include <cmath> // содержит функцию hypot

using namespace std;

// Точка
struct Point {
    double x = 0.0, y = 0.0;
};

// Отрезок прямой
struct LineSegment {
    Point start, end;

    // Возвращает длину отрезка
    double GetLength() {
        return hypot(end.x - start.x, end.y - start.y);
    }
}; 
```
Взглянем ещё раз на код поисковой системы:
```cpp
vector<string> SplitIntoWordsNoStop(const string& text, const set<string>& stop_words) {
    ...
}

class SearchServer {
public:
    void AddDocument(int document_id, const string& document) {
        const vector<string> words = SplitIntoWordsNoStop(document, stop_words_);
        documents_.push_back({document_id, words});
    }
    ...
}; 
```
И метод `AddDocument`, и вызываемая из него функция `SplitIntoWordsNoStop` работают с данными поисковой системы: документами и стоп-словами. Внутри методов классов и структур к полям можно обращаться по их имени. А вот функции так не могут, поэтому множество стоп-слов приходится передавать в функцию `SplitIntoWordsNoStop` явно.

В отличие от стандартной функции `hypot`, которая предназначена для использования во многих программах, функция `SplitIntoWordsNoStop` за пределами класса `SearchServer` не используется. В этом случае имеет смысл сделать её методом класса `SearchServer`. Тогда `SplitIntoWordsNoStop` сможет обращаться к полю `stop_words_` напрямую, и будет иметь меньше параметров.



Заглянем внутрь функции `SplitIntoWordsNoStop` и увидим, что она вызывает функцию `SplitIntoWords`:
```cpp
vector<string> SplitIntoWords(const string& text) {
    ...
}

vector<string> SplitIntoWordsNoStop(const string& text, const set<string>& stop_words) {
    vector<string> words;
    for (const string& word : SplitIntoWords(text)) {
        if (stop_words.count(word) == 0) {
            words.push_back(word);
        }
    }
    return words;
} 
```