## Поиск в отсортированном векторе, словаре и множестве
В этом уроке заполним таблицу полностью: разберём остальные методы поиска в отсортированном векторе, в словаре и множестве. 
#### Отсортированный вектор
Помимо функции `binary_search`, для поиска элементов в отсортированном векторе применяют функции `lower_bound`, `upper_bound` и `equal_range`.
- `upper_bound`
  
Эта функция вернёт итератор на элемент, больший искомого. Допустим, у нас есть отсортированный вектор:
```cpp
vector<int> v = {1, 1, 2, 3, 4, 4, 4, 5, 6};
auto it = upper_bound(v.begin(), v.end(), 4);
cout << "Номер позиции в векторе "s << distance(v.begin(), it) << endl;
cout << "Значение элемента "s << *it << endl; 
```
Будем искать первый элемент больше четвёрки. Здесь это пятёрка. Именно на позицию пятёрки будет указывать итератор, возвращённый функцией upper_bound:

1 1 2 3 4 4 4 5 6

Программа выведет:
```
Номер позиции в векторе 7
Значение элемента 5 
```
- `lower_bound`

Эта функция вернёт итератор на элемент, больший или равный искомому. Возьмём тот же пример и будем искать первый элемент, больший или равный четвёрке:
```cpp
vector<int> v = {1, 1, 2, 3, 4, 4, 4, 5, 6};
auto it = lower_bound(v.begin(), v.end(), 4);
cout << "Номер позиции в векторе "s << distance(v.begin(), it) << endl;
cout << "Значение элемента "s << *it << endl; 
```
Получим итератор на позицию первой четвёрки в данном векторе:

1 1 2 3 4 4 4 5 6
Программа выведет:

```
Номер позиции в векторе 4
Значение элемента 4 
```
- `equal_range`
  
Эта функция вернёт пару итераторов. Первый из них — результат `lower_bound`, а второй — результат `upper_bound`. Казалось бы, зачем нам функция, которая дублирует работу двух других. На самом деле поиск двух результатов так реализуется эффективнее, чем если бы сначала была вызвана функция `lower_bound`, а потом `upper_bound`. Искать пару сразу проще, чем каждый элемент по отдельности. Такой приём вы уже видели на примере minmax_element.
```cpp
vector<int> v = {1, 1, 2, 3, 4, 4, 4, 5, 6};
auto [lower, upper] = equal_range(v.begin(), v.end(), 4);
cout << "Номер начальной позиции в векторе "s << distance(v.begin(), lower) << endl;
cout << "Номер конечной позиции в векторе "s << distance(v.begin(), upper) << endl; 
```
Пара итераторов в примере будет указывать на диапазон:

1 1 2 3 4 4 4 5 6

Концепция полуинтервала продолжает работать и здесь, поэтому внимательно посмотрим на пятёрку. Мы получили полуинтервал, в рамках которого все элементы равны данному. Результат `upper_bound` играет роль конца диапазона. То есть пятёрка в диапазон не входит, но станет его окончанием. Программа выведет:
```
Номер начальной позиции в векторе 4
Номер конечной позиции в векторе 7 
```
Если бы в векторе не оказалось четвёрок, `lower_bound` и `upper_bound` вместе указывали бы на пятёрку. Это было бы то самое место, куда четвёрку можно вставить без нарушения сортировки.

Чтобы определить количество элементов, равных данному, достаточно расстояния между итераторами, которые вернула `equal_range`. А чтобы перебрать все нужные элементы, используют цикл от левой до правой границы найденного диапазона. 

#### Множества и словари
У множеств и словарей есть свои методы, одноимённые с функциями, которые мы уже разобрали. Эти методы работают эффективнее, чем функции, так как изначально знают, с каким контейнером имеют дело. Поиск организуется в соответствии с устройством конкретного контейнера. Но есть специфические моменты:
- проверить существование элемента во множестве или словаре можно, применив специальный метод contains. Правда, он появится только в следующем стандарте языка — в С++20. Поэтому в нынешнем стандарте используют метод count. Если элемент в контейнере есть, метод count вернёт 1, а если нет — 0;
- перебор всех подходящих элементов для множества и словаря не имеет значения, так как если элемент существует, он один — перебирать просто нечего;
- то же можно сказать о подсчёте количества: результат всегда будет или 0, или 1.

Что и как хотим найти? / Где ищем?|Неотсортированный вектор|Отсортированный вектор|Множество или словарь|
|:-:|:-:|:-:|:-:|
Проверка существования|Функция `find`|Функция `binary_search`|Метод `contains`, метод `count`|
Проверка существования и поиск первого подходящего элемента|Функция `find`|Функция `lower_bound` и проверка найденного элемента на равенство искомому|Метод `find`|
Поиск первого элемента, большего или равного данному|Функция `find_if`|Функция `lower_bound`|Метод  `lower_bound`|
Поиск первого элемента, большего данного|Функция `find_if`|Функция  `upper_bound`|Метод `upper_bound`|
Подсчёт количества|Функция `count`|Функция `equal_range` и расстояние между итераторами|Метод `count`|
Перебор по всем подходящим элементам|Функция `find` в цикле|Функция `equal_range` и цикл от левой до правой границы|Метод `find`|