## Функциональные объекты
Вы уже сталкивались с функциями, в которые можно передавать другие функции. Так, в функцию `sort` передаётся компаратор: либо в виде названия функции, либо в виде лямбда-функции, написанной при вызове сортировки. А функции `count_if` и `all_of` принимают проверяющую функцию.

В этом уроке вы научитесь писать такие функции. И вам снова будут полезны шаблоны.

Зададимся целью написать удобную обёртку для функции `sort`. Пусть она принимает контейнер и указание, по какой характеристике сортировать объекты. Указание должно быть в виде функции:

```cpp
#include <iostream>
#include <vector>
using namespace std;
struct Animal {
    string name;
    int age;
    double weight;
};
void PrintNames(const vector<Animal>& animals) {
    for (const Animal& animal : animals) {
        cout << animal.name << ' ';
    }
    cout << endl;
}
// как написать SortBy?
int main() {
    vector<Animal> animals = {
        {"Мурка"s,   10, 5},
        {"Белка"s,   5,  1.5},
        {"Георгий"s, 2,  4.5},
        {"Рюрик"s,   12, 3.1},
    };
    PrintNames(animals);
    // без сортировки: Мурка Белка Георгий Рюрик
    SortBy(animals, [](const Animal& animal) { return animal.name; });
    PrintNames(animals);
    // сортировка по имени: Белка Георгий Мурка Рюрик
    SortBy(animals, [](const Animal& animal) { return -animal.weight; });
    PrintNames(animals);
    // сортировка по убыванию веса: Мурка Георгий Рюрик Белка
} 
```
Написать функцию `SortBy`, принимающую только контейнер, проще простого:
```cpp
template <typename Container> 
void SortBy(Container& container) {
    sort(container.begin(), container.end());
} 
```
Здесь контейнером может быть как вектор с любыми элементами, так и строка.

Чтобы понять, как принять функцию вторым параметром, разберёмся, чего мы от функции ожидаем и какими они бывают.

Допустим, `key_mapper` — функция, которая по объекту возвращает ключ для сравнения объекта с соседями, а `x` — такой объект. Тогда естественно ожидать, что `key_mapper(x)` и есть ключ для данного объекта.

Ожидания оправдываются, когда `key_mapper` — обычная функция:

```cpp
#include <iostream>
#include <vector>
using namespace std;
struct Animal {
    string name;
    int age;
    double weight;
};
const string& GetName(const Animal& animal) {
    return animal.name;
}
   
int main() {
    vector<Animal> animals = {
        {"Мурка"s,   10, 5},
        {"Белка"s,   5,  1.5},
        {"Георгий"s, 2,  4.5},
        {"Рюрик"s,   12, 3.1},
    };
    auto key_mapper = GetName;
    cout << key_mapper(animals.front()) << endl;
    // выведет имя первого животного: Мурка
} 
```
Но можно положить в `key_mapper` лямбда-функцию. И всё тоже сработает ожидаемо:
```cpp
auto key_mapper = [](const Animal& animal) { return animal.name; };
cout << key_mapper(animals.front()) << endl;
// и снова имя первого животного: Мурка 
```
В обоих примерах мы написали `auto`. В случае, когда `key_mapper` — обычная функция, мы не указали тип функции явно, потому что он слишком длинный. В случае лямбды у нас уникальный тип без имени, поэтому без `auto` не обойтись.

Итак, чтобы принять в `SortBy` функцию, достаточно указать, что вторым параметром `SortBy` должен быть объект `key_mapper` произвольного, то есть шаблонного типа. Такой объект, что выражение `key_mapper(x)` для элемента x возвращает ключ для сортировки.

Сделаем же тип параметра `key_mapper` вторым шаблонным параметром функции!
```cpp
template <typename Container, typename KeyMapper>
void SortBy(Container& container, KeyMapper key_mapper) {
    // теперь можно сортировать контейнер
    // с компаратором key_mapper(lhs) < key_mapper(rhs)
} 
```
`key_mapper` принимается в функции по значению. Так принято, потому что функции, как правило, — лёгкие объекты.

Любой объект, который можно использовать как функцию, называется функциональным объектом. Позже вы научитесь создавать такие объекты самостоятельно.