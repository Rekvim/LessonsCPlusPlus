## Специализация шаблонов
Любой объект, который мы передадим вторым аргументом в `SortBy`, компилятор попытается использовать как функцию. И выдаст ошибку, если не сможет. Рассмотрим, как упростить вызов функции `SortBy` для частных случаев и не писать громоздкие лямбды.

В качестве примера объявим enum `class AnimalSortKey` с типами ключа для сортировки животных:
```cpp
enum class AnimalSortKey {
    AGE,     // по полю age
    WEIGHT,  // по полю weight
    RELATIVE_WEIGHT  // по weight / age
}; 
```
И попробуем вызвать функцию `SortBy` с элементом этого перечисления в качестве ключа:
```cpp
int main() {
    vector<Animal> animals = {
        {"Мурка"s,   10, 5},
        {"Белка"s,   5,  1.5},
        {"Георгий"s, 2,  4.5},
        {"Рюрик"s,   12, 3.1},
    };
        PrintNames(animals);
        // Мурка Белка Георгий Рюрик
    SortBy(animals, [](const Animal& animal) { return animal.name; }, true);
    PrintNames(animals);
        // Рюрик Мурка Георгий Белка
    SortBy(animals, AnimalSortKey::RELATIVE_WEIGHT);
    PrintNames(animals);
        // ожидаем вывод: Рюрик Белка Мурка Георгий
} 
```
Если ничего не менять, увидим большую ошибку компиляции. Вот пара фрагментов:
```
test.cpp: In instantiation of ‘SortBy(Container&, KeyMapper, bool) [with Container = std::vector<Animal>; KeyMapper = AnimalSortKey]::<lambda(const auto:1&, const auto:2&)> [with auto:1 = Animal; auto:2 = Animal]’:
...
test.cpp:18:34: error: ‘key_mapper’ cannot be used as a function
   18 |                 return key_mapper(lhs) > key_mapper(rhs); 
```
Компилятор не смог использовать `key_mapper` как функцию. Неудивительно, это же `enum`. В первой строке уточняется, где произошла неудача: в шаблонной лямбда-функции, где оба `auto` — это `Animal`. То есть `<lambda(const auto:1&, const auto:2&)> [with auto:1 = Animal; auto:2 = Animal]`. 

При этом лямбда создана в `SortBy(Container&, KeyMapper, bool)` с `Container = std::vector<Animal>` и `KeyMapper = AnimalSortKey`.

Итак, мы хотим написать конкретную версию функции `SortBy` с аргументами `vector<Animal>& animals, AnimalSortKey sort_key, bool reverse = false`. Так и сделаем:
```cpp
void SortBy(vector<Animal>& animals, AnimalSortKey sort_key, bool reverse = false) {
    switch (sort_key) {
        case AnimalSortKey::AGE:
                        // возвращается void, но return помогает сразу выйти из функции
            return SortBy(animals, [](const auto& x) { return x.age; }, reverse);
        case AnimalSortKey::WEIGHT:
            return SortBy(animals, [](const auto& x) { return x.weight; }, reverse);
        case AnimalSortKey::RELATIVE_WEIGHT:
            return SortBy(animals, [](const auto& x) { return x.weight / x.age; }, reverse);
    }
} 
```

Всё работает ожидаемо: мы применили механизм перегрузки функций. Особенность этого примера в том, что функция с конкретными типами аргументов конкурирует с шаблонной и побеждает именно благодаря своей конкретности.

Но ведь вес и возраст есть не только у животных. Можно сделать функцию шаблонной по типу контейнера и получить специализацию шаблона. То есть уточнённую версию изначальной функции с типом `AnimalSortKey` в качестве `KeyMapper`:

```cpp
template <typename Container>
void SortBy(Container& animals, AnimalSortKey sort_key, bool reverse = false) {
    switch (sort_key) {
        case AnimalSortKey::AGE:
            return SortBy(animals, [](const auto& x) { return x.age; }, reverse);
        case AnimalSortKey::WEIGHT:
            return SortBy(animals, [](const auto& x) { return x.weight; }, reverse);
        case AnimalSortKey::RELATIVE_WEIGHT:
            return SortBy(animals, [](const auto& x) { return x.weight / x.age; }, reverse);
    }
} 
```

Хороший разработчик теперь уберёт из функции упоминание животных, чтобы подчеркнуть её гибкость. 

Любители интерпретируемых языков подумают о следующем алгоритме:
1. оставить одну функцию,
2. в начале у функции проверить тип `KeyMapper`,
3. пойти по нужной ветке: либо общей, либо конкретной.

Применим шаблон `is_same_v` и напишем такой код:
```cpp
template <typename Container, typename KeyMapper>
void SortBy(Container& container, KeyMapper key_mapper, bool reverse = false) {
        // если KeyMapper — это AnimalSortKey...
    if (is_same_v<KeyMapper, AnimalSortKey>) {
        switch (key_mapper) {
            case AnimalSortKey::AGE:
                return SortBy(container, [](const auto& x) { return x.age; }, reverse);
            case AnimalSortKey::WEIGHT:
                return SortBy(container, [](const auto& x) { return x.weight; }, reverse);
            case AnimalSortKey::RELATIVE_WEIGHT:
                return SortBy(container, [](const auto& x) { return x.weight / x.age; }, reverse);
        }
                // вышли из функции, остальное снаружи if
    }
    if (reverse) {
        sort(container.begin(), container.end(),
             [key_mapper](const auto& lhs, const auto& rhs) {
                return key_mapper(lhs) > key_mapper(rhs);
             });
    } else {
        sort(container.begin(), container.end(),
             [key_mapper](const auto& lhs, const auto& rhs) {
                return key_mapper(lhs) < key_mapper(rhs);
             });
    }
} 
```
Не компилируется. Сообщение об ошибке извещает: `In instantiation of ‘void SortBy(Container&, KeyMapper, bool) [with Container = std::vector<Animal>; KeyMapper = main()::<lambda(const Animal&)>]’: ... error: switch quantity not an integer`. При вызове `SortBy` с лямбдой из `main` в качестве `KeyMapper` компилятор споткнулся о `switch`. Дело в том, что оператор `if` работает уже при запуске программы. Поэтому компилируется вся функция целиком, а не конкретная её часть.

Подскажем, что выражение `is_same_v<KeyMapper, AnimalSortKey>` можно вычислить ещё до запуска программы, и применим `if constexpr`:

```cpp
template <typename Container, typename KeyMapper>
void SortBy(Container& container, KeyMapper key_mapper, bool reverse = false) {
    if constexpr (is_same_v<KeyMapper, AnimalSortKey>) {
                // ... 
```
Получим другую ошибку компиляции: `‘key_mapper’ cannot be used as a function` с `KeyMapper = AnimalSortKey`. Снова компилируется лишняя часть функции, даже после гарантированного `return`. Исправим веткой `else`:
```cpp
template <typename Container, typename KeyMapper>
void SortBy(Container& container, KeyMapper key_mapper, bool reverse = false) {
    if constexpr (is_same_v<KeyMapper, AnimalSortKey>) {
        switch (key_mapper) {
            case AnimalSortKey::AGE:
                return SortBy(container, [](const auto& x) { return x.age; }, reverse);
            case AnimalSortKey::WEIGHT:
                return SortBy(container, [](const auto& x) { return x.weight; }, reverse);
            case AnimalSortKey::RELATIVE_WEIGHT:
                return SortBy(container, [](const auto& x) { return x.weight / x.age; }, reverse);
        }
    } else {
        if (reverse) {
            sort(container.begin(), container.end(),
                 [key_mapper](const auto& lhs, const auto& rhs) {
                    return key_mapper(lhs) > key_mapper(rhs);
                 });
        } else {
            sort(container.begin(), container.end(),
                 [key_mapper](const auto& lhs, const auto& rhs) {
                    return key_mapper(lhs) < key_mapper(rhs);
                 });
        }
    }
} 
```
Мы проделали интересное упражнение, но на практике предпочтительнее первый подход: написать отдельную функцию для конкретных типов параметров.