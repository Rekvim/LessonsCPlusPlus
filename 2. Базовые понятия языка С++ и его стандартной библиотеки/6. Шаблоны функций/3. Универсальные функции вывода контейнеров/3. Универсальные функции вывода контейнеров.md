## Универсальные функции вывода контейнеров
Возможно, вы успели огорчиться, что в C++ нельзя простым движением и оператором `<<` вывести содержимое контейнера:
```cpp
const vector<string> cats = {"Мурка"s, "Белка"s, "Георгий"s, "Рюрик"s};
cout << cats << endl; 
```
Не беда. C++ легко обучить. Чтобы шалость удалась, переопределим оператор вывода в поток для вектора:
```cpp
#include <iostream>
#include <vector>
using namespace std;
ostream& operator<<(ostream& out, const vector<string>& container) {
    for (const string& element : container) {
        out << element << " "s;
    }
    return out;
}  
   
int main() {
    const vector<string> cats = {"Мурка"s, "Белка"s, "Георгий"s, "Рюрик"s};
    cout << cats << endl;
} 
```
Этот код ожидаемо выводит `Мурка Белка Георгий Рюрик`. Разберёмся, как мы этого добились.

Мы написали функцию со специальным названием `operator<<`. У неё два аргумента: ссылка на выходной поток `out` (означает `output`) и константная ссылка на вектор. Своим существованием она говорит компилятору: «Если кто-то напишет `out << container`, вызови меня: `operator<<(out, container)`». Вернуть ссылку на поток нужно, чтобы объединять вывод в цепочку, как в выражении `cout << cats << endl`. Заметьте, что в операторе вывода мы не использовали `endl`: так принято делать для вывода однострочных объектов. За вывод `endl` отвечает код, использующий оператор: `cout << "[" << cats << "]" << endl;`.

Позже вы изучите переопределение и для других операторов, с другими целями. А пока начнём постепенно улучшать этот код.