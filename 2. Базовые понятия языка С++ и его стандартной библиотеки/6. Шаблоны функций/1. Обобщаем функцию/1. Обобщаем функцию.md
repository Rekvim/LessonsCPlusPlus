## Обобщаем функцию
Итак, функция `ComputeTermFreqs` умеет считать частоту строк по данному вектору. Функция короткая, но достойна существовать самостоятельно.

Вычислить частоту можно и для числовых данных. Подсчитаем количество двуногих и четвероногих обитателей квартиры:
```cpp
int main() {
    const vector<int> leg_counts = {4, 2, 4, 4};
    const auto legs_stat = ComputeTermFreqs(leg_counts);
    cout << "Двуногих "s << legs_stat.at(2) << ", "s
         << "четвероногих "s << legs_stat.at(4) << endl;
}  
```
И потерпим неудачу: наша функция умеет принимать только вектор строк:
```
error: invalid initialization of reference of type ‘const std::vector<std::__cxx11::basic_string<char> >&’ from expression of type ‘const std::vector<int>’
```
Но мы можем написать ещё одну функцию для типа `int`. И даже дать ей такое же название: компилятор сам поймёт по типам аргументов, какую функцию вызвать:
```cpp
map<string, int> ComputeTermFreqs(const vector<string>& terms) {
    map<string, int> term_freqs;
    for (const string& term : terms) {
        ++term_freqs[term];
    }
    return term_freqs;
}
map<int, int> ComputeTermFreqs(const vector<int>& terms) {
    map<int, int> term_freqs;
    for (int term : terms) {
        ++term_freqs[term];
    }
    return term_freqs;
}
int main() {
    const vector<int> leg_counts = {4, 2, 4, 4};
    const auto legs_stat = ComputeTermFreqs(leg_counts);
    cout << "Двуногих "s << legs_stat.at(2) << ", "s
         << "четвероногих "s << legs_stat.at(4) << endl;
        // Двуногих 1, четвероногих 3
} 
```
Это называется перегрузка функций. А ещё ужасный копипаст. Так делать не стоит.

Посмотрим, как надо. Версии функции `ComputeTermFreqs` отличаются в двух аспектах:
1. Вместо `string` использован `int`.
2. Цикл `for` перебирает элементы по значению, а не по ссылке.
   
От перебора по значению можно отказаться — функцию это серьёзно не замедлит. Отличие останется только в типе. Мы пока не знаем, с каким типом для слов функция будет работать, но уже можем её написать. Назовём тип `Term`:

```cpp
// нам интересны Term = string и Term = int, пытаемся обобщить
map<Term, int> ComputeTermFreqs(const vector<Term>& terms) {
    map<Term, int> term_freqs;
    for (const Term& term : terms) {
        ++term_freqs[term];
    }
    return term_freqs;
} 
```

Функция зависит не только от конкретного вектора `terms`, но и от типа его элементов. Такая функция называется шаблонной и оформляется следующим образом:

```cpp
template <typename Term>  // шаблонный параметр-тип с названием Term
map<Term, int> ComputeTermFreqs(const vector<Term>& terms) {
    map<Term, int> term_freqs;
    for (const Term& term : terms) {
        ++term_freqs[term];
    }
    return term_freqs;
} 
```
Вы увидели, как вызвать `ComputeTermFreqs` от вектора строк или вектора чисел и получить статистику частоты элементов. Без всякого копипаста.