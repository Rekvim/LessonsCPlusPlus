## GDB
Компилятор — не единственный инструмент поиска ошибок в коде. Для максимального эффекта используйте и встроенный отладчик своей IDE. Как правило, такие отладчики основаны на консольном отладчике GDB. Научимся работать с ним на примере задачи разделения на слова:
```cpp
#include <iostream>
#include <string>
#include <vector>
    
using namespace std;

vector<string> SplitIntoWords(const string& text) {
    vector<string> words;
    for (size_t i = 0; i < text.size(); ++i) {
        if (text[i] == ' ') {
            continue;
        }
        const size_t space_pos = text.find(' ', i);
        if (space_pos == text.npos) {
            words.push_back(text.substr(i));
            break;
        } else {
            words.push_back(text.substr(i, space_pos - i));
            i = space_pos;
        }
    }
    return words;
}

int main() {
    const string query = "hello kitty"s;
    for (const auto& word : SplitIntoWords(query)) {
        cout << '[' << word << ']' << endl;
    }
} 
```
Скомпилируем программу с флагом `-g` и запустим GDB для полученного исполняемого файла:
```
$ g++ gdb_example.cpp -std=c++17 -Wall -Werror -g -o gdb_example
$ gdb gdb_example 
# приветствие отладчика
(gdb) 
Теперь можно вводить команды. Запустим программу: она выведет слова и завершит работу. Мы ничего не отладили.

(gdb) run
Starting program: /path/to/project/gdb_example 
[hello]
[kitty]
[Inferior 1 (process 18489) exited normally]
```
Чтобы пройти программу пошагово, поставим *брейкпойнт* на функцию main и снова запустим программу:

```
(gdb) break main
Breakpoint 1 at 0x55555555553a: file gdb_example.cpp, line 25.
(gdb) run
Starting program: /path/to/project/gdb_example 

Breakpoint 1, main () at gdb_example.cpp:25
25    int main() { 

```
Выполнение программы прервалось в самом начале — при вызове функции `main`. Отладчик вывел строку, на которой это произошло. Чтобы понять, в каком месте кода мы находимся, выведем соседние строки:
```
(gdb) list
20            }
21        }
22        return words;
23    }
24    
25    int main() {
26        const string query = "hello kitty"s;
27        for (const auto& word : SplitIntoWords(query)) {
28            cout << '[' << word << ']' << endl;
29        } 
```
Напишем команду next в консоли и перейдём к следующей строке:
```
(gdb) next
26        const string query = "hello kitty"s; 
```
Чтобы не вводить `next` каждый раз, сокращайте команды до первой буквы (`next` → `n`, `list` → `l`) или просто нажимайте Enter — тогда будет повторяться предыдущая команда. Так можно довольно быстро дойти до конца программы:
```
(gdb) 
27        for (const auto& word : SplitIntoWords(query)) {
(gdb) 
28            cout << '[' << word << ']' << endl;
(gdb) 
[hello]
27        for (const auto& word : SplitIntoWords(query)) {
(gdb) 
28            cout << '[' << word << ']' << endl;
(gdb) 
[kitty]
27        for (const auto& word : SplitIntoWords(query)) {
(gdb) 
26        const string query = "hello kitty"s;
(gdb) 
30    }
(gdb) 
__libc_start_main (main=0x55555555553a <main()>, argc=1, argv=0x7fffffffdf48, init=<optimized out>, fini=<optimized out>, 
    rtld_fini=<optimized out>, stack_end=0x7fffffffdf38) at ../csu/libc-start.c:342
342    ../csu/libc-start.c: No such file or directory.
(gdb) 
[Inferior 1 (process 18669) exited normally] 
```
Видно, что после каждой итерации программа выводила очередное слово.

Если хотите не пропустить вызов функции `SplitIntoWords` и увидеть, что происходит внутри, вместо next используйте команду step:
```
(gdb) r
Starting program: /path/to/project/gdb_example 

Breakpoint 1, main () at gdb_example.cpp:25
25    int main() {
(gdb) n
26        const string query = "hello kitty"s;
(gdb) 
27        for (const auto& word : SplitIntoWords(query)) {
(gdb) s
SplitIntoWords (text=<error: Cannot access memory at address 0x8d4c5741fa1e0ff3>) at gdb_example.cpp:7
7    vector<string> SplitIntoWords(const string& text) {
(gdb) n
8        vector<string> words; 
```
Вы окажетесь в начале функции `SplitIntoWords`.

Распечатаем содержимое переменной `text`, дав команду `print`:
```
(gdb) p text
$2 = "hello kitty" 
```
Использовать `next` и `step` для пошагового прохода по программе можно и дальше. Добавим брейкпойнт и перейдём напрямую к обработке символа `k`:
```
(gdb) b 10 if text[i] == 'k'
Breakpoint 2 at 0x5555555553fc: file gdb_example.cpp, line 10.
(gdb) c
Continuing.

Breakpoint 2, SplitIntoWords (text="hello kitty") at gdb_example.cpp:10
10            if (text[i] == ' ') {
(gdb) p text[i]
$3 = (const __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type &) @0x7fffffffde26: 107 'k' 
```
- `b 10 if <условие>` — добавляет условный брейкпоинт на строке 10, первой строке цикла.
- `Breakpoint 2` — вторая точка остановки. Первая стоит на вызове функции `main`.
- Команда c — возобновляет выполнение программы. Брейкпойнт перехватил и приостановил его. Команда `continue` снова запускает программу.
- `p text[i]` — выводит значение `text[i]`. Это ссылка на символ `'k'`, как и ожидалось.

Команда *backtrace* позволяет посмотреть, в какой функции мы находимся, и какая другая функция её вызвала:
```
(gdb) backtrace 
#0  SplitIntoWords (text="hello kitty") at gdb_example.cpp:10
#1  0x0000555555555581 in main () at gdb_example.cpp:27 
```
Чтобы получить дополнительную информацию, поднимитесь по стеку вызовов функций (в данном случае в `main`):
```
(gdb) up
#1  0x0000555555555581 in main () at gdb_example.cpp:27
27        for (const auto& word : SplitIntoWords(query)) {
(gdb) p query
$5 = "hello kitty" 
```
Этих команд вполне достаточно для полноценной отладки. 

Пользователи Linux могут оценить ещё и визуальный режим:


Чтобы переключиться в него, используйте сочетание клавиш Ctrl+XA. Вводите XA последовательно при зажатом Ctrl.

Для выхода из отладчика введите команду `q`.