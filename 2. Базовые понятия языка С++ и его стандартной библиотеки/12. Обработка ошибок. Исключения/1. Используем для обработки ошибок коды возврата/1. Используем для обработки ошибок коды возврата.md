## Используем для обработки ошибок коды возврата

В этом уроке разберёмся, как обнаруживать внештатные ситуации в программе и реагировать на них, используя уже знакомые вам средства языка.

Рассмотрим программу, находящую корни квадратного уравнения:
```cpp
#include <cmath>
#include <iostream>
#include <utility>

using namespace std;

// Находим корни квадратного уравнения a*x^2 + b*x + c = 0
pair<double, double> SolveQuadraticEquation(double a, double b, double c) {
    // Находим дискриминант
    double discriminant = b * b - 4 * a * c;

    // Находим корни уравнения
    double x1 = (-b - sqrt(discriminant)) / (2 * a);
    double x2 = (-b + sqrt(discriminant)) / (2 * a);

    return {x1, x2};
}

int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;
    const pair<double, double> roots = SolveQuadraticEquation(a, b, c);

    cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
    cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
} 
```
Запустим код и проанализируем, что получится. Для некоторых входных данных программа выдаст понятные результаты:
```
Введите коэффициенты уравнения a*x^2 + b*x + c = 0
1 0 -4
Корни уравнения 1*x^2 + 0*x + -4 = 0
  x1=-2; x2=2 
```
При других входных данных результаты будут странные:
```
Введите коэффициенты уравнения a*x^2 + b*x + c = 0
1 0 4
Корни уравнения 1*x^2 + 0*x + 4 = 0
  x1=-nan; x2=-nan 
```
Дело в том, что во втором случае дискриминант квадратного уравнения оказался отрицательным, а функция `sqrt`, вычисляющая квадратный корень, для отрицательных чисел возвращает особое значение `nan` — «не число». Последующие операции с участием `nan` также возвращают «не число». Так или иначе, пользователю стоило бы выдать более осмысленный результат вроде сообщения «Уравнение не имеет действительных корней».

Есть несколько способов решить эту задачу.

**Способ 1 (плохой): нештатную ситуацию обнаруживает вызывающий код.** Проверку на отрицательность дискриминанта можно было бы разместить внутри функции `main` перед вызовом функции `SolveQuadraticEquation`:
```cpp
int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;
    if (b * b - 4 * a * c < 0) {
        cout << "Уравнение не имеет действительных корней"s << endl;
    } else {
        const pair<double, double> roots = SolveQuadraticEquation(a, b, c);

        cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
    }
} 
```
У этого способа несколько серьёзных недостатков. Функция пишется один раз, а применяется, как правило, многократно. Проверки в каждом месте использования `SolveQuadraticEquation` приводят к дублированию кода и ошибкам, особенно когда над проектом работает несколько человек. Другая проблема в том, что так мы выносим детали реализации функции за её пределы. Задача функции — упрощать использование фрагмента кода, а не усложнять его. Третья проблема — лишнее вычисление дискриминанта.

**Способ 2 (очень плохой): проверить корни на равенство *nan*, применив функцию *isnan*.** Функция `isnan` проверяет, будет ли переданное ей значение `double` «не-числом», то есть особым значением, показывающим что результат нельзя выразить вещественным числом:
```cpp
int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;

    pair<double, double> roots = SolveQuadraticEquation(a, b, c);
    if (!isnan(roots.first) && !isnan(roots.second)) {
        cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
    } else {
        cout << "Уравнение не имеет действительных корней"s << endl;
    }
} 
```
Недостаток этого способа в том, что функция решения уравнения в случае отрицательного дискриминанта выполняет вычисления, не имеющие смысла. Здесь это приводит к появлению результата, равного nan. В более сложных ситуациях игнорирование ошибок может привести к краху программы или порче данных.
**Способ 3: нештатную ситуацию обнаруживает сама функция.** Проверка на отрицательный дискриминант размещается внутри функции, выполняющей вычисления. Это решение устраняет дублирование кода и сохраняет детали реализации внутри функции. Но возникает проблема: надо сообщить вызывающему коду об ошибке.

Изменим сигнатуру функции так, чтобы она принимала по ссылке дополнительный параметр `success` типа `bool`:
```cpp
pair<double, double> SolveQuadraticEquation(double a, double b, double c, bool& success) {
    double discriminant = b * b - 4 * a * c;
    if (discriminant < 0) {
        success = false;
        // Функция должна вернуть пару значений. Пусть это будут нули
        return {0, 0};
    }
    success = true;

    double x1 = (-b - sqrt(discriminant)) / (2 * a);
    double x2 = (-b + sqrt(discriminant)) / (2 * a);
    return {x1, x2};
} 
```

В точке использования нужно завести переменную, передать её в функцию, а потом проверить значение:
```cpp
int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;

    bool success = false;
    const pair<double, double> roots = SolveQuadraticEquation(a, b, c, success);

    if (success) {
        cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
    } else {
        cout << "Уравнение не имеет действительных корней"s << endl;
    }
} 
```
Но и у третьего способа есть недостатки:
- функция стала принимать на один параметр больше;
- в случае ошибки функция возвращает результат `{0,0}`. Этот результат — не решение уравнения. Правильная его интерпретация отдаётся на откуп вызывающему коду, который должен предварительно проверить значение выходного параметра `success`.
Нужен другой способ. Снова изменим сигнатуру функции, чтобы она возвращала значение типа `bool`, сигнализирующее об успехе, а корни уравнения записывала в параметр, принимаемый по ссылке:
```cpp
bool SolveQuadraticEquation(double a, double b, double c, pair<double, double>& roots) {
    double d = b * b - 4 * a * c;
    if (d < 0) {
        return false;
    }

    double x1 = (-b - sqrt(d)) / (2 * a);
    double x2 = (-b + sqrt(d)) / (2 * a);
    roots = {x1, x2};
    return true;
}
```
В месте использования нужно заранее объявить переменную для сохранения результата и проверить возвращаемое значение функции в условном операторе:
```cpp
int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;

    pair<double, double> roots;
    if (SolveQuadraticEquation(a, b, c, roots)) {
        cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
    } else {
        cout << "Уравнение не имеет действительных корней"s << endl;
    }
} 
```
Нельзя сказать, что такой способ намного лучше третьего. Хотя функция не пытается вернуть суррогатное значение, проверка возвращаемого значения возлагается на вызывающий код. А об этом легко забыть:
```cpp
pair<double, double> roots;
// Здесь программист забыл проверить результат вызова функции
SolveQuadraticEquation(a, b, c, roots);
cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
```
Проблемы с проверкой возвращаемого значения можно частично решить, если пометить функцию `SolveQuadraticEquation` специальным атрибутом `[[nodiscard]]`. Так компилятор будет предупреждать, что возвращаемое значение функции не используется:

```cpp
[[nodiscard]] bool SolveQuadraticEquation(double a, double b, double c, 
                                          pair<double, double>& roots) {
    double d = b * b - 4 * a * c;
    if (d < 0) {
        return false;
    }

    double x1 = (-b - sqrt(d)) / (2 * a);
    double x2 = (-b + sqrt(d)) / (2 * a);
    roots = {x1, x2};
    return true;
} 
```
При попытке скомпилировать код увидим предупреждение:
```
warning: ignoring return value of function declared with 'nodiscard' attribute [-Wunused-result]
    SolveQuadraticEquation(a, b, c, roots);
    ^~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~ 
```
Казалось бы, победа! Но этот способ не панацея. В более сложной ситуации предупреждение о неиспользуемом результате выдаваться не будет:
```cpp
bool success;
/*...*/
pair<double, double> roots1, roots2;
success = SolveQuadraticEquation(a1, b1, c1, roots1);

// Информация об ошибке вычисления предыдущего уравнения оказалась утеряна
success = SolveQuadraticEquation(a2, b2, c2, roots2);
if (success) {
    /* обрабатываем roots1 и roots2 */
} 
```
Когда пишете надёжные программы, выдающие предсказуемые результаты, позаботьтесь об обработке нештатных ситуаций. Для этих целей подойдут коды возврата и атрибут `[[nodiscard]]`. Он предупреждает вас о неиспользуемом результате вызова функции или метода.