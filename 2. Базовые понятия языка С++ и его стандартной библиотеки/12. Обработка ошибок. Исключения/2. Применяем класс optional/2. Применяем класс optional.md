## Применяем класс optional
В прошлом уроке вы успели почувствовать неудобства, связанные с возвратом значений через выходные параметры функций:
- нужно заранее объявлять переменную-приёмник. Она передаётся в функцию по ссылке, куда функция записывает результат своей работы;

- нужно инициализировать выходной параметр внутри функции;
  
- нельзя использовать константы в качестве выходных параметров функций.

Вот был бы способ возвращать из функции результат, говорящий об отсутствии значения! Такой способ есть, и вы его освоите прямо сейчас.

Возьмём решение, когда функция может либо вернуть некоторый результат, либо не вернуть его — например из-за ошибки. Чтобы улучшить решение, применим встроенный в стандартную библиотеку шаблонный класс `std::optional`. Он задаёт опциональное значение, которое может быть:2
- обычным значением некоторого выбранного вами типа,
- специальным значением `nullopt`, показывающим отсутствие данных.

С `optional` ваша программа способна работать с переменными, которые в один момент времени хранят значение, а в другой — остаются пустыми. Опциональные значения могут быть простой альтернативой кодам возврата, хотя их область применения этим не ограничивается. 

Чтобы воспользоваться `optional` нужно подключить библиотеку `<optional>`. Как и в случае с контейнерами, тип значения, которое хранится в `optional`, нужно указать внутри угловых скобок:
```cpp
// Включим стандартный файл, содержащий std::optional
#include <optional>

using namespace std;

// ...
// Функция возвращает пару корней квадратного уравнения либо пустое значение, когда решения нет
optional<pair<double, double>> SolveQuadraticEquation(double a, double b, double c) {
    double discriminant = b * b - 4 * a * c;
    if (discriminant < 0) {
        // Возвращаем специальное значение nullopt, означающее отсутствие значения
        return nullopt;
    }

    double x1 = (-b - sqrt(discriminant)) / (2 * a);
    double x2 = (-b + sqrt(discriminant)) / (2 * a);

    // Возвращаем корни уравнения
    return pair{x1, x2};
} 
```
Проверить экземпляр `optional` на наличие в нём значения можно, используя метод `has_value`. Ещё вы можете обращаться с `optional` как со значением типа `bool`, например в операторах ветвления. Пустой объект `optional` будет вести себя как `false`, а непустой — как `true`:
```cpp
optional<int> result;
...
if (result.has_value()) // либо просто: if (result)
{
    // result содержит значение
} else {
    // в переменной result пусто
}
```
Чтобы получить доступ к значению, хранящемуся внутри `optional`, используют метод `value` и унарный оператор `*`. Если внутри `optional` хранится структура или класс, можно получить доступ к его полям напрямую. Для этого есть специальный оператор `->`:
```cpp
int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;
    // Вместо const optional<pair<double, double>> roots используем auto,
    //     позволяя компилятору вывести тип переменной roots самостоятельно
    if (const auto roots = SolveQuadraticEquation(a, b, c);
        roots.has_value())
    {
        cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        // Доступ к значению можно получить при помощи метода roots.value() или (*roots)
        // Если внутри хранится структура или класс, то доступ к его полям 
        //   можно получить при помощи ->
        cout << "  x1="s << roots.value().first << "; x2="s << roots->second << endl;
    } else {
        cout << "Уравнение не имеет действительных корней"s << endl;
    }
}
```
Переменную `roots` мы объявили прямо внутри условного выражения оператора `if`, а после `;` проверили её значение. Такой способ объявления переменной позволяет ограничить её область видимости границами оператора `if`, если за пределами этого оператора переменная не используется:
```cpp
if (string name = ReadString(); !name.empty()) {
    cout << "Привет, "s << name << endl;
} else {
    cout << "Привет, незнакомец"s << endl;
}
```
Для типа `optional` перегружена операция приведения к типу `bool`. Поэтому проверить наличие значения можно просто:
```cpp
// Значение roots будет проверено на наличие значения 
// при помощи оператора приведения к типу bool
if (const auto roots = SolveQuadraticEquation(a, b, c)) {
    cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
    cout << "  x1="s << roots.value().first << "; x2="s << roots->second << endl;
} else {
    cout << "Уравнение не имеет действительных корней"s << endl;
}
```
Применив `optional`, мы смогли написать функцию, которая способна сообщить об ошибке в ходе работы. При этом дополнительные выходные параметры в сигнатуру функции вводить не надо. Ключевое слово `auto` избавляет от многословности при объявлении типа переменной.