## Ускоряем поиск документов
В прошлом уроке вы научили поисковую систему обрабатывать минус-слова. Благодаря этому можно составлять более точно поисковые запросы, отсекая ненужные документы. 

Однако с ростом количества документов вы станете замечать, что поиск требует всё больше и больше времени.

В этом уроке вы примените такой способ хранения документов, который позволяет быстро выполнять поиск по ключевым словам среди большого количества документов.

Взгляните на код методов `FindAllDocuments` и `MatchDocument`, составляющих ядро поисковой системы:

```cpp
vector<Document> FindAllDocuments(const Query& query) const {
    vector<Document> matched_documents;
    for (const auto& document : documents_) {
        const int relevance = MatchDocument(document, query);
        if (relevance > 0) {
            matched_documents.push_back({document.id, relevance});
        }
    }
    return matched_documents;
}

static int MatchDocument(const DocumentContent& content, const Query& query) {
    if (query.plus_words.empty()) {
        return 0;
    }
    set<string> matched_words;
    for (const string& word : content.words) {
        if (query.minus_words.count(word) != 0) {
            return 0;
        }
        if (matched_words.count(word) != 0) {
            continue;
        }
        if (query.plus_words.count(word) != 0) {
            matched_words.insert(word);
        }
    }
    return static_cast<int>(matched_words.size());
} 
```

Метод `FindAllDocuments` для каждого документа вычисляет его релевантность и возвращает найденные документы с ненулевой релевантностью. Чтобы найти релевантность, метод `MatchDocument` перебирает все слова документа и проверяет их вхождение внутрь множества плюс- и минус-слов.

Итак, наш алгоритм плохо подходит для поиска среди большого количества документов. Основная его проблема в том, что он проверяет в каждом документе наличие плюс- и минус-слов. С ростом количества документов такой поиск будет занимать всё больше и больше времени.

### Инвертированный индекс

Для эффективного поиска текста среди большого количества документов применяется инвертированный индекс. Это структура данных, в которой каждому слову соответствует множество документов, в которых это слово встречается.

Построим инвертированный индекс. Для примера возьмём следующий набор документов.
#### Документы

|Документ|
|:-:|
|0. белый кот пушистый хвост|
|1. пятнистый пёс выразительные глаза|
|2. упитанный пушистый чёрный кот|
|3. ласковый ласковый чёрный кот|


Изначально индекс пуст. После добавления документа с id=0 и текстом «белый кот пушистый хвост» в индексе появятся четыре слова. Для каждого из этих слов множество id документов будет содержать только один элемент, равный 0.
#### Инвертированный индекс после добавления документа 0
|Слово|	Id документов|
|:-:|:-:|
|белый|	0|
|кот|	0|
|пушистый|	0|
|хвост|	0|

После добавления документа «пятнистый пёс выразительные глаза» в индексе появятся ещё четыре слова.

#### Инвертированный индекс после добавления документа 1
|Слово|Id документов|
|:-:|:-:|
|белый|0|
|выразительные|1|
|глаза|1|
|кот|0|
|пёс|1|
|пушистый|0|
|пятнистый|1|
|хвост|0|

После добавления документа «упитанный пушистый чёрный кот» с id=2 в индекс добавятся слова «упитанный» и «чёрный». Слова «пушистый» и «кот» в индексе уже есть, поэтому к набору их документов добавится id=2.

#### Инвертированный индекс после добавления документа 2
|Слово|Id документов|
|:-:|:-:|
|белый|0|
|выразительные|1|
|глаза|1|
|кот|0, 2|
|пёс|1|
|пушистый|0, 2|
|пятнистый|1|
|упитанный|2|
|хвост|0|
|чёрный|2|

На последнем шаге добавляется документ «ласковый ласковый чёрный кот» с id=3. Слово «ласковый» в этом документе встречается несколько раз, но в индексе это будет одна запись.

#### Инвертированный индекс после добавления документа 3
|Слово|Id документов|
|:-:|:-:|
белый|	0
выразительные|	1
глаза|1
кот|0, 2, 3
ласковый|3
пёс|1
пушистый|0, 2
пятнистый|1
упитанный|2
хвост|0
чёрный|2, 3

Опишем алгоритм добавления документа в индекс по шагам:
1. Документ разбивается на слова, из него исключаются стоп-слова. Этот этап присутствовал и в прежней, нативной версии алгоритма.
2. Выполняется перебор слов документа. В множество документов, соответствующих очередному слову, добавляется `id` текущего документа.

### Поиск документов с использованием инвертированного индекса

Добавление документа в индекс стало сложнее, чем раньше. Но это стоит того. Рассмотрим, как будет происходить поиск документа по инвертированному индексу.

Рассмотрим поиск по запросу: «-пушистый чёрный кот».

Сначала надо найти релевантность всех документов, в которых присутствуют плюс-слова: «чёрный» и «кот».

Сначала увеличиваем на единицу релевантность всех документов, в которых содержится слово «чёрный». Из индекса сразу можно увидеть, что это документы с `id`, равным 2 и 3. Так как это самый первый проход, релевантность найденных документов будет равна 1.

#### Результаты поиска после обработки слова «чёрный»

Id документа	|Релевантность	|Текст|
|:-:|:-:|:-:|
2	|1	|упитанный пушистый чёрный кот
3	|1|	ласковый чёрный кот

Теперь увеличиваем на единицу релевантность документов, в которых есть слово «кот». Это документы с id 0, 2 и 3. 

#### Результаты поиска после обработки слова «кот»
Id документа|	Релевантность|	Текст
|:-:|:-:|:-:|
0	|1|	белый кот пушистый хвост
2	|2|	упитанный пушистый чёрный кот
3	|2|	ласковый чёрный кот

После обработки всех плюс-слов нужно исключить все документы, в которых встречаются минус-слова, независимо от вычисленной релевантности документов. Из инвертированного индекса видно, что слово «пушистый» входит в документы 0 и 2. После исключения этих документов в результатах поиска окажется единственный документ.

#### Результаты поиска после исключения минус-слов
Id документа|	Релевантность|	Текст
|:-:|:-:|:-:|
3	|2|	ласковый чёрный кот

Порядок обработки минус-слов влияет на последовательность исключения документов из результатов поиска. Математика говорит, что итоговый результат будет один и тот же.

### Представление инвертированного индекса на C++

Итак, инвертированный индекс выглядит немного сложнее, чем простое хранение вектора документов. Зато при поиске по этому индексу обрабатываются только те документы, в которые входят слова из списка плюс- и минус-слов поискового запроса, что многократно ускоряет поиск.

Взгляните ещё раз на индекс, построенный для документов. Пришло время выбрать для него оптимальную структуру данных.

##### Инвертированный индекс
|Слово	|Id документов|
|:-:|:-:|
белый	|0
выразительные|	1
глаза	|1
кот	|0, 2, 3
ласковый|	3
пёс	|1
пушистый|	0, 2
пятнистый|	1
упитанный|	2
хвост	|0
чёрный	|2, 3

Контейнеры, составляющие инвертированный индекс, должны позволять быстро находить `id` документов по словам из поискового запроса. Для этой задачи хорошо подходит контейнер `map`, ключи которого — слова из проиндексированных документов. В качестве значений лучше подходит `set<int>`, в котором id документов не дублируются.

Получится словарь, в котором хранятся контейнеры `set`. Обращаться с ними можно как и с любыми другими значениями. Например, так мы сможем добавить документ с id 5 в словарь по ключу `"dog"`:

```cpp
map<string, set<int>> index;

// index["dog"] — это контейнер set. Чтобы добавить элемент в set 
// нужно вызвать метод insert:
index["dog"].insert(5); 
```

При этом можно пользоваться особенностями операции `[]`. Если мы обратимся по несуществующему ключу, то он будет создан автоматически и проинициализирован значением по умолчанию. Для контейнера `set` значение по умолчанию — это пустое множество.

Пора перейти от теории к практике и ускорить поисковую систему, используя инвертированный индекс.