## Захват переменных по значению
```cpp
int CountMoreThanFive(const vector<int>& v) {
    int result = 0;
    for (int value : v) {
        if (value > 5) {
            ++result;
        }
    }
    return result;
}
int main() {
    const vector<int> v = {1, 3, 5, 2, 6, 7, 10, 2, 3};
    cout << CountMoreThanFive(v) << endl;
} 
```
Многовато кода для такой простой задачи. Лучше использовать алгоритм `count_if` и лямбда-функцию. Тогда даже отдельная функция `CountMoreThanFive` не понадобится:
```cpp
const vector<int> v = {1, 3, 5, 2, 6, 7, 10, 2, 3};
cout << count_if(begin(v), end(v), [](int x) { return x > 5; }) << endl; 
```
И код лаконичнее, и работы меньше.

Теперь представим другую ситуацию. Вы решили посчитать количество чисел со значением больше некоторого числа из стандартного ввода. Для этого вы заменили 5 на `threshold`:
```cpp
int main() {
    int threshold;
    cin >> threshold;
    const vector<int> v = {1, 3, 5, 2, 6, 7, 10, 2, 3};
    cout << count_if(begin(v), end(v), [](int x) { return x > threshold; }) << endl;
        //                                                        ^ заменили 5 на threshold 
}
```
Такой код не скомпилируется:

```
..\src\hw.cpp: In lambda function:
..\src\hw.cpp:26:63: error: 'threshold' is not captured
     cout << count_if(begin(v), end(v), [](int x) { return x > threshold; }) << endl;
                                                               ^~~~~~~~~
..\src\hw.cpp:26:41: note: the lambda has no capture-default
     cout << count_if(begin(v), end(v), [](int x) { return x > threshold; }) << endl;
                                         ^
..\src\hw.cpp:22:9: note: 'int threshold' declared here
     int threshold;
         ^~~~~~~~~ 
```
Компилятор говорит: “'threshold' is not captured”. С++ спроектирован по принципу «не платите за то, чем не пользуетесь». Это касается и лямбда-функций. 

В общем случае внешние по отношению к лямбда-функции объекты могут требовать дополнительного времени и памяти. Если программист сделает опечатку в коде лямбда-функции и случайно обратится ко внешней переменной, такие расходы возникнут внезапно. 

Поэтому, чтобы использовать внешнюю переменную внутри лямбда-функции, её надо явно захватить — указать имя переменной в квадратных скобках перед параметрами лямбда-функции:
```cpp
int main() {
    int threshold;
    cin >> threshold;
    const vector<int> v = {1, 3, 5, 2, 6, 7, 10, 2, 3};
    cout << count_if(begin(v), end(v), [threshold](int x) { return x > threshold; }) << endl;
//                                      ^ вот здесь теперь указана переменная threshold
} 
```
Теперь код компилируется и корректно работает. Явный захват внешних переменных в лямбда-функции выражает ваше намерение их применить и «заплатить только за то, что будете использовать». Это безопасный и предсказуемый подход.
Из переменной, захваченной таким образом, можно только читать:
```cpp
int main() {
    int x = 0;
    auto lambda = [x]() { ++x; };
    lambda(); // да, лямбда-функции можно присваивать переменным, а потом вызывать как обычные функции
} 
```
Код выше не компилируется:
```
..\src\hw.cpp: In lambda function:
..\src\hw.cpp:23:29: error: increment of read-only variable 'x'
     auto lambda = [x]() { ++x; };
                             ^ 
```
В C++ есть способ менять захваченные переменные внутри лямбда-функции. О нём — позже в курсе.