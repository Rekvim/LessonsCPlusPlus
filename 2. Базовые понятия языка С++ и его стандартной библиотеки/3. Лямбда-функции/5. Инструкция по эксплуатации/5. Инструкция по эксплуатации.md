## Инструкция по эксплуатации
Вы познакомились с лямбда-функциями — синтаксическим сахаром С++. Разберёмся, как получить от них максимум пользы.
### Делайте лямбда-функции лаконичными
Основная цель лямбда-функций — сделать код проще для понимания. Например, по такому коду сразу видно, что выполняется сортировка по убыванию:
```cpp
sort(v.begin(), v.end(), [](int x, int y) { return x > y; }); 
```
Сложная логика в лямбда-функциях потребует слишком много внимания. Такой код лучше вынести в отдельную функцию.
Вот как выглядит громоздкая и непонятная лямбда-функция:
```cpp
struct Person {
    int age;
    string first_name;
    string last_name;
    bool graduated_from_university;
    string city;
};
void FindPeopleLikeMe(const vector<Person>& people) {
    int people_like_me_count = count_if(people.begin(), people.end(),
        [](const Person& p) {
            if (p.age < 18 || p.age > 40) {
                return false;
            }
            if (p.last_name != "Ivanov") {
                return false;
            }
            if (p.first_name == "Vasiliy" || p.first_name == "Petr") {
                return false;
            }
            if (p.city == "Moscow" || p.city.find("Petersburg") != string::npos) {
                return false;
            }
            return p.graduated_from_university;
        });
    // ...
} 
```
То же самое можно записать проще:
```cpp
struct Person {
    int age;
    string first_name;
    string last_name;
    bool graduated_from_university;
    string city;
};
bool IsLikeMe(const Person& p) {
    if (p.age < 18 || p.age > 40) {
        return false;
    }
    if (p.last_name != "Ivanov") {
        return false;
    }
    if (p.first_name == "Vasiliy" || p.first_name == "Petr") {
        return false;
    }
    if (p.city == "Moscow" || p.city.find("Petersburg") != string::npos) {
        return false;
    }
    return p.graduated_from_university;
}
void FindPeopleLikeMe(const vector<Person>& people) {
    int people_like_me_count = count_if(people.begin(), people.end(), IsLikeMe);
    // ...
} 
```
### Используйте лямбда-функции в алгоритмах
Лучшее место для лямбда-функций — предикаты в алгоритмах `sort`, `count_if` и в стандартных алгоритмах, о которых пойдёт речь позже.
### Контролируйте захватываемые локальные переменные
Допустим, грустный пользователь решил посчитать, сколько людей посетило больше стран, чем он (или она):

```cpp
struct Person {
    int age;
    string first_name;
    string last_name;
    set<string> visited_countries;
};
int CountBetterTravellersThanMe(const Person& me, const vector<Person>& people) {
    return count_if(people.begin(), people.end(), [](const Person& p) {
        return p.visited_countries.size() > me.visited_countries.size();
    });
} 
```

Код не скомпилируется, потому что переменная me не захвачена: 

```
..\src\hw.cpp: In lambda function:
..\src\hw.cpp:18:45: error: 'me' is not captured
         return p.visited_countries.size() > me.visited_countries.size(); 
```
Чтобы код скомпилировался, переменную me нужно захватить по значению:

```cpp
int CountBetterTravellersThanMe(const Person& me,
    const vector<Person>& people) {
    return count_if(people.begin(), people.end(), [me](const Person& p) {
        return p.visited_countries.size() > me.visited_countries.size();
    });
} 
```
Это самый простой, но неэффективный способ. Произойдёт глубокое копирование множества `visited_countries`. В общем случае такое копирование занимает много времени. Приемлемым решением будет захватить переменную `me` по ссылке:

```cpp
int CountBetterTravellersThanMe(const Person& me,
    const vector<Person>& people) {
    return count_if(people.begin(), people.end(), [&me](const Person& p) {
        return p.visited_countries.size() > me.visited_countries.size();
    });
} 
```
Но есть способ лучше. От переменной `me` внутри лямбда-функции нужен только размер множества. Размер можно сохранить в целочисленную переменную и захватить в лямбде эту переменную, а не `me`:
```cpp
int CountBetterTravellersThanMe(const Person& me,
    const vector<Person>& people) {
    int my_visited_countries = me.visited_countries.size();
    return count_if(people.begin(), people.end(),
        [my_visited_countries](const Person& p) {
            return p.visited_countries.size() > my_visited_countries;
        });
} 
```
Так вы скопируете в лямбда-функцию всего одну целочисленную переменную.

Вы прошли путь от очевидного решения до способа, который не только заставляет программу компилироваться, но и работает эффективно.

### Захватывайте переменные простых типов по значению
Может возникнуть желание захватывать все переменные по ссылке, ведь это никогда не приводит к глубокому копированию:

```cpp
int main() {
    int threshold;
    cin >> threshold;
    const vector<int> v = {1, 3, 5, 2, 6, 7, 10, 2, 3};
    cout << count_if(begin(v), end(v), [&threshold](int x) { return x > threshold; }) << endl;
//                                      ^ threshold захвачен по ссылке
} 
```
Делать так не стоит. Переменные, захваченные по ссылке, можно изменять изнутри лямбда-функции. Код ниже выводит 5:

```cpp
int main() {
    int x;
    auto lambda = [&x]() { x = 5; };
    lambda();bool
    cout << x << endl;
} 
```
У захвата переменной по ссылке две возможные цели: 
- избежать долгого глубокого копирования;
- дать лямбда-функции возможность изменить локальную переменную. Это нужно довольно редко.

Переменные простых типов — `int`, `double`, `char`, `bool` — копируются быстро. Захват таких переменных по ссылке может вызвать у читателя вашего кода ощущение, что вы собираетесь их изменять.

Чтобы явно показать свои намерения, захватывайте переменные простых типов по значению, а переменные сложных типов — по ссылке.