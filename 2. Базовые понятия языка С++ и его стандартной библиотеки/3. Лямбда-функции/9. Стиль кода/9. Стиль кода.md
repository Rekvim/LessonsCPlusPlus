## Стиль кода

Вы уже познакомились с большим количеством разнообразных элементов языка C++ и можете написать достаточно объёмные программы. Но надо помнить, что ваш код — это не только инструкции для компилятора, но и средство коммуникации с другими людьми. Бо́льшую часть времени разработчики тратят на то, чтобы читать код, а не писать его. Стремитесь к тому, чтобы ваш код делал коммуникацию между людьми эффективной. Для этого весь код нужно оформлять в едином стиле.


В этом спринте вам предстоит сдавать свой первый проект на ревью. Работу будет проверять код-ревьюер. Чтобы он обращал внимание на тонкости реализации и не отвлекался на детали оформления, стоит определиться со стилем и привести к нему свой код.

### Стили именования идентификаторов
Начнём с имён. Чаще всего, чтобы задать имя чему-либо в коде, одного слова недостаточно. А пробелы использовать нельзя. Чтобы обойти это ограничение и не получить абракадабру, придумали стили именования. Самые популярные:

- camelCase или lowerCamelCase. Он же — верблюжий стиль. Называется так, потому что каждое слово начинается с заглавной буквы, кроме первого.
- PascalCase или UpperCamelCase. Стиль похож на camelCase, но первое слово тоже начинается с заглавной буквы. Привет языку Pascal!
- snake_case. Или змеиный стиль. Все слова пишутся строчными буквами. Между словами расставляются подчёркивания.
- UPPER_SNAKE_CASE. Этот стиль стоит отметить отдельно. Это змеиный стиль, в котором все буквы заглавные.

Есть ещё один популярный стиль именования — `kebab-case`. Но к C++ он не применим. Он похож на `snake_case`, только между словами используются дефисы или минусы. Символ «минус» имеет особое значение для компиляторов C++. Имя `kebab-case` будет воспринято как `kebab` минус `case`.

### Именуем
Теперь, когда мы разобрались с заданием имён, определимся с правилами именования кода. В разных компаниях эти правила могут отличаться. Главное, чтобы коллеги, работающие над одними проектами, могли поддерживать код друг друга.

Стиль именования в Яндекс Практикуме основан на Google C++ Style Guide.

- Переменные, параметры функций и поля структур записывайте в `snake_case`;
- Поля классов записывайте в `snake_case_` с подчёркиванием в конце;
- Для функций и методов используйте `PascalCase`;
- Структуры и классы записывайте в `PascalCase`;
- Для глобальных констант используйте `UPPER_SNAKE_CASE`.

Посмотрите на программу, которая рассчитывает объём аквариума. Самостоятельно определите, где какие стили использованы.
```cpp
...

const int MAX_FISH_COUNT = 10;

struct AquariumFish {
    string name;
    string color;
    int length;
};

double CalculateAquariumVolume(const vector<AquariumFish>& fish) {
    ...
}

class AquariumWithFish {
public:
    void AddFish(const AquariumFish& fish) { ... }

private:
    vector<AquariumFish> fish_;
};

int main() {
    vector<AquariumFish> fish;
    ...
    double aquarium_volume = CalculateAquariumVolume(fish);
    ...
} 
```

Обратите внимание: имена идентификаторов написаны на английском языке. Такой подход делает ваш код интернациональным.

Старайтесь давать полные названия сущностям кода. Используйте только устоявшиеся сокращения. Например, для глобальной константы можно не писать `MAXIMUM_VOLUME`, понятно и `MAX_VOLUME`. А вот если назвать функцию `CalculateAquariumVolume() `покороче, например,  `CalcAquaVol()`, то можно подумать, что мы хотим вычислить объём воды. Или водное напряжение. Вдруг в вашем аквариуме будут жить электрические угри?

Однако для счётчиков, например, в циклах, можно использовать и однобуквенные имена, если точно понятно, о чём идёт речь. Для вложенных циклов подойдут имена `i`, `j`, `k`.

```cpp
for (int i = 0; i < MAX_FISH_COUNT; ++i) {
    ...
} 
```

Для именования отдельных объектов выбирайте единственное число, для коллекций — множественное. Также множественное число можно использовать в именах переменных, которые хранят количество чего-либо.
```cpp
string aquarium_item;
vector<string> aquarium_items;
set<string> unique_aquarium_items;
int number_of_aquarium_items; 
```

И ещё одно правило — чем меньше область видимости переменной, тем короче может быть её имя. Однако по имени переменной должно быть понятно, какую она играет роль. Имя должно полностью отражать сущность хранимых данных в переменной. Но старайтесь не превышать 4-5 слов.

#### Подключение библиотек

Чтобы использовать в коде какие-то элементы кроме стандартных, нужно подключать библиотеки. Это делается с помощью директивы включения `#include`. Библиотеки следует объявлять только в начале файла и сортировать по алфавиту. Тогда можно будет отследить, что используется в коде и используется ли на самом деле. Это особенно полезно, когда ваш код разрастается и директив становится больше.

```cpp
#include <map>
#include <set>
#include <string>
#include <vector> 
```
Всегда обращайте внимание на подключенные библиотеки. Если вы заменили один контейнер на другой, например, отказались от вектора в пользу словаря, подключите соответствующую библиотеку.


#### Отступы и пустые строки
Вы уже могли обратить внимание, что в примерах кода в теории и авторских решениях текст внутри разных областей видимости пишется со смещением. Это сделано, чтобы явно обозначить структуру разных блоков кода:
- ветки в операторе `if`;
- тела циклов, особенно вложенных;
- функции и структуры.

Тогда при чтении кода будет затрачиваться меньше усилий, чтобы понять, какие блоки кода вложены в другие. В качестве отступа мы рекомендуем использовать четыре пробела.
```cpp
int main() {
    // Внутри блока код отступает на четыре пробела
    cout << "Four spaces"s << endl;
} 
```
Не используйте специальные символы — например, знак табуляции. Во многих редакторах кода длина одной табуляции и четырёх пробелов совпадает. Поэтому клавиша “Tab” может показаться удобным решением: проще один раз нажать на кнопку, а не четыре. Но вы удивитесь, когда отправите очередной коммит на гитхаб. Скорее всего, код запляшет.

Таких сюрпризов можно избежать — настройте клавишу Tab, чтобы по её нажатию выводилось 4 пробела по умолчанию. Хорошая новость — в тренажёре эта настройка активирована.

Разделяйте функции и классы пустой строкой. Лучше использовать пустые строки и внутри функций, чтобы выделить отдельные функциональные блоки. Это повысит читаемость кода.

Сравните две версии одной и той же программы. Вот программа без отступов:
```cpp
#include <iostream>
using namespace std;
int main() {
for (int number = 2; number <= 100; ++number) {
bool is_prime = true;
for (int i = 2; i * i <= number; ++i) {
if (number % i == 0) {
is_prime = false;
break;
}}
if (is_prime) {
cout << number << ", "s;
}}} 
```
Вот та же программа, но с отступами и пустыми строками:
```cpp
#include <iostream>

using namespace std;

int main() {
    for (int number = 2; number <= 100; ++number) {
        bool is_prime = true;

        for (int i = 2; i * i <= number; ++i) {
            if (number % i == 0) {
                is_prime = false;
                break;
            }
        }

        if (is_prime) {
            cout << number << ", "s;
        }
    }
} 
```

На чтение второй программы требуется гораздо меньше усилий: отступы и пустые строки упрощают понимание структуры программы и выделяют в ней функциональные блоки.

#### Функции и методы классов

Функции позволяют выделить в программе самостоятельные блоки кода, предназначенные для многократного использования, и дать им понятные имена. Например, если в программе для вывода простых чисел из примера выше выделить внутренний цикл в отдельную функцию `IsPrime`, то разобраться в коде станет ещё легче:
```cpp
#include <iostream>

using namespace std;

bool IsPrime(int number) {
    if (number < 2) return false;

    for (int i = 2; i * i <= number; ++i) {
        if (number % i == 0) {
            return false;
        }
    }

    return true;
}

int main() {
    for (int number = 2; number <= 100; ++number) {
        if (IsPrime(number)) {
            cout << number << ", "s;
        }
    }
} 
```
В качестве первого слова в названиях функций и методов используйте глаголы, чтобы подчеркнуть, что именно эта функция или метод выполняют. Например, функцию расчёта объёма аквариума мы назвали CalculateAquariumVolume(). Возможны и исключения, если они повышают читаемость кода: sin для синуса, DegreeToRadians, ToString, AsInteger.

Устоявшиеся глаголы для методов:
- Set — установить значение,
- Get — получить значение,
- Compute — вычислить что-либо. Скорее всего, этот метод будет использовать больше ресурсов,
- Find — найти что-либо,
- Initialize — проинициализировать, то есть установить некоторое состояние чему-либо.
  
Для методов, возвращающих `bool`, можно использовать:

- Is
- Has
- Contains

Создадим класс «Аквариум с рыбками» и добавим в него несколько публичных методов:
```cpp
class AquariumWithFish {
public:
    // Добавить рыбку
    void AddFish(const AquariumFish& fish) {
       ...
    }

    // Взять рыбку по имени name (чтобы посмотреть)
    const AquariumFish& GetFish(const string& name) const {
        ...
    }

    // Удалить рыбку
    void DeleteFish(const AquariumFish& fish) {
       ...
    }

    // Убедиться, что в аквариуме есть рыбы
    bool ContainsFish() const {
       ...
    }

    // Убедиться, что аквариум пустой. Противоположный предыдущему метод
    bool IsEmpty() const {
       ...
    }

    ...
}; 
```

В коде даны поясняющие комментарии, но назначение методов читается и без них.

#### Структуры и классы

Используйте структуры для объединения полей и простого обращения с ними.

Используйте классы, чтобы описать тип с открытым интерфейсом и скрытой реализацией. В классах сначала описывайте публичную область `public`, затем защищённую `protected` (с ней ещё предстоит познакомиться) и только потом приватную `private`. Не располагайте поля в публичной области, для этого есть структуры.

Поля классов должны иметь понятные полные названия. Добавляйте к ним суффикс-подчёркивание для наглядности. Это поможет и при работе с конструкторами класса, о которых будет рассказано в следующем спринте.

Продолжим реализацию аквариума. У аквариума должен быть размер. Для объединения длины, ширины и высоты аквариума подойдёт структура `Size`. Также надо следить за уровнем воды в аквариуме и не забывать её доливать.
```cpp
struct Size {
    double length = 25;
    double width = 15;
    double height = 20;
}
/* Здесь пустая строка */
class AquariumWithFish {
public:
    void AddFish(const AquariumFish& fish) {
        ...
    }
    /* Здесь пустая строка */
    const AquariumFish& GetFish(const string& name) const {
        ...
    }
    /* Здесь пустая строка */
    void AddWater() {
        ...
    }

    ...

private:
    Size size_;
    int water_level_;
    vector<AquariumFish> fish_;
}; 
```
#### Фигурные скобки
Фигурные скобки служат для объединения нескольких операций в один блок. Есть несколько подходов, как их расставлять: 
- открывающая фигурная скобка остаётся на строке объявления функции:
   ```cpp
   int main() {
      cout << "Hello, friend!" << endl;
   } 
   ```
- открывающая фигурная скобка переносится на следующую строку:
   ```cpp
   int main()
   {
      cout << "Hello, friend!" << endl;
   } 
   ```

Мы придерживаемся первого способа, так как он позволяет записывать код чуть плотнее.

Для блоков if, else, for, while расставляйте фигурные скобки, даже если внутри одна инструкция. Если в будущем вы захотите выполнить не одну инструкцию, а несколько, с фигурными скобками это будет легче сделать.
```cpp
if (IsGoodStyle()) {
    return "That's good"!s;
} 
```
#### Магические числа

Магические числа обычно возникают всё в тех же арифметических выражениях. Это константы, значения которых не всегда понятны. Поэтому их лучше выносить из выражений и давать понятные имена.

Рассмотрим программу, которая принимает скорость в километрах в час и задаёт скорость ракеты в метрах в секунду.
```cpp
int main() {
    double speed_in_kmh;
    cin >> speed_in_kmh;
    // Переводим километры в час в метры в секунду
    double speed_in_ms = speed_in_kmh * 1000 / 3600;

    Rocket rocket;
    rocket.SetSpeed(speed_in_ms);

    ...
} 
```

Теперь код выглядит так:

```cpp
double KMetersPerHourToMetersPerSecond(double speed_in_kmh) {
    const int meters_per_kilometer = 1000;
    const int seconds_in_hour = 3600;
    return speed_in_kmh * meters_per_kilometer / seconds_in_hour;
}

int main() {
    double speed_in_kmh;
    cin >> speed_in_kmh;
    double speed_in_ms = KMetersPerHourToMetersPerSecond(speed_in_kmh);
    Rocket rocket;
    rocket.SetSpeed(speed_in_ms);

    ...
} 
```
#### Длина строки
Чтобы при чтении кода не приходилось листать его ещё и в горизонтальной оси, не оставляйте длинные строки. Ориентируйтесь на 80–100 символов в строке. В длинных выражениях ставьте перенос на новую строку так, чтобы код легко читался. При переносе арифметических операций переносите знак на следующую строку.
```cpp
// Перенос читается сложно
double x1 = (-b - sqrt(discriminate)) / (2
            * a);

// Перенос читается легко
double x1 = (-b - sqrt(discriminate))
            / (2 * a);

// Так как выражение короткое, код можно вообще не переносить
double x1 = (-b - sqrt(discriminate)) / (2 * a);
 ```
#### Комментарии
Комментировать код — это хорошо. Особенно на этапе продумывания проекта. В языке C++ есть два типа комментариев: однострочные и многострочные.
```cpp
// Однострочный комментарий

/*
    Блок
    комментариев
*/ 
```
Комментарий должен быть расположен над тем блоком, к которому он относится.
```cpp
// Вычисляем объём аквариума,
// учитываем количество рыб и их размер
double CalculateAquariumVolume(const vector<AquariumFish>& fish);
```
Есть случаи, когда многострочные комментарии могут пригодиться и внутри одной строки. Например, можно прокомментировать какой-нибудь из параметров функции:
```cpp
DrawArc(from, to, /*counter_clock_wise=*/false);
```
Но наличие большого числа комментариев не украсит ваш код. Лучше всего, когда все функции в коде короткие и из их названий понятно, что они выполняют. Такой код называется самодокументируемым и не требует поясняющих комментариев. В примере с конвертацией скорости мы сделали код самодокументируемым: вынесли расчёт в отдельную функцию и дали ей поясняющее название. Да, строчек кода стало больше, но времени, чтобы разобраться с кодом позже, потребуется меньше.
Придерживайтесь такого подхода и вы наверняка поблагодарите себя в будущем.

Вспомните функцию создания поискового сервера `CreateSearchServer()`. Её можно читать строчка за строчкой и понимать, что происходит на каждом этапе. Никакие комментарии не нужны.
```cpp
SearchServer CreateSearchServer() {
    SearchServer search_server;
    search_server.SetStopWords(ReadLine());
 
    const int document_count = ReadLineWithNumber();
    for (int document_id = 0; document_id < document_count; ++document_id) {
        search_server.AddDocument(document_id, ReadLine());
    }
 
    return search_server;
} 
```
Используйте комментарии там, где нужно объяснить некоторое неочевидное решение. Например, для случая, когда вы написали код, который обходит некоторую проблему в используемой библиотеке. Такие приёмы в коде обычно называют «костыли». Чтобы коллега по доброте душевной не решился этот «костыль» убрать и сломать то, что работает, оставьте предупреждение.
#### Запись логических выражений
И наконец, последнее, что мы рассмотрим в этом уроке, — логические выражения.

Посмотрите на программу распределения коробок:
```cpp
struct Box {
    int width = 0;
    int height = 0;
    int depth = 0;
    bool is_empty = true;
};

int main() {
    vector<Box> boxes;
    ...

    for (const Box& box : boxes) {
        // Здесь надо проверить коробку на пустоту
    }
}
```

В этом уроке вы прикоснулись к прекрасному. Теперь вы знаете, как сделать свой код не только рабочим, но и красивым, чтобы им можно было делиться с другими. И самим перечитывать с удовольствием.

Это основные правила оформления знакомых вам компонентов кода. Правил много, поэтому урок получился объёмным. Возвращайтесь к нему, когда будут вопросы.