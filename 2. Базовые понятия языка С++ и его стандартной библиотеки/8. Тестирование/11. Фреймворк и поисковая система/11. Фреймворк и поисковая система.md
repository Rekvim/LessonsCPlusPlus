## Флаги компиляции

Как вы, возможно, помните, отлавливать ошибки в С++ можно ещё на стадии компиляции. В этом уроке настроим компилятор так, чтобы найти и обезвредить максимум ошибок. 

Компилятор — программа. Её задача — преобразовать текстовый файл с кодом в программу. Не пугайтесь рекурсии: всё есть программа. Как в «Матрице». Даже компилятор — это результат компиляции некоторого кода.

Если вы уже писали программы на C++ на своём компьютере, компилятор у вас есть. Если нет, вернитесь в начало втрого спринта. На Linux и macOS компилятор стоит по умолчанию. Поставить и настроить его на Windows вы можете по инструкции в теме  «Работа со средой Visual Studio Code».

Мы рассмотрим работу с компилятором в консоли. Вывод приведён для g++ версии 10.0.1 на Ubuntu 20.04.1. На других системах или компиляторах он может незначительно отличаться.

Запустим g++ без параметров:
```
$ g++
g++-10: fatal error: no input files
compilation terminated.
```
Символ `$` вводить не нужно. В консоли он обычно используется как приглашение к вводу команды. Другой вариант приглашения — `>`. Просто введите `g++`, нажмите Enter — и получите вывод, похожий на тот, что показан выше после `$` `g++`. Вывод не отделяется символом `$`, и это помогает отличить его от вводимой команды.
Напишем простую программу, суммирующую два числа:
```cpp
#include <iostream>

using namespace std;

int main() {
    int x, y;
    cin >> x >> y;
    cout << x + y << endl;
} 
```
Сохраним её в файл example.cpp, напишем команду `cd`, чтобы прямо в консоли перейти в директорию с этим файлом. Скомпилируем файл из консоли:
```
$ g++ example.cpp -o example 
```
Читать эту команду нужно так: «Скомпилируй файл example.cpp, а результат положи в исполняемый файл example». Компиляция прошла успешно, поэтому никакого вывода не последовало.
Запустим полученную программу тут же в консоли и просуммируем числа 6 и 18:
```
$ ./example 
6 18
24 
```
На Windows вместо `./example` пишите `example.exe`.

Так вы можете компилировать код из консоли. 
Компилятор, как и любая серьёзная программа, имеет различные настройки своего поведения. Их можно менять флагами. Некоторые флаги отвечают за предупреждения. Вспомним сравнение знакового и беззнакового целых чисел:
```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    const vector<int> v = {6, 18, 2093};
    for (int i = 0; i < v.size(); ++i) {
        cout << v[i] << endl;
    }
} 
```
Если скомпилировать код как обычно, ничто не будет сигнализировать о потенциальной проблеме:
```
$ g++ unsigned_cmp.cpp -o unsigned_cmp 
```
Если включим вывод предупреждений флагом `-Wall` (all warnings), увидим:
```
$ g++ unsigned_cmp.cpp -Wall -o unsigned_cmp
unsigned_cmp.cpp: In function ‘int main()’:
unsigned_cmp.cpp:8:23: warning: comparison of integer expressions of different signedness: ‘int’ and ‘std::vector<int>::size_type’ {aka ‘long unsigned int’} [-Wsign-compare]
    8 |     for (int i = 0; i < v.size(); ++i) {
      |                     ~~^~~~~~~~~~ 
```
При этом программа скомпилируется и будет работать. А предупреждение невнимательный разработчик не заметит. Чтобы обезопасить себя, добавьте флаг `-Werror` — treat warnings as errors. Программа не скомпилируется, да ещё и подсветит проблему зловещим красным цветом:
```cpp
$ g++ unsigned_cmp.cpp -Wall -Werror -o unsigned_cmp
unsigned_cmp.cpp: In function ‘int main()’:
unsigned_cmp.cpp:8:23: error: comparison of integer expressions of different signedness: ‘int’ and ‘std::vector<int>::size_type’ {aka ‘long unsigned int’} [-Werror=sign-compare]
    8 |     for (int i = 0; i < v.size(); ++i) {
      |                     ~~^~~~~~~~~~
cc1plus: all warnings being treated as errors 
```
Комбинация флагов `-Wall -Werror` — залог счастья разработчиков на C++ по всему миру.

Флагом можно настроить и стандарт языка. Разные версии компиляторов поддерживают разные стандарты C++. Стандарт — это формальный документ, описывающий возможности языка. Новый стандарт — новые возможности.

Напишем простую программу, которая итерируется по словарю путём распаковки ключа и значения:
```cpp
#include <iostream>
#include <map>

using namespace std;

int main() {
    const map<string, int> cities_birth = {
        {"Moscow"s, 1147},
        {"Saint Petersburg"s, 1703},
        {"Petropavlovsk-Kamchatshiy"s, 1740},
    };
    for (const auto& [name, birth] : cities_birth) {
        cout << name << " is "s << 2020 - birth << " years old"s << endl;
    }
} 
```
Компилятор огорчает: распаковка поддерживается только при наличии определённого флага.
```
$ g++ map.cpp -Wall -Werror -o map
map.cpp: In function ‘int main()’:
map.cpp:12:22: error: structured bindings only available with ‘-std=c++17’ or ‘-std=gnu++17’ [-Werror]
   12 |     for (const auto& [name, birth] : cities_birth) {
      |                      ^
cc1plus: all warnings being treated as errors 
```
Добавляем флаг `-std=c++17`, и всё компилируется:
```
$ g++ map.cpp -Wall -Werror -std=c++17 -o map 
```
Этим флагом мы сказали компилятору включить все доступные в нём возможности стандарта C++17, выпущенного в 2017 году. Также можно включить флаги `c++11`, `c++14` и `c++20`. В стандартах C++11 и C++14 ожидаемо меньше возможностей, чем в C++17.

Есть и флаги, запускающие только одну стадию компиляции. В этом случае результатом может быть предварительно обработанный текст программы. Или наоборот: на вход подаётся почти готовая программа, которую человек уже не прочитает, а на выход — привычный исполняемый файл.