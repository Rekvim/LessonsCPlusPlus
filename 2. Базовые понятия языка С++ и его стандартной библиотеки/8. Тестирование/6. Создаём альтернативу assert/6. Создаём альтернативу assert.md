## Создаём альтернативу assert

В предыдущих уроках вы написали юнит-тесты, чтобы найти и исправить ошибки в решении задачи «Синонимы» и программе «Автобусные остановки».
Юнит-тесты были основаны на стандартном макросе `assert`, который проверяет ожидания от работы кода. Рассмотрим преимущества и недостатки этого макроса.
#### Преимущества

- Макрос `assert` показывает, какая именно проверка не сработала в модульном тесте, сообщает название файла и номер строки. Это помогает найти и выяснить причину ошибки. Простейший пример:
```cpp
#include <cassert>

int Add(int x, int y) {
    return x * y;
}

int main() {
    assert(Add(2, 3) == 5);
} 
```
При запуске программы `assert` «выстрелит»: аварийно прекратит её работу и выведет диагностическую информацию:
```cpp
test.exe: test.cpp:8: int main(): Assertion `Add(2, 3) == 5' failed. 
```
Макрос `assert` проверяет истинность условия, нарушение которого указывает на ошибку в логике программы или на противоречивость в её состоянии. Если условие ложное, программа завершает работу. А мы получаем диагностическую информацию о том, где код не прошёл тест.
На этом преимущества `assert` заканчиваются и начинаются недостатки.
#### Недостатки
- Диагностическая информация не содержит значений сравниваемых выражений. В примере выше не сработало условие `Add(2, 3) == 5`. Но какое именно значение вернула функция `Add`, мы не знаем. Чтобы выяснить это, приходится использовать отладчик.
  
- Первый же «выстреливший» `assert` прекращает работу программы и не даёт узнать, как пройдут остальные проверки.
  
- Макрос `assert` выводит диагностическую информацию в стандартный поток вывода, и она смешивается с выходными данными программы. Это может быть нежелательным.
  
Следующий недостаток разберём на примере:

```cpp
#define NDEBUG // Объявляем макрос NDEBUG
#include <cassert>

int Add(int x, int y) {
    return x * y; // Ошибка тут специально
}

int main() {
    assert(Add(2, 3) == 5); // Этот assert не сработает
} 
```
Запустим программу и увидим, что макрос `assert` не сработал. Дело в том, что мы объявили макрос `NDEBUG` перед подключением файла `cassert`. Определение макроса `assert` зависит от макроса `NDEBUG`, который по умолчанию не объявлен в стандартной библиотеке. Если объявить `NDEBUG` перед подключением файла `<cassert>`,  `assert` не будет делать ничего. Это позволяет ограничить использование макроса `assert` отладочными версиями программы и отключить проверки в финальной сборке программы.

Тесты для C++ пишут, используя не только макрос `assert`. Существуют целые фреймворки, такие как Google Test, Boost.Test, Catch2. На практике для разработки тестов применяют фреймворк, а макрос `assert` оставляют, чтобы проверить инварианты в отладочных версиях программы. Мы покажем, как это работает, разобрав устройство нашего тестового фреймворка.

Итак, при сравнении значений не видно, чему равен каждый из операндов, если assert «выстрелил». Устраним эту неприятность. Чтобы сравнивать значения разных типов, напишем функцию `AssertEqual`:
```cpp
AssertEqual(Add(2, 3), 5);
AssertEqual(Sort(vector<int>{1, 4, 2}), vector<int>{1, 2, 4}); 
```
Если её аргументы будут неравны, хорошо бы увидеть в консоли значения аргументов:
```
Assertion failed: 6 != 5
Assertion failed: [1, 4, 2] != [1, 2, 4] 
```
Для этого нужна функция, которая принимает два значения произвольного типа, сравнивает их и, если они оказались неравны, реагирует на это. Как это сделать в C++, вы уже знаете: создать шаблон функции. Напишем шаблон `AssertEqual`:
```cpp
#include <cstdlib>
#include <iostream>
#include <string>

using namespace std;

template <typename T, typename U>
void AssertEqual(const T& t, const U& u) {
    if (t != u) {
        cout << "Assertion failed: "s << t << " != "s << u << endl;
        // Аварийно завершаем работу программы
        abort();
    }
}

int main() {
    string hello = "hello"s;
    AssertEqual(hello.length(), 5);

    // Эта проверка не сработает
    AssertEqual(2 + 2, 5);
} 
```
Функция-шаблон здесь принимает два параметра некоторых типов `T` и `U`.  Если  значения неравны, она выводит их в консоль и стандартной функцией abort аварийно завершает программу. Функция `abort` подключается заголовочным файлом `<cstdlib>`.

Возникает логичный вопрос: почему шаблонная функция `AssertEqual` принимает аргументы не одного и того же типа, а различных. Ответ: так она удобнее в применении, особенно с целочисленными типами. Мы могли объявить функцию `AssertEqual` иначе:

template <typename T>
void AssertEqual(const T& t, const T& u) {
    if (t != u) {
        cout << "Assertion failed: "s << t << " != "s << u << endl;
        // Аварийно завершаем работу программы
        abort();
    }
} 
Тогда результат метода `length()`, который относится к типу `size_t`, сравнивался бы со значением 5, которое относится к типу `int`. Программа не скомпилировалась бы. Компилятор не может определить, какой тип использовать в данной ситуации:
```
string hello = "hello"s;
AssertEqual(hello.length(), 5); 
```
То есть разные типы `T` и `U `в шаблоне `AssertEqual` оправданы.

Запустим программу и увидим, что вторая проверка не сработала. В консоль вывелись значения сравниваемых аргументов:
```
Assertion failed: 4 != 5 
```
Теперь можем выводить значения аргументов функции `AssertEqual`. Но макрос `assert` сообщал, какая именно проверка сработала, и где искать ошибку. Этой информации мы лишились. Не беда. В следующем уроке мы покажем, как получать подробную диагностику и без `assert`. А пока добавим в `AssertEqual` параметр `hint`. Он содержит строку-подсказку, которая выводится в конце сообщения:

```cpp
template <typename T, typename U>
void AssertEqual(const T& t, const U& u, const string& hint) {
    if (t != u) {
        cout << "Assertion failed: "s << t << " != "s << u << "."s;
        if (!hint.empty()) {
            cout << " Hint: "s << hint;
        }
        cout << endl;
        abort();
    }
} 
```
Теперь в тестах можем использовать подсказки, помогающие диагностировать проблему:
```cpp
int Add(int a, int b) {
    // Ошибка здесь специально, чтобы вы увидели вывод информации об ошибке
    return a + b + 1;
}

int main() {
    // Эта проверка не сработает
    AssertEqual(Add(2, 3), 5, "Add() must add its arguments"s);
} 
```
```
Assertion failed: 6 != 5. Hint: Add() must add its arguments 
```
Посмотрим, как обстоит дело с проверкой булевых значений:
```cpp
int main() {
    // Ошибка в условии допущена намеренно, чтобы продемонстрировать работу AssertEqual
    AssertEqual(greeting.empty(), true, "Greeting must be non-empty"s);
} 
```
Запустим программу и увидим сообщение:
```
Assertion failed: 0 != 1. Hint: Greeting must be non-empty 
```
По умолчанию значения true и false выводятся в поток как единица и ноль. Чтобы заменить их при выводе на более привычные значения, применим boolalpha. Он подключается директивой `#include <iomanip>`. Отменяется такой режим манипулятором noboolalpha.

```cpp
#include <cstdlib>
#include <iomanip>  // Подключаем, чтобы использовать манипулятор boolalpha
#include <iostream>
#include <string>

using namespace std;

template <typename T, typename U>
void AssertEqual(const T& t, const U& u, const string& hint) {
    if (t != u) {
        // Включаем режим вывода значений типа bool в виде true и false
        cout << boolalpha;
        cout << "Assertion failed: "s << t << " != "s << u << "."s;
        if (!hint.empty()) {
            cout << " Hint: "s << hint;
        }
        cout << endl;
        abort();
    }
}

int main() {
    const string greeting = "Hello"s;
    // Ошибка в условии специально, чтобы вы увидели работу AssertEqual
    AssertEqual(greeting.empty(), true, "Greeting must be non-empty"s);
} 
```
Логические выражения стали выводиться так:
```
Assertion failed: false != true. Hint: Greeting must be non-empty
```
Проверять булевые значений функцией `AssertEqual` допустимо. Но это слишком длинный способ по сравнению с оригинальным макросом assert, который позволяет написать просто `assert(!greeting.empty());`. Чтобы устранить многословность, реализована функция `Assert`, проверяющая значение на равенство `true`. Если значение равно `false`, то выводится сообщение `Assertion failed.`, а программа аварийно прекращает работу. Для завершения работы применяется функция `abort()`. При непустом значении параметра `hint` дополнительно будет выводиться текст подсказки.