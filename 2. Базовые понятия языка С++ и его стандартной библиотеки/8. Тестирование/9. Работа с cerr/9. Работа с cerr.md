## Работаем с cerr
Когда юнит-тесты написаны, важно знать, что они выполняются. Для этого в код добавлен вывод сообщения об успешном завершении очередного теста:
```cpp
void TestAddingSynonymsIncreasesTheirCount() {
    ...
    cout << "TestAddingSynonymsIncreasesTheirCount OK"s << endl;
}

void TestAreSynonyms() {
    ...
    cout << "TestAreSynonyms OK"s << endl;
}

void TestSynonyms() {
    TestAddingSynonymsIncreasesTheirCount();
    TestAreSynonyms();
}

int main() {
    TestSynonyms();
    ...
} 
```
Запустим программу и увидим: она вывела названия выполненных тестов и ожидает пользовательский ввод:
```
TestAddingSynonymsIncreasesTheirCount OK
TestAreSynonyms OK 
```
Если отправить программу в таком виде в тестирующую систему, она не пройдёт автоматические проверки. Ведь вывод программы перемешался с выводом тестов, и выходные данные программы не совпадут с ожидаемыми. Можно всякий раз комментировать вывод названий тестов или убрать его совсем. Но есть способ лучше: выводить диагностическую информацию не в стандартный поток вывода, а в стандартный поток ошибок `cerr`.

`cerr` — один из трёх стандартных потоков. Он предназначен для вывода диагностической информации. Работа с `cerr` идентична работе с объектом `cout`.

По умолчанию поток `cerr` связан с выводом в консоль, но во время проверки приложения тестирующая система будет игнорировать вывод в поток ошибок.

Чтобы выводить диагностические сообщения в поток ошибок, нужно использовать не `cout`, а `cerr`. В функциях `AssertEqualImpl` и AssertImpl, а также в тестирующих функциях применяется cerr:
```cpp
template <typename T, typename U>
void AssertEqualImpl(const T& t, const U& u, const string& t_str, const string& u_str, const string& file,
                     const string& func, unsigned line, const string& hint) {
    if (t != u) {
        cerr << boolalpha;
        cerr << file << "("s << line << "): "s << func << ": "s;
        cerr << "ASSERT_EQUAL("s << t_str << ", "s << u_str << ") failed: "s;
        cerr << t << " != "s << u << "."s;
        if (!hint.empty()) {
            cerr << " Hint: "s << hint;
        }
        cerr << endl;
        abort();
    }
} 
```
```cpp
void AssertImpl(bool value, const string& expr_str, const string& file, const string& func, unsigned line,
                const string& hint) {
    if (!value) {
        cerr << file << "("s << line << "): "s << func << ": "s;
        cerr << "Assert("s << expr_str << ") failed."s;
        if (!hint.empty()) {
            cerr << " Hint: "s << hint;
        }
        cerr << endl;
        abort();
    }
} 
```
```cpp
void TestAddingSynonymsIncreasesTheirCount() {
    ...

    cerr << "TestAddingSynonymsIncreasesTheirCount OK"s << endl;
}

void TestAreSynonyms() {
    ...

    cerr << "TestAreSynonyms OK"s << endl;
} 
```
Теперь диагностическая информация будет выводиться в поток ошибок.

Посмотрите на код, который выводит названия успешно пройденных тестов. Сразу бросается в глаза дублирование. Во-первых, в каждом тесте приходится писать однотипный код. Во-вторых, надо следить, чтобы выводимое имя теста совпадало с именем тестирующей функции.

Чтобы исправить эти недостатки, разработана шаблонная функция `RunTestImpl` и использующий её макрос `RUN_TEST`. Они запускают тесты и выводят сообщения об их завершении в стандартный поток ошибок.
```cpp
template <typename TestFunc>
void RunTestImpl(const TestFunc& func, const string& test_name) {
    func();
    cerr << test_name << " OK"s << endl;
}

#define RUN_TEST(func) RunTestImpl(func, #func) 
```