## Тестируем по плану
В прошлом уроке вы изучили принципы тестирования, помогающие отладить решение задач. Применим их на практике.

Допустим, у вас есть задача: написать программу, которая считывает со стандартного входа три строки, разделённые пробелами и состоящие из строчных латинских букв. Программа должна вывести в стандартный вывод лексикографически минимальную из этих трёх строк. Например:
- для строк `milk`, `milkshake`, `month` должна быть выведена строка `milk`;
- для строк `c`, `a`, `b` должна быть выведена строка `a`;
- для строк `fire`, `fog`, `wood` должна быть выведена строка `fire`.

Задачу можно решить так:
```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    string a, b, c;

    cin >> a >> b >> c;

    if (a < b && a < c) {  // Первая строка является минимальной?
        cout << a << endl;
    } else if (b < a && b < c) {  // Вторая строка является минимальной?
        cout << b << endl;
    } else if (c < a && c < b) {  // Третья строка является минимальной?
        cout << c << endl;
    }
} 
```

Программа успешно компилируется. Проверим её работу на примерах, которые даны в условии:

```
milk milkshake month
milk 
```
```
c a b
a 
```
```
fire fog wood
fire 
```

Программа отработала правильно. Казалось бы, можно отправлять решение на проверку.

Сделаем это и увидим, что программа не прошла один из тестов. Значит, в ней есть ошибки, которые не проявили себя на примерах из условия задачи. Чтобы исправить ошибки, составим план тестирования.

По условию задачи, пользователь вводит три строки, а программа проверяет, находится ли минимальная строка на первой, второй или третьей позиции. Возможны следующие варианты:
- Все три строки разные. Среди них минимальная строка может быть на первом, втором или третьем месте. При этом относительное местоположение двух других строк значения не имеет. Например:
  `alpha beta gamma`
  `beta alpha gamma`
  `gamma beta alpha`

- Две из трёх строк одинаковые. Пусть одинаковые строки будут являться минимальными. В противном случае входные данные подпадали бы под предыдущий класс эквивалентности. Примеры входных данных:
  `alpha beta alpha`
  `beta alpha alpha`
  `alpha alpha beta`

- Все три строки одинаковые. Например:
  `alpha alpha alpha`
  
Таким образом, для этой программы у нас семь классов эквивалентности — то есть семь наборов входных данных. План тестирования готов.

Теперь проверим работу программы на каждом варианте входных данных. Когда все строки разные, она работает правильно:
```
alpha beta gamma
alpha 
```
```
beta alpha gamma
alpha 
```
```
gamma beta alpha
alpha 
```
Проверим вариант, где две одинаковые строки минимальны:
```
alpha beta alpha 
```
Странно, программа не вывела ничего, хотя из трёх строк одна точно должна быть ответом. Взглянем на проверяемые условия:
```cpp
  if (a < b && a < c) {  // Первая строка минимальная?
      cout << a << endl;
  } else if (b < a && b < c) {  // Вторая строка минимальная?
      cout << b << endl;
  } else if (c < a && c < b) {  // Третья строка минимальная?
      cout << c << endl;
  } 
  ```
Первое, что бросается в глаза, — избыточность условия вывода третьей строки. Ведь если ни первая, ни вторая строка не будут ответами, значит, ответ — третья. Уберём последнюю проверку:
```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    string a, b, c;

    cin >> a >> b >> c;

    if (a < b && a < c) {  // Первая строка минимальная?
        cout << a << endl;
    } else if (b < a && b < c) {  // Вторая строка минимальная?
        cout << b << endl;
    } else {  // Третья строка точно минимальная
        cout << c << endl;
    }
} 
```
Проверим, как программа ведёт себя на входных данных, с которыми тест падал:
```
alpha beta alpha
alpha 
```
Отлично, она стала работать правильно там, где не работала. Но считать программу готовой нельзя, ведь мы проверили её не на всех запланированных тестах. Исправляя одну ошибку, мы могли внести новую или пропустить другие. Поэтому важно выполнить все тесты.

Проверим работу программы на предыдущих тестах, чтобы убедиться: то, что работало, мы правками не сломали. Затем продолжим тестирование по плану.

Тесты с тремя разными строками:
```
alpha beta gamma
alpha 
```
```
beta alpha gamma
alpha 
```
```
gamma beta alpha
alpha 
```

Тесты с двумя одинаковыми строками:
```
alpha beta alpha
alpha 
```
```
beta alpha alpha
alpha 
```
```
alpha alpha beta
beta 
```

И снова неожиданность. Программа вывела строку `beta`, хотя в лексикографическом порядке строка `alpha` идёт до `beta`. Проанализируем, как выполняется код на данных `alpha alpha beta`:

```cpp
  if (a < b && a < c) {  // Первая строка минимальная?
      cout << a << endl;
  } else if (b < a && b < c) {  // Вторая строка минимальная?
      cout << b << endl;
  } else {  // Третья строка точно минимальная
      cout << c << endl;
  } 
```

На таком входном наборе в переменной `a` хранится значение `“alpha”`, в переменной `b` — “alpha”, а в переменной `c` — “beta”, и ожидается, что будет выведено значение переменной a либо переменной `b`. Но `a` и `b` содержат одно и то же значение. Поэтому из-за строгих сравнений `a < b` и `b < a` ни одно из первых двух условий не выполняется, а выполняется третья ветка, выводящая значение переменной `c`. Чтобы исправить ошибку, используем нестрогие сравнения — при равенстве строк неважно, какую из них выводить:

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    string a, b, c;

    cin >> a >> b >> c;

    if (a <= b && a <= c) {  // Первая строка минимальная?
        cout << a << endl;
    } else if (b <= a && b <= c) {  // Вторая строка минимальная?
        cout << b << endl;
    } else {
        cout << c << endl;
    }
} 
```

Повторим провалившийся тест и убедимся, что новая версия кода решает выявленную проблему:
```
alpha alpha beta
alpha 
```
Ура! Исправили уже две ошибки. Теперь посмотрим, как программа ведёт себя на последнем тесте с тремя одинаковыми строками:
```
alpha alpha alpha
alpha 
```
Исправляя последнюю ошибку, мы могли внести в программу дефект. Перепроверим её работу на всех тестах плана тестирования:
```
alpha beta gamma
alpha 
```
```
beta alpha gamma
alpha 
```
```
gamma beta alpha
alpha 
```
```
alpha beta alpha
alpha 
```
```
beta alpha alpha
alpha 
```
Всё в порядке. Теперь программу можно считать завершённой и смело отправлять её на проверку. Так происходит ручное тестирование.