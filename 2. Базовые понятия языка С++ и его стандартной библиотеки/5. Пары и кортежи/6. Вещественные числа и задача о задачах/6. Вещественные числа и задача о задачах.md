## Вещественные числа и задача о задачах

Документы в выдаче вашей поисковой системы ранжируются по релевантности. Вы узнали, как сортировать по нескольким параметрам и можете добавить второй уровень сортировки — например, по рейтингу.

Релевантность измеряется нецелыми вещественными числами, которые мы храним в переменной типа `double`. Как вы увидите далее, это создаёт дополнительные сложности. Память, занимаемая переменной, не бесконечна, а значит, переменная `double` может представить лишь некоторое конечное множество вещественных чисел. При выполнении арифметических операций не всегда получается число, представимое в типе `double`. В этом случае процессор вынужден округлять, теряя точность вычислений. Результат получается приближённый, и операция `==` не всегда имеет смысл:
```cpp
#include <iostream>
using namespace std;
int main() {
    double x1 = 0;
    for (int i = 0; i < 3; ++i) {
        x1 += 1.0 / 5;
    }
    double x2 = 0;
    for (int i = 0; i < 9; ++i) {
        x2 += 1.0 / 15;
    }
    cout << "x1 = "s << x1 << endl;
    // выводит x1 = 0.6
    cout << "x2 = "s << x2 << endl;
    // выводит x2 = 0.6
    cout << "(x1 == x2) = "s << (x1 == x2) << endl;
    // выводит (x1 == x2) = 0
} 
```
Оказывается, 0.6 ≠ 0.6! Разберёмся почему. Если перед выводом увеличить количество отображаемых значащих цифр до 20 командой `cout.precision(20);`, увидим, что `x1` = 0.60000000000000008882, а `x2` = 0.5999999999999999778. То есть результат верный.

Чтобы избежать подобных сюрпризов, не сравнивайте вещественные числа на равенство: не используйте ни `==,` ни `!=.` Если сделать это всё-таки нужно, вместо применения `==` вычислите разность чисел и проверьте, укладывается ли она в погрешность:
```cpp
#include <cmath>
#include <iostream>
using namespace std;
int main() {
    double x1 = 0;
    for (int i = 0; i < 3; ++i) {
        x1 += 1.0 / 5;
    }
    double x2 = 0;
    for (int i = 0; i < 9; ++i) {
        x2 += 1.0 / 15;
    }
    cout.precision(20);
    const double EPSILON = 1e-6;  // 10 в степени -6
    cout << "x1 = "s << x1 << endl;
    // выводит x1 = 0.6
    cout << "x2 = "s << x2 << endl;
    // выводит x2 = 0.6
    cout << "(x1 == x2) = "s << (x1 == x2) << endl;
    // выводит (x1 == x2) = 0

    cout << "(x1 ≈ x2) = "s << (std::abs(x1 - x2) < EPSILON) << endl;
    // выводит (x1 ≈ x2) = 1
} 
```
Функция `std::abs` из библиотеки `<cmath>` вычисляет модуль — абсолютную величину — числа. В данном случае мы считаем, что `x1` ≈ `x2`, если `x2`  находится между `x1` − 10⁻⁶ и `x1` + 10⁻⁶.

В некоторых задачах числа могут быть очень большими или маленькими по абсолютной величине. В этом случае лучше использовать не абсолютную погрешность, а относительную: перед сравнением с `EPSILON` делить разность на большее по модулю число.