## Создание кортежей
Вы научились сравнивать структуры, применяя кортеж. Познакомимся с ним поближе. 
При создании кортежа объекты копируются в него:
```cpp
string name = "Василий"s;
const tuple animal_info(name, 5, 4.1);
name = "Вася"s;  // в animal_info остался Василий 
```
У этого есть недостаток. Когда создаём кортеж для немедленного сравнения с другим кортежем, тяжёлые объекты могут скопироваться зря. Так произойдёт и с сортировкой `AnimalObservation`:

```cpp
struct AnimalObservation {
        string name;
        int days_ago;
        int health_level;
        auto MakeKey() const {
        return tuple(days_ago, health_level, name);
                // потенциально тяжёлая строка name копируется в создаваемый кортеж
    }
};
// ...
sort(observations.begin(), observations.end(),
     [](const AnimalObservation& lhs, const AnimalObservation& rhs) {
             return lhs.MakeKey() < rhs.MakeKey();
     }); 
Чтобы избавиться от лишнего копирования, применим функцию tie из библиотеки <tuple>:

auto MakeKey() const {
    return tie(days_ago, health_level, name);
} 
```
Разберёмся, в чём разница. Специально вызовем ошибку компиляции и посмотрим на тип, возвращаемый сейчас методом `MakeKey`:

```cpp
+AnimalObservation{}.MakeKey();  // создали структуру AnimalObservation,
                                 // не инициализируя поля, сразу вызвали MakeKey(),
                                                                 // а к результату применили оператор + 
```
Бо́льшую часть текста ошибки занимает описание типа, к которому не удалось применить оператор +:
```
no match for 'operator+'
(operand type is 'std::tuple<const int&, const int&, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>') 
```
Функция `tie` вернула кортеж, хранящий не сами объекты, а ссылки на них: `const int&`, const `int&` и `const string&`. Тип `string` записан своим оригинальным именем с применением `basic_string`. Ссылки при этом оказались константными благодаря константности самого метода `MakeKey`.

Создание кортежа из ссылок не требует копировать объекты. Однако этот подход неуниверсален, поскольку создать ссылку на временный объект нельзя:

```cpp
struct Document {
    int id;
    Status status;
    double relevance;
    int rating;
    
    auto MakeKey() const {
        return tie(status, -rating, -relevance);
    }
};
// ошибка компиляции: cannot bind non-const lvalue reference of type 'int&'
// to an rvalue of type 'int' 
```
Ошибка компиляции буквально переводится так: нельзя привязать ссылку `int&` к временному объекту типа `int`. Дело в том, что объекты `-rating` и `-relevance `создались внутри метода. Они уничтожаются сразу по окончании выражения, где были созданы. Ссылку на такие временные объекты создать нельзя.

Если создаёте кортеж и из ссылок, и из самих значений, укажите типы явно:
```cpp
struct AnimalObservation {
    string name;
    int days_ago;
    int health_level;
    // в заголовке метода теперь указан полный тип
      tuple<int, int, const string&> MakeKey() const {
        // создаём и сразу возвращаем объект:
        // явно указывать его тип не нужно, достаточно указать аргументы конструктора
        // в фигурных скобках
        return {days_ago, -health_level, name};
    }
}; 
```