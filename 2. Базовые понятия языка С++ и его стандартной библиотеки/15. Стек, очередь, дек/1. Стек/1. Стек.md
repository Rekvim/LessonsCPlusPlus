## Стек
Вы уже видели, как работает LIFO в ситуации с тележкой в магазине. Другим примером может быть магазин с патронами. Первым из ствола вылетит тот патрон, который вставлен последним. Более близкое к программированию применение стека — знакомый вам стек функций. Он организован точно так же, как магазин с патронами.

Рассмотрим пример:
```cpp
void Bar() {
    int x = 2;
}

void Foo() {
    int x = 1;
    Bar();
}

int main() {
    int x = 0;
    Foo();
} 
```
1. Всё начинается с функции main. Она добавляется в стек.
2. main вызывает функцию Foo. Все локальные переменные функции Foo оказываются сверху функции main. При этом локальные переменные функции main не доступны из стека функции Foo. Можно не бояться, что у них совпадают имена.
3. Функция Foo вызывает функцию Bar. Происходит то же самое, что на прошлом шаге, только теперь на верх стека добавляется функция Bar.
4. Предположим, Bar закончила работу. Теперь её можно удалить из стека. Сверху теперь снова оказалась функция Foo и все её локальные переменные на месте.
5. Теперь функция Foo тоже закончила работу. Сверху стека оказалась функция main, с которой всё начиналось.
   
6. Функция main закончила своё выполнение. Стек пуст. Это значит, что программа завершила работу, а возвращаемое значение функции main и есть возвращаемое значение всей программы.
   

Попробуйте так же нарисовать стек для рекурсивной функции.

Из всех примеров вытекает, какими должны быть методы класса `Stack`:
- Вставка элемента в стек — `Push`;
- Удаление элемента из стека — `Pop`;
- Получение значения вершины стека — `Peek`;
- Размер стека — `Size`;
- Проверка на пустоту — `IsEmpty`. Проверить контейнер на пустоту можно и через функцию `Size`. Но она будет долго пересчитывать все элементы. А `IsEmpty` позволяет без пересчёта узнать, пуст контейнер или нет.