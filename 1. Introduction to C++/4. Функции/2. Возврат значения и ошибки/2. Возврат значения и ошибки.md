## Возврат значения и ошибки

Чтобы вернуть результат выполнения функции, используют ключевое слово `return`. Тип возвращаемого значения указывают перед именем функции в момент её создания. Результат вернётся в место вызова функции. 

Например, функция `Concatenate` соединяет две строки пробелом и возвращает результат — строку:
```cpp
#include <iostream>
#include <string>

using namespace std;

string Concatenate(string left, string right) {
    return left + " "s + right;
}

int main() {
    string str1 = "In C++"s;
    string str2 = "we trust"s;
    cout << Concatenate(str1, str2) << endl;
} 
```
Этот код вычисляет результат работы функции `Concatenate` от аргументов `str1` и `str2`, а затем подставляет его в место вызова. Программа выведет:

```
In C++ we trust 
```

`return` завершает выполнение функции. Допустим, вы ищете первое чётное число в векторе целых чисел:
```cpp
#include <iostream>
#include <vector>

using namespace std;

bool CheckForEven(vector<int> some_vector) {
    for (int i : some_vector) {
            if (i % 2 == 0) {
                return true;
            }
        cout << i << " нечётное, ищу дальше"s << endl;
    }
    return false;
}

int main() {
    vector<int> numbers = {1, 3, 7, 8, 9, 10};
    if (CheckForEven(numbers)) {
        cout << "Ага! У нас тут чётное число!"s << endl;
    } else {
        cout << "Жаль, но у нас нет чётных чисел!"s << endl;
    }
} 
```
Цикл по вектору `numbers` дойдёт до цифры восемь, выполнение функции прервётся. Больше ничего напечатано не будет:
```
1 нечётное, ищу дальше
3 нечётное, ищу дальше
7 нечётное, ищу дальше
Ага! У нас тут чётное число! 
```
При работе с функциями бывает несколько типичных ошибок. 

1. Забыли вернуть значение из функции:
```cpp
#include <iostream>

using namespace std;

int AddFive(int x) {
    x += 5;
}

int main() {
    cout << AddFive(5) << endl;
} 
```
Компилятор молчать не станет:
```
test_func.cpp: In function ‘int AddFive(int)’:
test_func.cpp:7:1: error: no return statement in function returning non-void [-Werror=return-type]
 }
 ^
cc1plus: all warnings being treated as errors
```
Но есть исключение. Функция `int main()` возвращает ноль, даже если не написать это явно. Возврат нулевого значения из `main()` — корректное завершение работы программы, а ненулевого — некорректное. Для остальных функций, которые возвращают значение, отсутствие `return` — ошибка.

2. Неправильный тип или количество аргументов. Вызовете `AddFive(5, 6)`, и компилятор будет недоволен:
```
test_func.cpp: In function ‘int main()’:
test_func.cpp:9:27: error: too many arguments to function ‘int AddFive(int)’
  cout << AddFive(5, 6) << endl;
                           ^
test_func.cpp:3:5: note: declared here
 int AddFive(int x) {
     ^~~~~~~
```
Вызов AddFive("some text") спровоцирует такое сообщение:
```
test_func.cpp: In function ‘int main()’:
test_func.cpp:9:28: error: invalid conversion from ‘const char*’ to ‘int’ [-fpermissive]
  cout << AddFive("some text") << endl;
                            ^
test_func.cpp:3:5: note:   initializing argument 1 of ‘int AddFive(int)’
 int AddFive(int x) {
     ^~~~~~~
```
В случае с  `AddFive("some text")` компилятор не может найти преобразование типа переменной, которое подходит типу входного параметра функции. Преобразование типов будет рассмотрено позже в курсе.

3. Забыли объявить функцию, объявили её после применения или опечатались в названии:
```cpp
#include <iostream>

using namespace std;

int Addfive(int x) {
    x += 5;
    return x;
}

int main() {
    cout << AddFive(5) << endl; // Функция с этим названием объявлена ниже
    cout << Addive(5) << endl; // А в вызове этой функции опечатка в названии
}

int AddFive(int x) {
    x += 5;
} 
```
Компилятор не увидит объявление вызываемой функции и укажет номер строки, где возникла проблема:
```cpp
test_func.cpp: In function ‘int main()’:
test_func.cpp:11:13: error: ‘AddFive’ was not declared in this scope
     cout << AddFive(5) << endl;
             ^~~~~~~
test_func.cpp:11:13: note: suggested alternative: ‘Addfive’
     cout << AddFive(5) << endl;
             ^~~~~~~
             Addfive
test_func.cpp:12:13: error: ‘Addive’ was not declared in this scope
     cout << Addive(5) << endl;
             ^~~~~~
test_func.cpp:12:13: note: suggested alternative: ‘Addfive’
     cout << Addive(5) << endl;
             ^~~~~~
             Addfive 
```
4. Недостижимый код. Речь не о недостижимом качестве:
```cpp
#include <iostream>

using namespace std;

int ProcessValue(int value, int threshold) {
    if (value > threshold)
        value = value / 2;
        return value; // код далее в этой функции недостижим для исполнения
    if (value < threshold) 
        value = value * 3;
        return value;
}

int main() {
    int value, threshold;
    cin >> value >> threshold;
    cout << endl << ProcessValue(value, threshold) << endl;
} 
```
Автор кода забыл фигурные скобки для `if`-блока. Поэтому выполнение этой функции всегда заканчивается на первом `return`. Компилятор указывает на проблему:
```cpp
test_func.cpp: In function ‘int ProcessValue(int, int)’:
test_func.cpp:6:5: error: this ‘if’ clause does not guard... [-Werror=misleading-indentation]
     if (value > threshold)
     ^~
test_func.cpp:8:9: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the ‘if’
         return value; // код далее в этой функции недостижим для исполнения
         ^~~~~~
test_func.cpp:9:5: error: this ‘if’ clause does not guard... [-Werror=misleading-indentation]
     if (value < threshold)
     ^~
test_func.cpp:11:9: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the ‘if’
         return value;
         ^~~~~~
cc1plus: all warnings being treated as errors 
```
Такая ошибка может возникнуть и во время рефакторинга. Чтобы её избежать, нужна внимательность — крайне полезное качество при разработке на С++.