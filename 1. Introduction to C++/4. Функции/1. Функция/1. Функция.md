## Функция, вас вызывают!

Часто в программном коде повторяются одни и те же наборы выражений. Это увеличивает его размер и затрудняет чтение. Поэтому вместо повторяющихся выражений используют функции.

Функция — фрагмент кода, который вызывают из другого места программы. Каждому такому фрагменту присваивают уникальное имя — название функции. В отличие от методов в Java, функции в С++ не привязаны к конкретному объекту.

С++ строго следует системе типов, поэтому тип возвращаемого значения указывают всегда — даже если функция ничего не возвращает. Ничего не возвращающие функции вернут «ничего».

Посмотрите на функцию логирования. Она принимает целое число (id пользователя) и строку (поисковый запрос) и выводит отладочную строку вида «запрос сделан пользователем с таким id»:
```cpp
#include <iostream>

using namespace std;

void PrintLogMessage(int user_id, string query) {
    cout << "Query " << query << " was done by the user with id = " << user_id << endl;
}

int main() {
    PrintLogMessage(237, "GET_STATUS");
    return 0;
}
```
Каждое слово в названии функции принято писать с большой буквы. Здесь название начинается с глагола `print` и отвечает на вопрос «что сделать?» — это позволяет отличить функции от типов при чтении кода.

Функция `PrintLogMessage` ничего не возвращает. Поэтому перед названием написано ключевое слово void. Из такого правила есть исключение — о нём в следующем уроке.

После названия функции дан список входных параметров с указанием их типов. Эти параметры называются аргументами. После аргументов следует тело функции — то, что она «делает»:
```cpp
void <имя функции>(<тип1> <аргумент1>, <тип2> <аргумент2>,) {
    <тело функции>
} 
```
Код выведет:
```
Query GET_STATUS was done by the user with id = 237 
```
В первой теме курса вы создали переменную-строку `string hello = "Hello, friend"`, чтобы обращаться к ней из других мест программы. А здесь сохраняете фрагмент кода в функции, чтобы применять его, где захотите.

Функции позволяют упростить модель очереди беспокойных людей:
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

// ... тела функций ...

int main() {
    int q;
    cin >> q;
    vector<bool> is_nervous;

    for (int i = 0; i < q; ++i) {
        string operation_code;
        cin >> operation_code;

        if (operation_code == "WORRY_COUNT") {
            PrintWorriedCount(is_nervous);
        } else if (operation_code == "WORRY" || operation_code == "QUIET") {
            int person_index;
            cin >> person_index;
            // выражение (operation_code == "WORRY") имеет тип bool и равно true для запроса WORRY,
            // поэтому is_nervous[person_index] станет равным false или true
            // в зависимости от operation_code
            ChangePersonStatus(is_nervous, person_index, (operation_code == "WORRY"));
        } else if (operation_code == "COME") {
            int person_count;
            cin >> person_count;
            ChangeQueueSize(is_nervous, person_count);
        }
    }
} 
```
Теперь из `main()` видно, что программа проверяет несколько условий и вызывает нужную функцию для каждого случая. Вся логика обработки запросов перенесена внутрь функций. Объём кода остался прежним, но читать его проще.

Методы вектора, такие как `resize()`, — разновидность функций. Их можно вызывать для конкретного вектора. Тела этих функций спрятаны за волшебными словами `#include <vector>` и входят в стандартную библиотеку С++.

При вызове функции к её имени всегда добавляют круглые скобки. В скобках перечисляют значения параметров. Например, если хотите вывести результат сложения двух целых чисел, нужна функция `void PrintSum(int x, int y)`, способная их принять:
```cpp
#include <iostream>
#include <vector>

using namespace std;

void PrintSum(int x, int y) {
    cout << x + y << endl;
}

int main() {
    vector<int> numbers = {1, 2, 3, 4, 5};
    int sum = 0;
    for (int i : numbers) {
        PrintSum(i, sum);
        sum += i;
    }
    return 0;
}
```
Здесь вы проходите по вектору целых чисел и накапливаете их сумму, каждый раз предварительно печатая её:
```
1
3
6
10
15 
```