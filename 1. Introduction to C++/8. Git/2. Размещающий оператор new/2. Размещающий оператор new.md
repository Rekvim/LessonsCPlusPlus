## Размещающий оператор new

В прошлом уроке вы узнали, что настоящий класс `vector` конструирует свои объекты в сырой памяти только при необходимости. Под сырой памятью здесь понимается область памяти, которой владеет `vector` и в которой пока не создано ни одного объекта.

Ранее вы изучали способы работы с памятью, при которых создание объекта неотделимо от выделения памяти для его хранения.

- Объявление локальной переменной внутри функции автоматически выделяет память для её хранения. Выход из блока, где она объявлена, автоматически вызывал деструктор объекта и освобождал занимаемую им память.

- Объявление глобальной переменной выделяет под неё память в момент запуска программы. При завершении программы автоматически вызывается деструктор объекта, а память возвращается операционной системе.

- Операторы `new` и `new[]` выделяют память в куче и конструируют объекты и массивы. Соответствующие им операторы `delete` и `delete[]` вызывают деструкторы объектов и возвращают память обратно в кучу.

В этом уроке вы увидите, как выделять сырую память в куче и на стеке и вручную создавать и удалять в ней объекты. А ещё создадите упрощённый аналог класса `optional`.

Чтобы показать, как создаётся объект, используем класс `Cat`. Он оповещает о своём конструировании и разрушении:
```cpp
#include <iostream>
#include <memory>
#include <new>
#include <string>

using namespace std;

class Cat {
public:
    Cat(string name, int age)
        : name_(move(name))
        , age_(age)  //
    {
        cout << "Hello from " << name_ << endl;
    }

    ~Cat() {
        cout << "Goodbye from "sv << name_ << endl;
    }

    void SayHello() const {
        cout << "Meow, my name is "sv << name_ << ". I'm "sv << age_ << " year old."sv << endl;
    }

private:
    string name_;
    int age_;
};
```
Убедимся, что если создать кота в автоматической памяти, он будет справляться с обязанностями:
```cpp
int main() {
    Cat cat("Tom"s, 2);
    cat.SayHello();
} 
```
```
Hello from Tom
Meow, my name is Tom. I'm 2 year old.
Goodbye from Tom 
```
Кот работает корректно:
```cpp
int main() {
    Cat* cat = new Cat("Leo"s, 3);
    cat->SayHello();
    delete cat;
}
```
```
Hello from Leo
Meow, my name is Leo. I'm 3 year old.
Goodbye from Leo
```
Чтобы не забыть вызвать `delete` для удаления объекта, используйте умный указатель `unique_ptr`:
```cpp
int main() {
    auto cat = make_unique<Cat>("Felix"s, 4);
    cat->SayHello();
}
```
```
Hello from Felix
Meow, my name is Felix. I'm 4 year old.
Goodbye from Felix
```

Это были знакомые вам способы создания объектов. В них выделение памяти и конструирование объекта выполнялись транзакционно: когда памяти достаточно и конструктор завершился успешно, вы получаете объект, пригодный для использования. Если конструктор выбросил исключение, происходит откат изменений. В него входит вызов деструкторов полей объекта, которые успели сконструироваться, и освобождение памяти.

В C++ есть способ вручную сконструировать объект в ранее выделенной сырой области памяти — размещающий оператор `new`. Его синтаксис:
```
new (адрес) Класс(параметры конструктора)
```
Он вызывает конструктор класса `Класс` по адресу `адрес` и передаёт ему `параметры конструктора`. `Адрес` должен иметь выравнивание блока памяти, нужное для типа Класс. Размещающий оператор `new` возвращает указатель типа `Класс*` на сконструированный объект.

Как только созданный так объект становится не нужен, его надо удалить. Для этого вызывают деструктор:
```cpp
Obj* obj = ...;
...
obj->~Obj();
```

Когда создаёте объекты размещающим оператором `new`, всегда используйте явный вызов деструктора.

В следующем примере в области стека выделяется массив размера, достаточного для хранения объекта типа `Cat`. Затем размещающий оператор `new` конструирует в этом массиве экземпляр класса `Cat`. Перед выходом из `main` сконструированный вручную объект нужно разрушить, явно вызвав его деструктор:
```cpp
int main() {
    alignas(Cat) char buf[sizeof(Cat)];
    Cat* cat = new (&buf[0]) Cat("Luna"s, 1);
    cat->SayHello();
    cat->~Cat();
}
```
Спецификатор alignas сообщает компилятору, что массив buf должен быть размещён в памяти с выравниванием, нужным типу Cat. Иначе возможно неопределённое поведение.
Запустим программу и увидим, что она работает идентично предыдущей:
```
Hello from Luna
Meow, my name is Luna. I'm 1 year old.
Good bye from Luna 
```
Можно ли обернуть в `unique_ptr` указатель, который получен размещающим оператором `new`, как показано во фрагменте? Выберите один ответ.
```cpp
int main() {
    alignas(Cat) char buf[sizeof(Cat)];

    unique_ptr<Cat> cat(new (&buf[0]) Cat("Luna"s, 1));
    cat->SayHello();
} 
```

> Нет. Объект типа Cat создан размещающим оператором new. Чтобы удалить Cat, нужно использовать явный вызов деструктора.

Буфер, нужный для создания объекта, необязательно должен размещаться в области стека. Его можно выделить и динамически. Чтобы выделить сырой массив данных в куче, вызывают функцию [operator new](https://en.cppreference.com/w/cpp/memory/new/operator_new). У неё есть несколько перегрузок. В нашем случае полезна эта:
```cpp
void* operator new(std::size_t size);
```
Данную глобальную функцию может автоматически переопределить программист. Она выделяет `size` байт в динамической памяти и возвращает указатель на эту выделенную область. Функция возвращает указатель `void*`. Указатели такого типа могут ссылаться на данные произвольного типа.

Эта функция `operator new` выделяет память в куче по адресу, выровненному по умолчанию. В документации есть и другие её версии. С ними легко управлять выравниванием данных в динамической памяти.

Для возврата сырой памяти обратно в кучу служит парная функция [operator delete](https://en.cppreference.com/w/cpp/memory/new/operator_delete). Версия функции, которую мы будем использовать, выглядит так:
```cpp
void operator delete(void* ptr) noexcept;
```
Выделим сырую память, используя `operator new` перед конструированием объекта. После вызова деструктора удалим объект функцией `operator delete`:
```cpp
int main() {
    void* buf = operator new (sizeof(Cat));
    Cat* cat = new (buf) Cat("Murka"s, 4);
    cat->SayHello();
    cat->~Cat();
    operator delete (buf);
}
```

Убедимся в работоспособности программы:
```
Hello from Murka
Meow, my name is Murka. I'm 4 year old.
Good bye from Murka 
```
Именно этот подход с размещающим оператором `new` пригодится при разработке новой версии вектора. Но для начала решите задачу полегче: напишите упрощённую версию `std::optional`.