## Логические операции «и», «или», «не»

Сравнение — простая логическая операция. В этом уроке речь пойдёт о более сложных. 

- Конъюнкция — логическая операция «и». Оформляется двумя амперсандами &&. Выражение a && b возвращает true, если истинно и a, и b. В противном случае вернёт `false`.

- Дизъюнкция — логическая операция «или». Оформляется двумя вертикальными чертами ||. Выражение a || b возвращает true, если истинно хотя бы одно из a и b. В противном случае вернёт `false`.

- Отрицание — логическая операция «не». Оформляется восклицательным знаком. Выражение `!a` возвращает `false`, если `a` истинно. В противном случае вернёт `true`.

Используя эти логические операции, вы можете компактно записывать условные выражения. Например, код, проверяющий, находится ли одно число между двумя другими, можно записать так:

```cpp
int n, lower_bound, upper_bound;
...
if (lower_bound < n && n < upper_bound) {
    // Этот код выполнится только когда n будет строго между lower_bound И upper_bound
    cout << n << " is between "s << lower_bound << " and "s << upper_bound;
} 
```
Без использования логических выражений пришлось бы использовать вложенную инструкцию `if`:
```cpp
int n, lower_bound, upper_bound;
...
if (lower_bound < n) {
    if (n < upper_bound) {
        cout << n << " is between "s << lower_bound << " and "s << upper_bound;
    }
} 
```
Результаты работы логических операций можно представить в виде таблицы истинности. В таблице видно, что если `a=true`, а `b=false`, то `a && b` будет `false`.

#### Таблица истинности оператора &&

|a  | b |a && b|
|:-:|:-:|:-:|
|false|false|false|
|false|true|false|
|true|false|false|
|true|true|true|

Действие оператора `&&` напоминает умножение. При умножении двух чисел ненулевой результат получается, когда оба числа не равны нулю. А здесь результат операции имеет значение «истина», когда оба аргумента имеют значение «истина». Поэтому конъюнкцию ещё называют логическим умножением.

|a  | b |a \|\| b|
|:-:|:-:|:-:|
|false|false|false|
|false|true|true|
|true|false|true|
|true|true|true|

Действие оператора `||` напоминает сложение. При сложении неотрицательных чисел нулевая сумма получается, только когда оба числа равны нулю. Здесь результат имеет значение «ложь», только когда оба аргумента имеют значение «ложь». Поэтому дизъюнкцию называют логическим сложением.

#### Таблица истинности оператора !

|a	|!a|
|:-:|:-:|
|false|	true|
|true|false|

Эта программа должна помочь Зои понять, нужно ли ей заходить в дом перед ней:

```cpp
string house_color; // цвет дома
int num_floors;     // количество этажей в доме
...
if ((house_color == "green"s && num_floors == 2) || num_floors == 3) {
    cout << "Enter the "s << house_color << " house with "s
         << num_floors << " floors"s << endl;
} 
```
Выберите комбинации цвета и этажности домов, у жильцов которых Зои стоит спросить о своём питомце.

> Трёхэтажный красный дом

> Трёхэтажный зелёный дом

> Двухэтажный зелёный дом

Дом должен быть либо зелёным двухэтажным, о чём нам говорит условие: `(house_color == "green"s && num_floors == 2)`, либо трёхэтажным произвольного цвета. Под эти требования подходят все дома, кроме двухэтажного красного.

У операций `&&` и `||` есть особенность: они вычисляются слева направо. Когда по значению левого аргумента можно определить значение всего выражения, правый аргумент не вычисляется. Это не только уменьшает количество вычислений, но и позволяет перенести в правую часть этих операций код, зависящий от условия в левой части. Например, так проверяется, что строка `s` непустая, и её первый символ — `'z'`:

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s;
    getline(cin, s);
    if (!s.empty() && s[0] == 'z') {
        cout << s << endl;
    }
}
```
Поместив проверку на непустоту `s` в левой части оператора `&&`, можно безопасно проверить значение `s[0]` в правой части. Выражение `s[0] == 'z'` будет вычислено, только когда `s` — непустая строка. Ведь если значение хотя бы одного аргумента операции `&& — false`, то и значение всей операции — `false`.

А здесь проверяется другое — строка `s` пустая или первый символ равен `'k'`:

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s;
    getline(cin, s);
    if (s.empty() || s[0] == 'k') {
        cout << s << endl;
    }
} 
```
В этой программе доступ к `s[0]` также находится под защитой оператора `||`.

(true || x < 5) == true. Истина! Слева от || стоит true, потому выражение справа от || не играет роли.


Когда в одном выражении встречаются операции `&&`, `||` и `!`, они вычисляются в соответствии с их приоритетом:
- сначала `!`;
- потом `&&`;
- в конце — `||`.

Легко запомнить: сначала вычисляется `&&` — логическое умножение, а потом `||` — логическое сложение.

Чему равно значение этого выражения?
```cpp
(false || true && true || false) 
```

> `true`


Сначала будет вычислено выражение `true && true`, что даст значение `true`. Затем будет вычислено `false || true` и даст значение `true`. В конце `true || false` даст значение `true`. 

В сложных логических выражениях явно расставляйте скобки, чтобы облегчить чтение кода. Так, выражение `a || (b && c) || d` воспринимается легче, чем `a || b && c || d`.