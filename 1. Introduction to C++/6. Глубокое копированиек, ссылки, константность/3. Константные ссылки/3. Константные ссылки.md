## Константные ссылки

Ссылки позволяют не только избавляться от лишних копирований, но и менять внутри функции исходные объекты. Это не всегда полезно.

Одна из концепций С++ — отловить большую часть ошибок на этапе компиляции, чтобы выполнение программы было максимально эффективным. Найти ошибки, которые связаны с непреднамеренным изменением объекта, позволяет константность. Она делает объект или ссылку неизменяемыми и защищает код от вторжения. Такая возможность есть не во всех языках программирования. Константные ссылки используют, чтобы:

- передать тяжёлый объект в функцию, не копируя и не позволяя менять его внутри функции;
- перебрать такие объекты в цикле `for` с теми же условиями.

Ссылки `const string&` или `const vector<int>&` — константные. 

Неконстантные ссылки вводят разработчиков в заблуждение. Взять хотя бы последнюю версию функции, которая разбивает строки на слова:
```cpp
vector<string> SplitIntoWords(string& text) {
    vector<string> words;
    string word;
    for (char c : text) {
        if (c == ' ') {
            if (!word.empty()) {
                words.push_back(word);
                word.clear();
            }
        } else {
            word += c;
        }
    }
    if (!word.empty()) {
        words.push_back(word);
    }

    return words;
}
```
Разработчик не будет спешить использовать её в своей программе. Он прочтёт заголовок и узнает, что функция:
1. называется «разбить на слова»;
2. возвращает вектор строк — похоже, те самые слова;
3. принимает ссылку на строку.

Несчастный разработчик сделает вывод, что функция не только возвращает набор слов, но и зачем-то меняет исходную строку. Если строка, которую нужно разбить на слова, ещё нужна разработчику в неизменном виде, он может перестраховаться и передать функции её копию:

```cpp
string query;
...
string query_copy = query;
// Разбиваем на слова не саму строку query, а её копию, чтобы защитить query от изменения
vector<string> words = SplitIntoWords(query_copy);
// ... последующий код может использовать строку query 
```
То, что функция принимает строку по ссылке, чтобы избавить программу от неявного копирования строки, само стало причиной копирования. Программист решил, что доверять ценные данные функции, которая может их изменить, не лучшая идея, и передал функции копию строки.

Тут на помощь приходят константные ссылки. Как и обычные ссылки, они лишь создают новое имя, по которому можно обратиться к существующему объекту. Вдобавок они не разрешают использовать это имя для изменения объекта:
```cpp
int main() {
    string pet_name = "Leo"s;
    
    const string& const_pet_name_ref = pet_name;
    // Имя const_pet_name_ref можно использовать для чтения строки
    cout << const_pet_name_ref << "'s name size is "s << const_pet_name_ref.size() << endl;
    // Выведет Leo's name size is 3    

    // Следующая строка не скомпилируется, так как имя const_pet_name_ref
    // нельзя использовать для модификации объекта
    // const_pet_name_ref += "pold"s;

    // А вот саму переменную pet_name и ссылающуюся на неё ссылку pet_name_ref можно
    // использовать для изменения строки pet_name.
    pet_name += "po"s; 
    string& pet_name_ref = pet_name;
    pet_name_ref += "ld"s;
    
    cout << pet_name_ref << "'s name size is "s << pet_name_ref.size() << endl;
    // Выведет Leopold's name size is 7
}
```
Замена `string& text` на `const string& text` в функции `SplitIntoWords` не только говорит, что функция не изменит переданную ей строку, но защищает от ошибки и самого автора функции. Представьте, что вместо `word += c` он случайно написал бы `text += c`. Компиляция функции, которая принимает параметр `text` по константной ссылке, в этом случае завершится с ошибкой:
```
code.cpp: In function 'std::vector<std::__cxx11::basic_string<char> > SplitIntoWords(const string&)':
code.cpp:19:12: error: passing 'const string' {aka 'const std::__cxx11::basic_string<char>'} as 'this' argument discards qualifiers [-fpermissive]
    text += c;
            ^
In file included from <...>,
                 from code.cpp:3:
<...>/include/c++/bits/basic_string.h:1167:7: note:   in call to 'std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator+=(_CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]'
       operator+=(_CharT __c) 
```
Дословный перевод: «Передача `const string` в качестве аргумента this отбрасывает квалификаторы».

Эту ошибку вызвала инструкция `text += c;`. “Discards qualifiers” говорит о проблеме с константностью объекта. В данном случае проблема в том, что модифицирующую операцию `+=` нельзя применять к константной строке.

Встретив такую ошибку, не бросайтесь сразу убирать `const` с типа. Проверьте, что не перепутали изменяемый объект с другим. Если объект выбран верно, взгляните на функцию глазами пользователя: ожидаемо ли что функция изменит переданный ей параметр. Если в теле функции изменяется значение параметра, но для пользователей функции это нежелательное поведение, рассмотрите вариант с приёмом параметра по значению.

В этой программе функции `IsYes` и `IsNo` проверяют, ввёл ли пользователь одну из строк “yes” и “no” в произвольном регистре. Для этого они предварительно приводят переданные им строки к нижнему регистру.
```cpp
#include <iostream>

using namespace std;

void ToLower(string& text) {
    for (char& c : text) {
        c = tolower(c); // Переводим каждый символ строки к нижнему регистру
    }
}

bool IsYes(string& text) {
    ToLower(text);
    return text == "yes"s;
}

bool IsNo(string& text) {
    ToLower(text);
    return text == "no"s;
}

int main() {
    cout << "Do you like C++?"s << endl;
    string answer;
    getline(cin, answer);
    
    if (IsYes(answer)) {
        cout << ":)"s << endl;
    } else if (IsNo(answer)) {
        cout << ":(" << endl;
    } else {
        cout << "You entered '"s << answer << "'. Please enter yes or no"s << endl;
    }
}
 ```
Вряд ли пользователи функций `IsYes` и `IsNo` ожидают, что переданная в них строка изменится:
```
Do you like C++?
I don't know
You entered 'i don't know'. Please enter yes or no
```
Исправить этот недостаток можно несколькими способами.

- Явно создать копию переданного параметра и приводить её к нижнему регистру. В этом случае функция должна принимать свой аргумент по константной ссылке.

- Принимать строку по значению. Тогда любые действия над ней внутри функции не скажется на оригинальной строке.

```cpp
bool IsYes(string text) {
    // Аргумент text принимается по значению, 
    // поэтому можно свободно изменять содержимое text

    ToLower(text);
    return text == "yes"s;
}

bool IsNo(const string& text) {
    // Создаём и модифицируем копию text явно

    string text_in_lower_case = text;
    ToLower(text_in_lower_case);
    return text_in_lower_case == "no"s;
} 
```
То же самое с перебором в цикле по ссылке. Менять здесь элементы вектора автор кода не хотел:
```
for (string& word : query_words) {
    cout << '[' << word << ']' << endl;
} 
```
Чтобы не вводить никого в заблуждение, ссылку нужно сделать константной:

```cpp
for (const string& word : query_words) {
    cout << '[' << word << ']' << endl;
}
```

Константность этой ссылки поможет застраховаться от случайного изменения элементов вектора.