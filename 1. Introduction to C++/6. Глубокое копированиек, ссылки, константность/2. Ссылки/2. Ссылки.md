## Ссылки

Глубокое копирование приносит пользу не всегда. В этом уроке вы познакомитесь со ссылками. Они позволят избежать нежелательного копирования аргументов функций и элементов контейнера внутри цикла `for`.

Тип string — это строка. Когда вы объявляете переменную string word;, создаётся новая пустая строка. Когда вы объявляете строку и задаёте ей значение другой строки, например string word = value;, происходит глубокое копирование: строка word будет хранить копию строки value.

Если поставить символ амперсанд & после типа, вы объявите ссылку на этот тип. Например, string& — ссылка на строку. В отличие от переменной, ссылка не хранит само значение. Ссылка вводит ещё одно имя, по которому вы можете обратиться к существующему объекту.

![alt text](image.png)

Как кота не зовите, он останется тем же котом

Инициализация `string& word = value;` — не копирование данных, а создание новой связки ссылки и объекта. Вот как это выглядит:
```cpp
string search_query = "how to learn c+"s;
// Ссылка search_query_ref — ещё одно имя для доступа к переменной search_query
string& search_query_ref = search_query;  // ref — сокращение от reference (ссылка)

cout << search_query << endl;     // выведет how to learn c+

// добавляем символ '+' к строке search_query, используя ссылку search_query_ref
search_query_ref += '+';

cout << search_query << endl;     // выведет how to learn c++
cout << search_query_ref << endl; // выведет how to learn c++ 
```
Меняя `search_query_ref`, меняете и исходную переменную `search_query`. Но есть нюансы:
- Ссылку нельзя создать без инициализации — код `string& word_ref;` не скомпилируется. Это гарантирует, что любая ссылка в программе привязана к какому-либо объекту.
- Ссылку нельзя «перевесить» на другой объект. Код `search_query_ref` = `another_query`; не привяжет ссылку к объекту `another_query`, а присвоит переменной `search_query`, к которой привязана ссылка, новое значение из переменной `another_query`.

Ссылки часто используются внутри цикла, чтобы на очередной итерации работать с элементом контейнера, а не с его копией:
```cpp
for (string& word : query_words) {
        cout << '[' << word << ']' << endl;
}
```
Здесь ссылка string& word на каждой итерации цикла привязывается к очередному элементу вектора. Никакого копирования элементов не происходит. Приятный бонус: в таком цикле можно изменять элементы контейнера, используя имя word. Например, дописать точку в конец каждого слова запроса:
```cpp
for (string& word : query_words) {
        word.push_back('.');
}
```
Что выведет эта программа?
```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> numbers{1, 2, 3, 4, 5};
    for (int x : numbers) {
        x += 1;
    }
    for (int x : numbers) {
        cout << x << ", "s;
    }
} 
```

> `1, 2, 3, 4, 5,`



Переменная `x` на каждой итерации хранит копию текущего элемента массива. Изменение этой переменной не изменяет элементы массива.

Что выведет эта программа?
```
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> numbers{1, 2, 3, 4, 5};
    for (int& x : numbers) {
        x += 1;
    }
    for (int x : numbers) {
        cout << x << ", "s;
    }
} 

```

> `2, 3, 4, 5, 6,`


В этой программе `x` — это ссылка, которая на каждой итерации привязывается к текущему элементу массива. `x += 1` увеличивает этот элемент на единицу.

Часто ссылки используют, чтобы не копировать тяжеловесный объект при вызове функции:
```cpp
#include <iostream>
#include <vector>

using namespace std;

void PrintStrings(vector<string>& strings) {
    for (string& s : strings) {
        cout << '[' << s << "] "s;
    }
}

int main() {
    vector<string> words = {"white"s, "cat"s, "long"s, "tail"s};
    PrintStrings(words);
}
```
Вызов `PrintStrings(words)` привязывает ссылку `vector<string>& strings` к переменной `words` из функции `main`. При любом обращении к переменной `strings` внутри функции `PrintStrings` происходит обращение к исходному вектору строк `words`. Глубокое копирование вектора строк при вызове функции не происходит.

Часто параметры передают по ссылке, когда функция должна изменить их значение. С параметром-ссылкой легко написать функцию, которая удалит последнее слово из переданного в неё вектора:
```cpp
// Удаляет последнее слово из вектора слов
void RemoveLastWord(vector<string>& words) {
    if (!words.empty()) {
        // Метод pop_back удаляет последний элемент вектора
        // и тем самым противоположен методу push_back.
        // Этот метод можно безопасно вызывать только у непустого вектора
        words.pop_back();
    }
}
```
Пример вызова функции:
```cpp
string query = "white cat with green eyes"s;
vector<string> query_words = SplitIntoWords(query);
RemoveLastWord(query_words);
PrintStrings(query_words);
// выведет [white] [cat] [with] [green]  
```
Если убрать амперсанд из параметра и превратить ссылку на вектор строк в обычный вектор строк, вызывать функцию `RemoveLastWord` бессмысленно. В этом случае переданный вектор строк будет скопирован в параметр `words`. Что бы вы ни делали внутри этой функции с параметром `words`, на оригинальный вектор это не повлияет.