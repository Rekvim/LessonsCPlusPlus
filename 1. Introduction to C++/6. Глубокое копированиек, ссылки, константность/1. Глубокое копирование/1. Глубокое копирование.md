## Глубокое копирование
В этом уроке вы узнаете:

- что такое глубокое копирование объектов,
- когда оно происходит.

Посмотри́те на фрагмент кода:
```cpp
string search_query;
cin >> search_query;
string another_search_query = search_query;
```
Как думаете, что произойдёт со строками `search_query` и `another_search_query` после этих операций?

> Строки станут двумя объектами с одинаковым содержимым.

Они станут двумя самостоятельными объектами с одинаковым содержанием. Иными словами, случится глубокое копирование строки.

![alt text](image.png)

Так называют копирование, при котором изменения, внесённые в копию, не будут отражаться в оригинале. Похоже на редактирование копии файла документа: любые правки копии не затрагивают оригинальный документ.

Если изменить `another_search_query`, строка `search_query` останется прежней. И наоборот. 
```cpp
string search_query = "young white kitten"s;
string another_search_query = search_query;
another_search_query.insert(6, "-"s);  // вставляем ‘-’ перед буквой ‘w’

cout << search_query << endl; // выведет young white kitten

cout << another_search_query << endl; // выведет young -white kitten 
```
В C++ при вызове функции её аргументы копируются, и функция работает не с оригинальными значениями параметров, а с их копиями. Благодаря этому изменение параметров внутри функции не отражается на самих передаваемых значениях.
```cpp
#include <iostream>

using namespace std;

void Countdown(int n) {
    while (n >= 0) {
        cout << n << ' ';
        --n;
    }
    cout << endl;
}

int main() {
    int n = 5;
    Countdown(n); // Выведет 5 4 3 2 1 0
    cout << "n="s << n << endl; // Выведет n=5
}
```
В этой программе изменение значения `n` внутри функции `Countdown` никак не сказывается на значении переменной n внутри функции `main`: `n` внутри `Countdown`  — копия переменной `n` из функции `main`.

Такая передача параметров в функцию, при которой происходит копирование аргумента, называется передачей параметра по значению. В С++ по умолчанию все параметры функций передаются по значению. Это удобно: функция может делать что угодно со своими параметрами, не влияя на переменные из вызывающих её функций. Однако у удобства есть своя цена.

Создание копии файла требует некоторого времени и места на диске. Чем больше размер оригинала, тем больше места и времени нужно на его копирование. Операция `string another_search_query = search_query;` копирует содержимое исходной строки в новую. Если строка большая, процесс затянется. То же самое происходит и при передаче параметров функции по значению.

Вспомните функцию `SplitIntoWords` из пройденных задач:
```cpp
// ...
using namespace std;

vector<string> SplitIntoWords(string text) {
    vector<string> words;
    string word;
    for (char c : text) {
        if (c == ' ') {
            if (!word.empty()) {
                words.push_back(word);
                word.clear();
            }
        } else {
            word += c;
        }
    }
    if (!word.empty()) {
        words.push_back(word);
    }

    return words;
}

int main() {
    string query;
    getline(cin, query);
    vector<string> words = SplitIntoWords(query);
    
    for (string word : words) {
        cout << '[' << word << ']' << endl;
    }
}
```
Функция `SplitIntoWords` принимает параметр `text` по значению:
```cpp
vector<string> SplitIntoWords(string text) {
    // ...
}

int main() {
    ...
    vector<string> words = SplitIntoWords(query);
    ...
} 
```
Это значит, что строка `SplitIntoWords` получит копию строки `query`. Копия будет доступна внутри функции под именем `text`.

Второе копирование строк происходит в последнем цикле:
```cpp
for (string word : words) {
    cout << '[' << word << ']' << endl;
} 
```
Здесь тоже есть новая переменная — `word`. На каждой итерации цикла в неё будет копироваться очередная строка из вектора `words`.

Избавиться от нежелательных копирований легко — вы убедитесь в этом в следующем уроке.