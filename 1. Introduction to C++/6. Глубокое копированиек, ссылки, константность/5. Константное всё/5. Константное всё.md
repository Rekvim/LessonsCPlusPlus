## Константное всё

Модификатор `const` позволяет получить от ссылок неизменяемость исходного объекта. Но `const` способен на большее.

Тип `const string&` читается как «ссылка на `const string»`, где `const string` — самостоятельный тип, неизменяемая строка.

Создание переменной типа `const string`:
```
const string query = ReadString();

// Так ОК: для константной строки можно и узнать размер, и обратиться к символу
cout << query[query.size() - 2] << endl;

// Так нельзя: += изменяет строку
query += " free download"s; 
```
После создания константной строки изменить её значение будет нельзя. Например, строка `const string empty_string;` будет пустой. Константность `empty_string` нужна, чтобы застраховаться от случайного изменения объекта: будет странно, если в переменной `empty_string` будет непустая строка.

В C++ переменная сохраняет свой тип с момента объявления и до выхода из блока, в котором была объявлена. Если переменная была неконстантной, она останется такой до конца:

```cpp
int main() {
    // query объявлена неконстантной, 
    // чтобы в неё можно было считать значение функцией getline
    string query;
    getline(cin, query);
    // Начиная с этого места, мы хотим запретить изменять содержимое query
    
    int num_words = 0;
    char prev_char = ' ';
    for (char c : query) {
        if (c != ' ' && prev_char == ' ') {
            ++num_words;
        }
        prev_char = c;
    }

    cout << '\'' << query << "' contains "s << num_words << " words"s << endl;
}
```
Если во фрагменте кода нужно запретить изменять неконстантную переменную, фрагмент надо вынести в отдельную функцию. Заодно это сделает код более понятным:
```cpp
int CountWords(const string& text) {
    int num_words = 0;
    char prev_char = ' ';
    for (char c : text) {
        if (c != ' ' && prev_char == ' ') {
            ++num_words;
        }
        prev_char = c;
    }
    return num_words;
}

int main() {
    string query;
    getline(cin, query);
    // Код подсчёта слов вынесен в отдельную функцию, которая не может изменить query
    cout << '\'' << query << "' contains "s << CountWords(query) << " words"s << endl;
} 
```
Чтобы сделать переменную query неизменяемой, можно вынести код чтения строки в отдельную функцию:
```cpp
// ...

string ReadLine() {
    string line;
    getline(cin, line);
    return line;
}

int main() {
    // Значение переменной query теперь задаётся при её объявлении,
    // поэтому можно объявить эту переменную константной
    const string query = ReadLine();
    cout << '\'' << query << "' contains "s << GetNumWords(query) << " words"s << endl;
}
```
Константность помогает защитить переменные от случайных модификаций. Перед вами код парсинга запроса с учётом стоп-слов:
```cpp
// ...

int main() {
      // ...
    
        set<string> stop_words = ParseStopWords(stop_words_joined);
        
      // представьте, что здесь много-много кода
    
        string query;
        getline(cin, query);
        vector<string> query_words = ParseQuery(query, stop_words);
    
      // ...
} 
```
Допустим, этот код написали не вы. Или вы, но много лет назад. Теперь вы пытаетесь разобраться в инициализации `vector<string> query_words`. Что такое `query` понятно: эта строка создаётся и заполняется рядом. А вот `stop_words` инициализируется намного выше в коде. Вы нашли фрагмент, где вызывается функция `ParseStopWords`. Но нет гарантии, что с момента инициализации `stop_words` эту переменную не менял никакой новый код. 

Проверить, менялась ли переменная, бывает сложно. Даже если видны вызовы вроде `ParseQuery(query, stop_words)`, не исключено, что функция ParseQuery принимает параметр `stop_words` по неконстантной ссылке и изменяет содержимое `stop_words`. Есть несколько способов предотвратить подобные сложности.

1. Сделать переменную stop_words константной, если она не должна меняться после создания.
2. Сделать функции, в том числе main, компактными, чтобы не продираться через «простыню» кода, распутывая сложную судьбу переменной. Для уменьшения размера функций вынесите их самостоятельные части в другие функции.
3. Особым образом помечать имена аргументов функций, передаваемых по неконстантным ссылкам. Так принято в некоторых командах. Это приём скорее стилистический и требует дополнительных знаний.

Так можно объявить переменную stop_words константной:
```cpp
const set<string> stop_words = ParseStopWords(stop_words_joined);
```
Понять замысел автора станет гораздо проще. Так действует выразительное выделение слов в романе.
Применение типов вы видели ещё в трёх ситуациях.

1. Цикл `for` — `for (char c : text) { /* ... */ }`. Тут полезно заменить `char` на `const char`. Так вы отметите, что переменную `c` — символ везде в теле цикла — нельзя поменять.

2. Параметры функций, передаваемые по значению: `void UpdateIfGreater(int limit, int& value) { /* ... */ }`. Можно объявить `const int limit`, но часто в таких случаях `const` опускают, чтобы не делать заголовок функции ещё длиннее.

3. Возвращаемое значение функции: `vector<string> SplitIntoWords(const string& text) { /* ... */ }`. Нет смысла добавлять `const` к вектору. Ваше намерение не менять полученный из этой функции вектор лучше выразить в типе переменной, куда вы его положите.

Красота C++ — в его стройности и логичности.