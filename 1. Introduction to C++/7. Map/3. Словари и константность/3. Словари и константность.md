## Словари и константность

Операция `[]` — это удобный способ читать из словаря и менять в нём значения. Но она может сама по себе приводить к изменению — если ключа нет, он автоматически добавляется в словарь. А значит, возникнут проблемы с константными словарями.

Попробуем скомпилировать такой пример:

```cpp
const map<string, int> legs_count = {{"rabbit"s, 4}, {"dog"s, 4}, {"chicken"s, 2}};
int value = legs_count["dog"s]; // ошибка 
```
На первый взгляд всё хорошо, мы обращаемся по существующему ключу. Но компилятор продолжает указывать на ошибку:

```
test_func.cpp:10:33: error: passing ‘const std::map<std::__cxx11::basic_string<char>, int>’ as 
‘this’ argument discards qualifiers [-fpermissive]
int value = legs_count["dog"s];
^
In file included from /usr/include/c++/7/map:61:0,
from test_func.cpp:3:
/usr/include/c++/7/bits/stl_map.h:504:7: note: in call to ‘std::map<_Key, _Tp, _Compare, _Alloc>::
mapped_type& std::map<_Key, _Tp, _Compare, _Alloc>::operator[](std::map<_Key, _Tp, _Compare,
_Alloc>::key_type&&) [with _Key = std::__cxx11::basic_string<char>; _Tp = int; _Compare =
std::less<std::__cxx11::basic_string<char> >; 
_Alloc = std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >; std::map<_Key,
 _Tp, _Compare, _Alloc>::mapped_type = int; std::map<_Key,
 _Tp, _Compare, _Alloc>::key_type = std::__cxx11::basic_string<char>]’
operator[](key_type&& __k) 
```
Почему возникает ошибка?

> Действие операции [] подразумевает модификацию словаря при отсутствии в нём ключа. Поэтому для её использования словарь должен быть неконстантным.
Как вам задача?

Компилятор ориентируется только на типы. А тип словаря const `map<string, int>` не говорит о том, какой ключ есть, а какого нет. Поэтому компилятор должен быть готов к тому, что ключа `dog` в словаре не окажется, и придётся выполнить модификацию. Это приводит к ошибке: у неизменяемого объекта const map нельзя вызывать метод `operator[]`. Комментарий `discards qualifiers` часто появляется именно из-за попытки изменить константный объект.

Чтобы словарь не обновлялся при запросе неизвестного ключа, применяют метод `at()`. Он действует аналогично квадратным скобкам, но не даёт возможности обратиться к словарю по несуществующему ключу. С константными словарями теперь можно работать:
```cpp
const map<string, int> legs_count = {{"rabbit"s, 4}, {"dog"s, 4}, {"chicken"s, 2}};
int value = legs_count.at("dog"s); // как и для других методов круглые скобки 
```
Если всё же обратиться по несуществующему ключу, возникнет специальная ошибка — исключение.

<div class="callout">
Исключения — отдельная большая тема, которая будет подробно раскрыта далее в курсе. В отличие от ошибок компиляции они возникают, когда программа уже выполняется. На них можно отреагировать и обработать их. Как правило, в исключениях содержится информация о том, почему и при каких обстоятельствах они произошли.
</div>

Код с `at()` скомпилируется:
```cpp
const map<string, int> birds_amount = {{"chicken"s, 2}, {"duck"s, 3}, {"goose"s, 2}};
cout << birds_amount.at("bat"s) << endl; 
```
Но во время исполнения во второй строке появится исключение:
```
terminate called after throwing an instance of 'std::out_of_range'
  what():  map::at
Aborted (core dumped) 
```
Сообщение говорит, что после выбрасывания исключения `std::out_of_range` была вызвана команда `terminate`. Эта команда вызывается, чтобы завершить работу программы, если исключение не было обработано.

Казалось бы, что хорошего в экстренном завершении программы. На самом деле так выражается её забота о своём стабильном состоянии. Если бы проверки на существование ключа не было, программа могла повести себя непредсказуемо, и все дальнейшие результаты не были бы надёжными. Чтобы этого избежать, программа сообщает разработчику о проблеме.

Обработка исключений не входит в наши ближайшие планы, поэтому пока что будем следить за тем, чтобы обращаться только по существующим ключам. Для этого можно проверять наличие ключа с помощью метода `count()`. Этот метод возвращает количество элементов с ключом. Если количество элементов не равно нулю, обращаться по ключу безопасно.
```cpp
const map<string, int> birds_amount = {{"chicken"s, 2}, {"duck"s, 3}, {"goose"s, 2}};
if (birds_amount.count("penguin"s) != 0) {
    // Этот код не будет вызван.
    cout << birds_amount.at("penguin"s) << endl;
}
if (birds_amount.count("duck"s) != 0) {
    cout << birds_amount.at("duck"s) << endl;
}
```
Для неконстантного словаря метод `at()` возвращает изменяемую ссылку на элемент. Поэтому если прилетят ещё две утки, код отработает без проблем:
```cpp
map<string, int> birds_amount = {{"chicken"s, 2}, {"duck"s, 3}, {"goose"s, 2}};
birds_amount.at("duck"s) += 2 
```
Есть аналогичный метод и у вектора:
```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> prices = {100, 235, 333};
    cout << prices.at(3) << endl;
} 
```
Поведение этого метода при обращении по несуществущему индексу вполне предсказуемо, в отличие от квадратных скобок. Оно аналогично поведению словаря: будет выброшено исключение с подробным описанием ошибки. 
```cpp
terminate called after throwing an instance of 'std::out_of_range'
  what():  vector::_M_range_check: __n (which is 3) >= this->size() (which is 3)
Aborted (core dumped) 
```
С методом at у словаря и вектора всё одинаково: есть ключ — получаем значение, нет ключа — получаем исключение. А вот с операцией `[]` дело обстоит по-разному. Опишем поведение этой операции таблицей:

|`[]`| есть ключ или индекс|	нет ключа или индекса|
|:-:|:-:|:-:|
`vector`	|Ok	|неопределённое поведение
`const` vector|	Ok	|неопределённое поведение
`map`	|Ok	|добавляется элемент со значением по умолчанию
`const map`	|ошибка компиляции|	ошибка компиляции

На этом основные сведения о `map` заканчиваются. С ним вам предстоит встретиться ещё не раз. Контейнер `map` не так прост, как кажется на первый взгляд.