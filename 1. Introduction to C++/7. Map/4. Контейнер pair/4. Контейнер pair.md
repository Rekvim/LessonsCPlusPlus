## Контейнер pair

Фраза о том, что словари хранят пары «ключ-значение», — это не метафора. В реализации контейнера `map` есть деталь — контейнер `pair`, состоящий из пары значений разного типа.

Вы уже итерировались по вектору и множеству, используя range-based for. Теперь нужно сделать то же для `map`. Только в этот раз использовать `auto`:

```cpp
map<string, int> legs_count = {{"dog"s, 4}, {"ostrich"s, 2}};

// Аналогично for (const pair<string, int>& entry : legs_count)
for (const auto& entry : legs_count) {
    // здесь надо обратиться к содержимому
} 
```
Тип `entry` — пара из строки и целого числа `pair<string, int>`. При создании словаря пара была записана внутри фигурных скобок. Обратиться к элементам пары просто: `.first` — это первый элемент, ключ, а `.second` — второй, значение.
```cpp
map<string, int> legs_count = {{"dog"s, 4}, {"ostrich"s, 2}};
for (const auto& entry : legs_count) {
    cout << entry.first << " : "s << entry.second << endl;
}
```
Используя `auto`, можно также декомпозировать содержимое пары, то есть связать имена в программе с полями `first` и `second`. Названия переменных `animal` и `leg_count` из версии `for (const auto& [animal, leg_count])` гораздо приятнее бездушного `entry.first` и `entry.second`:

```cpp
map<string, int> legs_count = {{"dog"s, 4}, {"ostrich"s, 2}};

// Имена animal и leg_count ссылаются на ключ и значение, соответственно:
for (const auto& [animal, leg_count] : legs_count) {
    cout << animal << " : "s << leg_count << endl;
}
```
На выходе будет нечто знакомое:
```
dog : 4
ostrich : 2
```
Пару из двух значений можно создать на лету фигурными скобками, а затем вставить в словарь методом `insert()` как ключ и значение:

```cpp
const auto [octopus_iterator, success] = legs_count.insert({"octopus"s, 8}); 
```
Метод `insert()` не только принимает, но и возвращает пару. Она состоит из:

- итератора `octopus_iterator`, который указывает на добавленный элемент,

- булева значения `success`. Оно равно `true`, если вставка удалась, то есть такой записи в словаре ещё не было. В противном случае значение равно `false`.

`pair` может работать как вместе с `map`, так и самостоятельно.