## Как работают множества

Сохранить массив ключевых слов для поиска можно в векторе строк `vector<string> words`. Чтобы проверить наличие конкретного слова, нужно пройтись по вектору циклом range-based for и вернуть результат:

```cpp
vector<string> words;
string word_to_find;
// ...
bool found = false;
for (string word : words) {
    if (word == word_to_find) {
        found = true;
    }
} 
```

Но представьте, как обидно потратить время на просмотр всех элементов вектора и не найти нужный. К счастью, в С++ есть контейнер для быстрого поиска объектов. Он называется `set`.

`set`, или множество, — это упорядоченный набор уникальных элементов. «Упорядоченный» означает, что внутри `set` элементы хранятся в определённом порядке — по умолчанию в порядке возрастания. За счёт этого поиск в контейнере `set` работает быстрее, чем полный перебор элементов вектора. Например, вы быстро найдёте нужное слово среди ключевых слов поиска. Уникальность элементов означает, что каждый элемент внутри множества может храниться только в одном экземпляре.
Используем множество и перепишем пример выше:
```cpp
set<string> words;
string word_to_find;
// ...
// Метод count возвращает количество вхождений элемента внутри множества.
bool found = words.count(word_to_find) != 0;
```

Вместо цикла применяется метод `count` — с ним код короче и эффективнее, чем последовательный цикл, особенно при большом количестве элементов.

Создание множества синтаксически похоже на создание вектора. Чтобы объединить в множество животных — в том числе трубкозуба, — подключите библиотеку `<set>`, укажите тип элементов множества и перечислите элементы в фигурных скобках:
```cpp
#include <iostream>
#include <set>

using namespace std;

void PrintSet(set<string> s) {
    for (string x : s) {
        cout << x << endl;
    }
}

int main() {
    set<string> animals = {"cat"s, "dog"s, "aardvark"s, "dog"s, "sheep"s, "ape"s, "sheep"s};
    PrintSet(animals);
}
```
Программа выведет:
```
aardvark
ape
cat
dog
sheep 
```
Имена животных при выводе содержимого `set` упорядочены по возрастанию, а не в порядке их упоминания в фигурных скобках. В данном случае — по алфавиту. Также строки dog и sheep были выведены только один раз. Это из-за того, что в множестве элементы хранятся без дубликатов.

Как и у векторов и строк, у множества есть метод `size()`, возвращающий количество элементов. Чтобы проверить множество на пустоту, примените метод `empty()`. Он возвращает значение типа `bool`:
```cpp
//...

int main() {
    set<string> animals = {"cat"s, "dog"s, "aardvark"s, "dog"s, "sheep"s, "ape"s, "sheep"s};
    if (!animals.empty()) {
        cout << "There are some animals in the set,"s << endl;
        cout << animals.size() << " different animals, to be exact."s;
    }
} 
```
Программа выведет:
```
There are some animals in the set,
5 different animals, to be exact.
```
Для добавления новых элементов внутрь множества используйте метод `insert()`. После вставки упорядоченность элементов множества сохранится:
```cpp
// ...

int main() {
    set<string> animals = {"cat"s, "dog"s, "aardvark"s, "dog"s, "sheep"s, "ape"s, "sheep"s};
    PrintSet(animals);
    cout << endl;
    animals.insert("another dog"s);
    animals.insert("cat"s);
    animals.insert("penguin"s);
    PrintSet(animals);
}
```
Программа выведет:
```
aardvark
ape
cat
dog
sheep

aardvark
another dog
ape
cat
dog
penguin
sheep
```
Добавленные животные заняли свои места в алфавитном порядке. Повторное добавление кошки проигнорировано — это имя уже есть в множестве.

Чтобы удалить элементы из `set`, вызовите метод `erase()`:
```cpp
// ...

int main() {
    set<string> animals = {"cat"s, "dog"s, "aardvark"s, "dog"s, "sheep"s, "ape"s, "sheep"s};
    PrintSet(animals);
    cout << endl << "Some animals are gone!"s << endl << endl;
    animals.erase("cat"s);
    animals.erase("dog"s);
    animals.erase("ape"s);

    // Удаление отсутствующего элемента не делает ничего
    animals.erase("mouse"s);

    PrintSet(animals);
}
```
Удаление элемента, которого в множестве нет, будет проигнорировано. Например, в этой программе среди животных изначально не было мышей, поэтому инструкция `animals.erase("mouse"s);` ничего не сделает.

Результат:
```
aardvark
ape
cat
dog
sheep

Some animals are gone!

aardvark
sheep 
```
Контейнер `set` автоматически сортирует элементы и удаляет дубликаты. Поэтому при большом количестве элементов он эффективнее, чем вектор.