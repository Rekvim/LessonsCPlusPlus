## Ошибки компиляции

C++ печально известен длинными сообщениями об ошибках. Но эти сообщения позволяют устранить часть проблем уже на этапе компиляции. 

Чтобы сгенерировать машинный код, компилятор анализирует ваш код целиком и выявляет ошибки. Если их исправить, компиляция пройдёт успешно. Такие ошибки называют ошибками компиляции, хотя на самом деле это ошибки программиста.

Компиляторов существует множество. Причём в разных компиляторах один и тот же код, скорее всего, получит разные сообщения об ошибках. Чтобы сберечь нервы, программист выбирает для работы конкретный компилятор и полагается на него.

В этом курсе используется компилятор g++. Он доступен практически на любой платформе.

### Забыта директива #include

Распространённая ошибка — вы пропустили директиву `#include`, которая подключает нужную библиотеку.
```cpp
using namespace std;

int main() {
    cout << "Hello, world" << endl;
}
```
Скомпилируем программу и увидим сообщение компилятора:
```
prog.cc: In function 'int main()':
prog.cc:4:5: error: 'cout' was not declared in this scope
    4 |     cout << "Hello, world" << endl;
      |     ^~~~
prog.cc:1:1: note: 'std::cout' is defined in header '<iostream>'; did you forget to '#include <iostream>'?
  +++ |+#include <iostream>
    1 | using namespace std;
prog.cc:4:31: error: 'endl' was not declared in this scope
    4 |     cout << "Hello, world" << endl;
      |                               ^~~~
prog.cc:1:1: note: 'std::endl' is defined in header '<ostream>'; did you forget to '#include <ostream>'?
  +++ |+#include <ostream>
    1 | using namespace std;
```
Здесь компилятор сообщает, что слово `cout` не было объявлено, и помогает: «`std::cout `объявлен в заголовочном файле <iostream>. Вы не забыли написать `#include <iostream>`?»

Добавим директиву `#include`, но при этом неправильно напишем имя файла:

```cpp
#include <iosteam> // Ошибка допущена умышленно.

using namespace std;

int main() {
    cout << "Hello, world" << endl;
} 
```
Программа снова выдаст ошибку:
```
prog.cc:1:10: fatal error: iosteam: No such file or directory
    1 | #include <iosteam>
      |          ^~~~~~~~~~~
compilation terminated. 
```
Исправим опечатку в имени файла, заменив #`include <iosteam>` на `#include <iostream>`. Программа выведет заветное “Hello, world”.

### Нет using namespace std

Другая частая ошибка — забыли написать `using namespace std`.
```cpp
#include <iostream>

int main() {
    cout << "Hello, world"s << endl;
}
```
Здесь компилятор снова сообщает, что слово `cout` не найдено, но теперь задаёт уточняющий вопрос: «А не `std::cout` ли вы имеете в виду»?
```
prog.cc: In function 'int main()':
prog.cc:4:5: error: 'cout' was not declared in this scope; did you mean 'std::cout'?
    4 |     cout << "Hello, world"s << endl;
      |     ^~~~
      |     std::cout
In file included from prog.cc:1:
/opt/wandbox/gcc-10.1.0/include/c++/10.1.0/iostream:61:18: note: 'std::cout' declared here
   61 |   extern ostream cout;  /// Linked to standard output
      |                  ^~~~
... Подобная ошибка, связанная с endl
```
Если напишете `using namespace std;`, сможете использовать короткие имена, объявленные в стандартной библиотеке C++, а не полные, такие как `std::cout` и `std::endl`.

### Неверное обозначение строковых литералов

Следующую ошибку часто делают программисты, работавшие с языками, где в строковых литералах можно использовать и двойные, и одинарные кавычки. Например, Python и JavaScript. В C++ одинарные и двойные кавычки имеют разное значение:
```cpp
#include <iostream>

using namespace std;

int main() {
    cout << 'Hello, world' << endl;
}
```
Одинарные кавычки задают символьную константу, значение которой — целое число, равное коду символа внутри кавычек. Несколько символов внутри одинарных кавычек компилятор считает подозрительными и выдаёт предупреждение или ошибку, в зависимости от своих настроек.

Скомпилируем программу и увидим сообщение об ошибке:

```
prog.cc:6:13: error: character constant too long for its type [-Werror]
    6 |     cout << 'Hello, world' << endl;
      |             ^~~~~~~~~~~~~~ 
```

Здесь компилятор сообщает, что символьная константа `'Hello, world'` слишком длинная для своего типа. Чтобы исправить ошибку, замените одинарные кавычки на двойные.

Забыт `return` в функции, возвращающей значение

Следующая программа выглядит, на первый взгляд, вполне корректно:

```cpp
#include <iostream>

using namespace std;
    
int Main() {
    cout << "Hello world"s << endl;
} 
```
Однако при её компиляции возникнет ошибка:

prog.cc: In function 'int Main()':

prog.cc:7:1: error: no return statement in function returning non-void [-Werror=return-type] 

Компилятор сообщает, что в функции `Main`, возвращающей непустое значение, нет оператора `return`. Этот оператор возвращает значение из функции. Функция `Main` должна вернуть целое число, об этом говорит тип int перед её именем. Здесь указано имя `Main` вместо `main`. В C++ регистр символов в идентификаторах важен: `main` и `Main` — разные функции. 

Функция `main` — особенная. В ней разрешается не писать `return`, тогда после выполнения последней инструкции функция `main` автоматически вернёт нулевое значение. Оно означает успешное завершение программы. 

Чтобы исправить ошибку, достаточно заменить имя функции на `main`.

### Инструкции за пределами функций

В C++ переменные можно объявить как внутри, так и вне функций. Однако прочие инструкции могут располагаться только в теле функции. Если написать их вне функции, получите ошибку компиляции. В этой программе все инструкции находятся вне функции `main`: 

```cpp
#include <iostream>

using namespace std;
    
cout << "Enter two numbers x and y:"s << endl;
int x, y;
cin >> x >> y;
cout << x << " + "s << y << " = "s << x + y << endl;

int main() {
} 
```
Компилятор сообщит, что в начале 5, 7 и 8 строк ожидает увидеть имя типа переменной или возвращаемого значения функции:
```
errors_0.cpp:5:1: error: 'cout' does not name a type
    5 | cout << "Enter two numbers x and y:"s << endl;
      | ^~~~
errors_0.cpp:7:1: error: 'cin' does not name a type
    7 | cin >> x >> y;
      | ^~~
errors_0.cpp:8:1: error: 'cout' does not name a type
    8 | cout << x << " + "s << y << " = "s << x + y << endl;
      | ^~~~ 
```
Переместим инструкции внутрь `main`:
```cpp
#include <iostream>

using namespace std;
    
int main() {
    cout << "Enter two numbers x and y:"s << endl;
    int x, y;
    cin >> x >> y;
    cout << x << " + "s << y << " = "s << x + y << endl;
} 
```
Проблема решена:

```
Enter two numbers x and y:
2 5
2 + 5 = 7 
```

### Некорректное чтение переменных

Эта программа похожа на предыдущую на 99%. Сколько у вас уйдёт времени, чтобы найти в ней отличие в пару символов?

```cpp
#include <iostream>

using namespace std;
    
int main() {
    cout << "Enter two numbers x and y:"s << endl;
    int x, y;
    cin >> x, y;
    cout << x << " + "s << y << " = "s << x + y << endl;
} 
```
Компилятору понадобятся доли секунды, чтобы найти в программе две проблемы:

```
errors_1.cpp: In function 'int main()':
errors_1.cpp:8:16: error: right operand of comma operator has no effect [-Werror=unused-value]
    8 |     cin >> x, y;
      |                ^
errors_1.cpp:9:33: error: 'y' may be used uninitialized in this function [-Werror=maybe-uninitialized]
    9 |     cout << x << " + "s << y << " = "s << x + y << endl;
      |                                 ^~~~~~
cc1plus.exe: all warnings being treated as errors 
```

Строка `cin >> x, y;` считывает значение только в переменную `x`. Из-за этого значение переменной `y` будет неинициализированным в момент вывода. Об этом сообщает ошибка `'y' may be used uninitialized in this function`. Чтобы исправить ошибку, надо верно написать команду считывания переменных: `cin >> x >> y`;.

### Неверная раскладка клавиатуры

Иногда ошибка может быть в прямом смысле слова не видна невооружённым глазом:

```cpp
#include <iostream>

using namespace std;
    
int main() {
    сout << "Hello world" << endl;
} 
```

Но от зорких глаз компилятора она не скроется:

```
prog.cc: In function 'int main()':
prog.cc:6:5: error: '\U00000441out' was not declared in this scope
    6 |     сout << "Hello world" << endl;
      |     ^~~~ 
```

Компилятор нашёл идентификатор со странным именем `\U00000441out`. Здесь в слове `cout` вместо английской буквы “c” написана русская «с». Такое часто случается, ведь на клавиатуре эти буквы находятся на одной и той же клавише. В сообщениях об ошибках символы, выходящие за пределы английского алфавита, пробела, цифр и символов пунктуации, компилятор g++ отображает в виде их числовых кодов.

В этом уроке мы рассмотрели несколько ошибок, возникающих из-за невнимательности программиста. Потренируйтесь обнаруживать их. Внимательно читайте сообщения компилятора, они содержат ключ к решению проблемы.